---
description: Get Start!
---

# 第1章 你好并发世界

## 第1章 你好并发世界

什么是并发？在单核时代想要运行多个任务同时运行，实际上每刻只有一个任务在运行，其他则要进行等待。但是多核心下，有多个核心可以分别运行不同的任务，则即使同一个任务也可以在不同的核心之间切换，尽可能地让任务等待的时间变得更少。所有的代码实例都将在ubuntu下g++编译器下编译运行。

### 并发的方式

* 多进程通信 通信方式主要有信号、套接字、文件、管道等等，通常这些方式效率不尽人意，因为操作系统会对进程进行保护。
* 多线程并发 在单进程中运行多个线程。线程很像轻量级的进程：每个线程相互独立运行，并且可以 在不同的指令序列中运行。不过，进程中的所有线程都共享地址空间 地址空间共享，以及缺少线程间的数据保护，使得操作系统记录的工作量减小，所以使用多线程的开销远远 小于多进程。不过，共享内存的灵活性是有代价的：如果多个线程访问数据，那么必须确保每个线程所访问 到的数据一致，这就需要对线程通信做大量的工作

### 为什么使用并发

* 关注点分离 通过将相关的代码与无关的代码分离，可以使程序更容易理解和测 试，从而减少出错的可能。即使一些操作需要同时进行，依旧可以使用并发，分离不同的功能区域。若不显 式地使用并发，就得编写一个任务切换机制，或者在操作中主动地调用一段不相关的代码。例如交互界面可以一直实时响应，但后面的任务处理可能需要进行工作一定时间，虽然我们看到的是光标一直转，但如果没了并发，那么就要停一会界面，停一会要处理的任务。
* 性能 将一个单个任务分成几部分并行运行，从而降低总运行时间、一个线程执行算法的一部分，而另一个线程执行算法的另一个部分、每个线程在不同的数据块上执行相同的操作。

### 什么时候不使用并发

收益比不上成本、代码开发与维护成本。

线程资源有限、线程不能无限分配，每个线程都需要自己堆栈。

客户端服务端，如果为每个链接启动一个独立的线程，请求过多时会造成消耗过大，通常采用线程池方案解决

线程越多、操作系统就需要越多的上下文切换，每一次切换都需要耗费时间，如果要得到系统的最佳性能，要以考虑硬件并发，调整运行线程的数量。

### 第一个并发程序

```cpp
#include <iostream>
#include <thread>

//线程任务入口函数
void hello()
{
    std::cout << "Hello Concurrent World" << std::endl;
}

int main(int argc, char **argv)
{
    std::thread t(hello); //开启新的线程
    t.join();             //等待线程t的结束
    return 0;
}
//程序输出 Hello Concurrent World
```

如何编译，本质上还是用了pthread库，但是c++从c++11标准支持了相应的接口，也就是为多平台的代码同意做了有效的工作。

```bash
g++ example1.cpp -o example1.exe -std=c++11 -lpthread  && ./example1.exe
```
