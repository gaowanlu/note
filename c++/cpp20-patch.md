# ğŸŒ C++20 ç‰¹æ€§

C++20 å¼•å…¥äº†è®¸å¤šæ–°ç‰¹æ€§å’Œè¯­è¨€æ”¹è¿›ï¼Œä¸‹é¢æ˜¯å…¶ä¸­ä¸€äº›ä¸»è¦çš„ç‰¹æ€§ï¼š

1ã€æ¦‚å¿µï¼ˆConceptsï¼‰ï¼šC++20 å¼•å…¥äº†æ¦‚å¿µçš„æ¦‚å¿µï¼Œå…è®¸ç¨‹åºå‘˜åœ¨ç¼–å†™æ¨¡æ¿ä»£ç æ—¶æŒ‡å®šå‚æ•°å¿…é¡»æ»¡è¶³çš„ç±»å‹çº¦æŸã€‚

2ã€æ¨¡å—ï¼ˆModulesï¼‰ï¼šC++20 å¼•å…¥äº†æ¨¡å—ï¼Œå…è®¸ç¨‹åºå‘˜å°†ä»£ç åˆ†å‰²ä¸ºé€»è¾‘å•å…ƒï¼Œå‡å°‘äº†å¤´æ–‡ä»¶åŒ…å«å¸¦æ¥çš„ç¼–è¯‘æ—¶é—´å’ŒäºŒè¿›åˆ¶æ–‡ä»¶å¤§å°ã€‚

3ã€åç¨‹ï¼ˆCoroutinesï¼‰ï¼šC++20 å¼•å…¥äº†åç¨‹ï¼Œä½¿å¾—å¼‚æ­¥ç¼–ç¨‹å˜å¾—æ›´åŠ ç®€å•å’Œé«˜æ•ˆã€‚

4ã€åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°æ¨¡æ¿ï¼ˆTemplate for Initialization List Constructorsï¼‰ï¼šC++20 å…è®¸ä½¿ç”¨æ¨¡æ¿å®šä¹‰åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°ï¼Œä»è€Œæ”¯æŒæ›´å¤šçš„åˆå§‹åŒ–æ–¹å¼ã€‚

5ã€constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹ä¸å†æœ‰é™åˆ¶ï¼ˆRelaxing Constraints on constexpr Functionsï¼‰ï¼šC++20 å…è®¸ constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œè€Œä¸å†æœ‰é™åˆ¶ã€‚

6ã€ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ï¼ˆConstexpr Null Pointerï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€ä¸ªæ–°çš„ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ std::nullptr_tï¼Œå…è®¸åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ›´å®‰å…¨çš„ç©ºæŒ‡é’ˆæ£€æŸ¥ã€‚

7ã€ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼ˆCompile-Time String Operationsï¼‰ï¼šC++20 å¼•å…¥äº†ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œå­—ç¬¦ä¸²çš„æ‹¼æ¥ã€æˆªå–å’Œè½¬æ¢ç­‰æ“ä½œã€‚

8ã€å¤šçº¿ç¨‹åº“æ”¹è¿›ï¼ˆImprovements to the Thread Libraryï¼‰ï¼šC++20 æ”¹è¿›äº†å¤šçº¿ç¨‹åº“ï¼Œå¼•å…¥äº†ä¸€äº›æ–°çš„ç‰¹æ€§ï¼Œå¦‚åŒæ­¥é˜Ÿåˆ—ã€é”å‡çº§ã€çº¿ç¨‹å±€éƒ¨å­˜å‚¨ç­‰ã€‚

9ã€å…ƒç¼–ç¨‹æ”¹è¿›ï¼ˆImprovements to Metaprogrammingï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€äº›å…ƒç¼–ç¨‹æ”¹è¿›ï¼Œå¦‚ consteval å‡½æ•°ã€requires è¡¨è¾¾å¼ã€typename åœ¨æ¨¡æ¿å‚æ•°åˆ—è¡¨ä¸­çš„ä½ç½®æ›´åŠ çµæ´»ç­‰ã€‚

10ã€ä¸‰è·¯æ¯”è¾ƒæ“ä½œç¬¦

11ã€å¼‚å¸¸è§„èŒƒ

12ã€åˆå§‹åŒ–ä¸Šä¸‹æ–‡ä¼˜åŒ–

13ã€ç±»å‹ç‰¹æ€§ä¿®æ”¹å’Œå¢å¼º

14ã€std::rangesåº“

15ã€æ•è·åˆå§‹åŒ–

16ã€çº¿ç¨‹æœ¬åœ°å­˜å‚¨

17ã€ç»Ÿä¸€çš„æ„é€ å’Œææ„

18ã€æ•°å­¦åˆ†éš”ç¬¦

19ã€åŒæ­¥é˜Ÿåˆ—

20ã€å…¶ä»–ç»†èŠ‚æ”¹è¿›ï¼šC++20 è¿˜å¼•å…¥äº†ä¸€äº›å…¶ä»–çš„ç»†èŠ‚æ”¹è¿›ï¼Œå¦‚ä¸‰å‘æ¯”è¾ƒæ“ä½œç¬¦ã€æ ¼å¼åŒ–å­—ç¬¦ä¸²å‡½æ•° std::format()ã€std::span å®¹å™¨ã€æ ‡å‡†åº“ä¸­å¯¹æ–‡ä»¶ç³»ç»Ÿçš„æ”¯æŒç­‰ã€‚

## ä¸‰å‘æ¯”è¾ƒ

### å¤ªç©ºé£èˆ¹ spaceship è¿ç®—ç¬¦

C++20æ ‡å‡†æ–°å¼•å…¥äº†ä¸€åä¸ºâ€œå¤ªç©ºé£èˆ¹â€(spaceship)çš„è¿ç®—ç¬¦`<=>`ã€‚å®ƒæ˜¯ä¸€ä¸ªä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ã€‚`<=>`å¹¶ä¸æ˜¯C++20é¦–åˆ›çš„ï¼Œå®é™…ä¸ŠPerlã€PHPã€Rubyç­‰è¯­è¨€æ—©å·²æ”¯æŒäº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼ŒC++æ˜¯åæ¥çš„å­¦ä¹ è€…ã€‚

```cpp
// lhs <=> rhs
// å¯èƒ½äº§ç”Ÿä¸‰ç§ç»“æœ è¯¥ç»“æœå¯ä»¥å’Œ0æ¯”è¾ƒ
// å°äº0 lhs < rhs
// ç­‰äº0 lhs == rhs
// å¤§äº0 lhs > rhs
#include <iostream>
using namespace std;

int main()
{
    bool b = 7 <=> 11 < 0;
    std::cout << b << std::endl; // 1
    return 0;
}
```

è¿ç®—ç¬¦`<=>`çš„è¿”å›å€¼åªèƒ½ä¸0å’Œè‡ªèº«ç±»å‹æ¥æ¯”è¾ƒï¼Œå¦‚æœåŒå…¶ä»–æ•°å€¼æ¯”è¾ƒï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

```cpp
bool b = 7 <=> 11 < 100; // ç¼–è¯‘å¤±è´¥,<=>çš„ç»“æœä¸èƒ½ä¸0ä¹‹å¤–çš„æ•°å€¼æ¯”è¾ƒ
```

### ä¸‰å‘æ¯”è¾ƒçš„è¿”å›ç±»å‹

å¯ä»¥çœ‹å‡º`<=>`çš„è¿”å›ç»“æœå¹¶ä¸æ˜¯ä¸€ä¸ªæ™®é€šç±»å‹ï¼Œæ ¹æ®æ ‡å‡†ä¸‰å‘æ¯”è¾ƒä¼šè¿”å›3ç§ç±»å‹ï¼Œè€Œè¿™3ç§ç±»å‹åˆä¼šåˆ†ä¸ºæœ‰3ï½4ç§æœ€ç»ˆç»“æœã€‚

```cpp
std::strong_ordering
std::weak_ordering
std::partial_ordering
```

### std::strong_ordering

```cpp
// è¡¨è¾¾å¼ lsh <=> rhs
std::strong_ordering
    - std::strong_ordering::less    å¯¹åº” lhs  < rhs
    - std::strong_ordering::equal   å¯¹åº” lhs == rhs
    - std::strong_ordering::greater å¯¹åº” lhs  > rhs
```

`std::strong_ordering` ç±»å‹çš„ç»“æœå¼ºè°ƒçš„æ˜¯strongçš„å«ä¹‰ï¼Œè¡¨è¾¾çš„æ˜¯ä¸€ç§å¯æ›¿æ¢æ€§ï¼Œç®€å•æ¥è¯´ï¼Œè‹¥`lhs == rhs`ï¼Œé‚£ä¹ˆåœ¨ä»»ä½•æƒ…å†µä¸‹rhså’Œlhséƒ½å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) == fx(rhs)`ã€‚

å¯¹äºåŸºæœ¬ç±»å‹ä¸­çš„intç±»å‹ï¼Œä¸‰å‘æ¯”è¾ƒè¿”å›çš„æ˜¯`std::strong_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <iostream>

using namespace std;

int main()
{
    std::cout << typeid(decltype(7 <=> 11)).name();
    // St15strong_ordering
    return 0;
}
```

å¯¹äºæœ‰å¤æ‚ç»“æ„çš„ç±»å‹ï¼Œ`std::strong_ordering` è¦æ±‚å…¶æ•°æ®æˆå‘˜å’ŒåŸºç±»çš„ä¸‰å‘æ¯”è¾ƒç»“æœéƒ½ä¸º`std::strong_ordering`ã€‚ä¾‹å¦‚ï¼š

é»˜è®¤æƒ…å†µä¸‹è‡ªå®šä¹‰ç±»å‹æ˜¯ä¸å­˜åœ¨ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œéœ€è¦ç”¨æˆ·æ˜¾å¼é»˜è®¤å£°æ˜ã€‚

```cpp
#include <iostream>
#include <compare>

using namespace std;

class B
{
public:
    int a;
    long b;
    auto operator <=> (const B&) const = default;
};

class D : public B
{
public:
    short c;
    auto operator <=> (const D&) const = default;
};

int main()
{
    D x1, x2;
    std::cout << typeid(decltype(x1 <=> x2)).name() << std::endl;
    // St15strong_ordering
    return 0;
}
```

å¯¹ç»“æ„ä½“Bè€Œè¨€ï¼Œç”±äºintå’Œlongçš„æ¯”è¾ƒç»“æœéƒ½æ˜¯`std::strong_ordering`ï¼Œå› æ­¤ç»“æ„ä½“Bçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¹Ÿæ˜¯`std::strong_ordering`ã€‚  
å¯¹ç»“æ„ä½“Dï¼Œå…¶ åŸºç±» å’Œ æˆå‘˜ çš„æ¯”è¾ƒç»“æœæ˜¯`std::strong_ordering`ï¼ŒDçš„ä¸‰å‘æ¯”è¾ƒç»“æœåŒæ ·æ˜¯`std::strong_ordering`ã€‚

### std::weak_ordering

```cpp
lhs <=> rhs
    - std::weak_ ordering::less      å¯¹åº” lhs < rhs
    - std::weak_ordering::equivalent å¯¹åº” lhs == rhs
    - std::weak_ ordering::greater   å¯¹åº” lhs > rhs
```

weakè¡¨è¾¾çš„æ˜¯ä¸å¯æ›¿æ¢æ€§ã€‚å³è‹¥æœ‰`lhs == rhs`ï¼Œåˆ™rhså’Œlhsä¸å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) != fx(rhs)`ã€‚è¿™ç§æƒ…å†µåœ¨åŸºç¡€ç±»å‹ä¸­å¹¶æ²¡æœ‰ï¼Œä½†æ˜¯å®ƒå¸¸å¸¸å‘ç”Ÿåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»ä¸­ï¼Œæ¯”å¦‚ä¸€ä¸ªå¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼š

```cpp
#include <iostream>
#include <compare>
#include <string>

using namespace std;

int ci_compare(const char* s1, const char* s2)
{
    while(tolower(*s1) == tolower(*s2++))
    {
        if(*s1++ == '\0')
        {
            return 0;
        }
    }
    return tolower(*s1) - tolower(*--s2);
}

class CIString
{
public:
    CIString(const char*s) : str_(s){}
    std::weak_ordering operator<=>(const CIString& b) const
    {
        return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
    }
private:
    std::string str_;
};

int main()
{
    CIString s1{"HELLO"}, s2{"hello"};
    std::cout << (s1 <=> s2 == 0) << std::endl;
    // 1
    return 0;
}
```

ä»¥ä¸Šä»£ç å®ç°äº†ä¸€ä¸ªç®€å•çš„å¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼Œå®ƒå¯¹äºs1å’Œs2çš„æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering::equivalent`ï¼Œè¡¨ç¤ºä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç­‰ä»·çš„ã€‚ä½†æ˜¯å®ƒä»¬ä¸æ˜¯ç›¸ç­‰çš„ä¹Ÿä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚å½“`std::weak_ordering`å’Œ`std::strong_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
```

ç”¨MSVCç¼–è¯‘è¿è¡Œä¸Šé¢è¿™æ®µä»£ç ä¼šè¾“å‡º`class std::weak_ordering`ï¼Œå› ä¸ºDä¸­çš„æ•°æ®æˆå‘˜CIStringçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¸º`std::weak_ordering`ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœæ˜¾å¼å£°æ˜é»˜è®¤ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¸º`std::strong_ordering operator <=> (const D&) const = default;`é‚£ä¹ˆä¸€å®šä¼šé­é‡åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚

### std::partial_ordering

```cpp
std::partial_ordering
    - std::partial_ordering::less
    - std::partial_ordering::equivalent
    - std::partial_ ordering::greater
    - std::partial_ordering::unordered
```

`std::partial_ordering`çº¦æŸåŠ›æ¯”`std::weak_ordering`æ›´å¼±ï¼Œå®ƒå¯ä»¥æ¥å—å½“`lhs == rhs`æ—¶rhså’Œlhsä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚
åŒæ—¶å®ƒè¿˜èƒ½ç»™å‡ºç¬¬å››ä¸ªç»“æœ`std::partial_ordering::unordered`ï¼Œè¡¨ç¤ºè¿›è¡Œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°æ²¡æœ‰å…³ç³»ã€‚æ¯”å¦‚åŸºç¡€ç±»å‹ä¸­çš„æµ®ç‚¹æ•°ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << typeid(decltype(7.7 <=> 11.1)).name();
    // St16partial_ordering
    return 0;
}
```

ä¼šè¾“å‡º`class std::partial_ordering`è€Œä¸æ˜¯`std::strong_ordering`ï¼Œæ˜¯å› ä¸ºæµ®ç‚¹çš„é›†åˆä¸­å­˜åœ¨ä¸€ä¸ªç‰¹æ®Šçš„NaNï¼Œå®ƒå’Œå…¶ä»–æµ®ç‚¹æ•°å€¼æ˜¯æ²¡å…³ç³»çš„ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << ((0.0 / 0.0 <=> 1.0) == std::partial_ordering::unordered);
    // 1
    return 0;
}
```

å½“`std::weak_ordering`å’Œ`std::partial_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::partial_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  float u;
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
// class std::partial_ordering
```

å†æ¬¡å¼ºè°ƒä¸€ä¸‹ï¼Œ`std::strong_ordering`ã€`std::weak_ordering`å’Œ`std::partial_ordering`åªèƒ½ä¸0å’Œç±»å‹è‡ªèº«æ¯”è¾ƒã€‚æ·±ç©¶å…¶åŸå› ï¼Œæ˜¯è¿™3ä¸ªç±»åªå®ç°äº†å‚æ•°ç±»å‹ä¸ºè‡ªèº«ç±»å‹å’Œ`nullptr_t`çš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚

### std::variant

`std::variant`æ˜¯ C++17 å¼•å…¥çš„æ ‡å‡†åº“æ¨¡æ¿ï¼ˆä½¿ç”¨å‰è¯·ç¡®ä¿ä½ çš„ç¼–è¯‘å™¨æ”¯æŒ C++ 17ï¼‰ï¼Œå®ƒæä¾›äº†ä¸€ç§ç±»å‹å®‰å…¨çš„å˜ä½“ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ã€‚ `std::variant`è¡¨ç¤ºä¸€ä¸ªç±»å‹å®‰å…¨çš„è”åˆä½“ï¼Œå³å¯ä»¥åœ¨ä¸€ä¸ªå˜é‡ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ï¼Œè€Œä¸”ä¸€æ¬¡åªèƒ½å­˜å‚¨å®ƒå…¶ä¸­ä¸€ä¸ªå¯èƒ½çš„ç±»å‹çš„å€¼ã€‚ `std::variant`çš„ä¸»è¦ä¼˜ç‚¹æ˜¯æä¾›äº†ç±»å‹å®‰å…¨å’Œçµæ´»æ€§ã€‚å®ƒå¯ä»¥ç”¨äºå¤„ç†å…·æœ‰å¤šç§å¯èƒ½ç±»å‹çš„æ•°æ®ï¼Œä¾‹å¦‚åœ¨å‡½æ•°å‚æ•°ä¸­ä¼ é€’ä¸åŒç±»å‹çš„å‚æ•°ï¼Œæˆ–è€…åœ¨å¤„ç†å¼‚è´¨é›†åˆæ—¶å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ã€‚ ä»¥ä¸‹æ˜¯ä½¿ç”¨`std::variant`çš„ä¸€äº›ç¤ºä¾‹ä»£ç ï¼š

```cpp
#include <iostream>
#include <variant>
using namespace std;

void processVariant(const std::variant<int, double, std::string>& v)
{
    std::visit([](auto &value){
        std::cout << "Value: " << value << std::endl;
    }, v);
}

int main()
{
    std::variant<int, double, std::string> v = 42;
    processVariant(v);
    v = 3.14;
    processVariant(v);
    v = "Hello, world";
    processVariant(v);
    std::cout << typeid(std::get<0>(v)).name() << std::endl;
    // i
    std::cout << typeid(std::get<1>(v)).name() << std::endl;
    // d
    std::cout << typeid(std::get<2>(v)).name() << std::endl;
    // NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
    return 0;
}
/*
Value: 42
Value: 3.14
Value: Hello, world
*/
// https://en.cppreference.com/w/cpp/utility/variant
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`std::variant`åœ¨å­˜å‚¨ç±»å‹æ—¶ä½¿ç”¨äº†åŠ¨æ€å¤šæ€æ€§ï¼ˆå³è¿è¡Œæ—¶å¤šæ€ï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå­˜å‚¨çš„å…·ä½“ç±»å‹ï¼Œè€Œæ˜¯åœ¨è¿è¡Œæ—¶æ ¹æ®å®é™…èµ‹å€¼æ¥ç¡®å®šã€‚ è¿™ä¹Ÿæ„å‘³ç€åœ¨ä½¿ç”¨`std::variant`æ—¶ï¼Œéœ€è¦è°¨æ…å¤„ç†ç±»å‹è½¬æ¢å’Œæ“ä½œï¼Œä»¥ç¡®ä¿ç±»å‹å®‰å…¨ã€‚

### std::common_comparison_category

åœ¨C++20çš„æ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ªæ¨¡æ¿å…ƒå‡½æ•° `std::common_comparison_category` ï¼Œå®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬åœ¨ä¸€ä¸ªç±»å‹åˆé›†ä¸­åˆ¤æ–­å‡ºæœ€ç»ˆä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ï¼Œå½“ç±»å‹åˆé›†ä¸­å­˜åœ¨ä¸æ”¯æŒä¸‰å‘æ¯”è¾ƒçš„ç±»å‹æ—¶ï¼Œè¯¥æ¨¡æ¿å…ƒå‡½æ•°è¿”å›voidã€‚

```cpp
https://en.cppreference.com/w/cpp/utility/compare/common_comparison_category
```

### å¯¹åŸºç¡€ç±»å‹çš„æ”¯æŒ

1. å¯¹ä¸¤ä¸ªç®—æœ¯ç±»å‹çš„æ“ä½œæ•°è¿›è¡Œä¸€èˆ¬ç®—æœ¯è½¬æ¢ï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒã€‚å…¶ä¸­æ•´å‹çš„æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ï¼Œæµ®ç‚¹å‹çš„æ¯”è¾ƒç»“æœä¸º`std::partial_ordering`ã€‚ä¾‹å¦‚`7 <=> 11.1`ä¸­ï¼Œæ•´å‹7ä¼šè½¬æ¢ä¸ºæµ®ç‚¹ç±»å‹ï¼Œç„¶åå†è¿›è¡Œæ¯”è¾ƒï¼Œæœ€ç»ˆç»“æœä¸º`std::partial_ordering`ç±»å‹ã€‚
2. å¯¹äºæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹å’Œæ•´å‹æ“ä½œæ•°ï¼Œæšä¸¾ç±»å‹ä¼šè½¬æ¢ä¸ºæ•´å‹å†è¿›è¡Œæ¯”è¾ƒï¼Œæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹æ— æ³•ä¸æµ®ç‚¹ç±»å‹æ¯”è¾ƒã€‚

```cpp
enum color {
  red
};

auto r = red <=> 11;   //ç¼–è¯‘æˆåŠŸ
auto r = red <=> 11.1; //ç¼–è¯‘å¤±è´¥
```

3. å¯¹ä¸¤ä¸ªç›¸åŒæšä¸¾ç±»å‹çš„æ“ä½œæ•°æ¯”è¾ƒç»“æœï¼Œå¦‚æœæšä¸¾ç±»å‹ä¸åŒï¼Œåˆ™æ— æ³•ç¼–è¯‘ã€‚
4. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºboolç±»å‹çš„æƒ…å†µï¼Œå¦ä¸€ä¸ªæ“ä½œæ•°å¿…é¡»ä¹Ÿæ˜¯boolç±»å‹ï¼Œå¦åˆ™æ— æ³•ç¼–è¯‘ã€‚æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚
5. ä¸æ”¯æŒä½œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°ä¸ºæ•°ç»„çš„æƒ…å†µï¼Œä¼šå¯¼è‡´ç¼–è¯‘å‡ºé”™ï¼Œä¾‹å¦‚ï¼š

```cpp
int arr1[5];
int arr2[5];
auto r = arr1 <=> arr2; // ç¼–è¯‘å¤±è´¥
```

6. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºæŒ‡é’ˆç±»å‹çš„æƒ…å†µï¼Œéœ€è¦å¦ä¸€ä¸ªæ“ä½œæ•°æ˜¯åŒæ ·ç±»å‹çš„æŒ‡é’ˆï¼Œæˆ–è€…æ˜¯å¯ä»¥è½¬æ¢ä¸ºç›¸åŒç±»å‹çš„æŒ‡é’ˆï¼Œæ¯”å¦‚æ•°ç»„åˆ°æŒ‡é’ˆçš„è½¬æ¢ã€æ´¾ç”Ÿç±»æŒ‡é’ˆåˆ°åŸºç±»æŒ‡é’ˆçš„è½¬æ¢ç­‰ï¼Œæœ€ç»ˆæ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚

```cpp
char arr1[5];
char arr2[5];
char* ptr = arr2;
auto r = ptr <=> arr1;
// ä¸Šé¢çš„ä»£ç å¯ä»¥ç¼–è¯‘æˆåŠŸï¼Œè‹¥å°†ä»£ç ä¸­çš„arr1æ”¹å†™ä¸ºint arr1[5]ï¼Œåˆ™æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºint [5]æ— æ³•è½¬æ¢ä¸ºchar *ã€‚å¦‚æœå°†char * ptr = arr2;ä¿®æ”¹ä¸ºvoid * ptr = arr2;ï¼Œå°±å¯ä»¥ç¼–è¯‘æˆåŠŸäº†ã€‚
```

### è‡ªåŠ¨ç”Ÿæˆçš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°

æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªåä¸º`std::rel_ops`çš„å‘½åç©ºé—´ï¼Œåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹å·²ç»æä¾›äº†`==`è¿ç®—ç¬¦å‡½æ•°å’Œ<è¿ç®—ç¬¦å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå¸®åŠ©ç”¨æˆ·å®ç°å…¶ä»–4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œ åŒ…æ‹¬`!=ã€>ã€<=å’Œ>=`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <string>
#include <utility>
class CIString2 {
public:
  CIString2(const char* s) : str_(s) {}

  bool operator < (const CIString2& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) < 0;
  }
private:
  std::string str_;
};

using namespace std::rel_ops;
CIString2 s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

ä¸è¿‡å› ä¸ºC++20æ ‡å‡†æœ‰äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„å…³ç³»ï¼Œæ‰€ä»¥ä¸æ¨èä¸Šé¢è¿™ç§åšæ³•äº†ã€‚C++20æ ‡å‡†è§„å®šï¼Œå¦‚æœç”¨æˆ·ä¸ºè‡ªå®šä¹‰ç±»å‹å£°æ˜äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šä¸ºå…¶è‡ªåŠ¨ç”Ÿæˆ`<ã€>ã€<=å’Œ>=`è¿™4ç§è¿ç®—ç¬¦å‡½æ•°ã€‚å¯¹äºCIStringæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™4ç§è¿ç®—ç¬¦å‡½æ•°:

```cpp
CIString s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

é‚£ä¹ˆè¿™é‡Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªç–‘é—®ï¼Œå¾ˆæ˜æ˜¾ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦èƒ½è¡¨è¾¾ä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç›¸ç­‰æˆ–è€…ç­‰ä»·çš„å«ä¹‰ï¼Œä¸ºä»€ä¹ˆæ ‡å‡†åªå…è®¸è‡ªåŠ¨ç”Ÿæˆ4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œå´ä¸èƒ½è‡ªåŠ¨ç”Ÿæˆ`==å’Œ=!`è¿™ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå®é™…ä¸Šè¿™é‡Œå­˜åœ¨ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚åœ¨C++20æ ‡å‡†æ‹Ÿå®šä¸‰å‘æ¯”è¾ƒçš„æ—©æœŸï¼Œæ˜¯å…è®¸é€šè¿‡ä¸‰å‘æ¯”è¾ƒè‡ªåŠ¨ç”Ÿæˆ6ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œè€Œä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ä¹Ÿä¸æ˜¯3ç§è€Œæ˜¯5ç§ï¼Œå¤šå‡ºæ¥çš„ä¸¤ç§åˆ†åˆ«æ˜¯`std::strong_equality`å’Œ`std::weak_equality`ã€‚ä½†æ˜¯åœ¨ææ¡ˆæ–‡æ¡£p1190ä¸­æå‡ºäº†ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚ç®€å•æ¥è¯´ï¼Œå‡è®¾æœ‰ä¸€ä¸ªç»“æ„ä½“ï¼š

```cpp
struct S {
    std::vector<std::string> names;
    auto operator<=>(const S &) const = default;
};
```

å®ƒçš„ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„é»˜è®¤å®ç°è¿™æ ·çš„ï¼š

```cpp
template<typename T>
std::strong_ordering operator<=>(const std::vector<T>& lhs, const std::vector<T> & rhs)
{
    size_t min_size = min(lhs.size(), rhs.size());
    for (size_t i = 0; i != min_size; ++i) {
        if (auto const cmp = std::compare_3way(lhs[i], rhs[i]); cmp != 0) {
            return cmp;
        }
    }
    return lhs.size() <=> rhs.size();
}
```

è¿™ä¸ªå®ç°å¯¹äº`<å’Œ>`è¿™æ ·çš„è¿ç®—ç¬¦å‡½æ•°æ²¡æœ‰é—®é¢˜ï¼Œå› ä¸ºéœ€è¦æ¯”è¾ƒå®¹å™¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä½†æ˜¯`==`è¿ç®—ç¬¦å°±æ˜¾å¾—ååˆ†ä½æ•ˆï¼Œå¯¹äº`==`è¿ç®—ç¬¦é«˜æ•ˆçš„åšæ³•æ˜¯å…ˆæ¯”è¾ƒå®¹å™¨ä¸­çš„å…ƒç´ æ•°é‡æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœå…ƒç´ æ•°é‡ä¸åŒï¼Œåˆ™ç›´æ¥è¿”å›falseï¼š

```cpp
template<typename T>
bool operator==(const std::vector<T>& lhs, const std::vector<T>& rhs)
{
    const size_t size = lhs.size();
    if (size != rhs.size()) {
        return false;
    }

    for (size_t i = 0; i != size; ++i) {
        if (lhs[i] != rhs[i]) {
            return false;
        }
    }
    return true;
}
```

æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæ ‡å‡†å…è®¸ç”¨ä¸‰å‘æ¯”è¾ƒçš„ç®—æ³•è‡ªåŠ¨ç”Ÿæˆ`==`è¿ç®—ç¬¦å‡½æ•°ä¼šå‘ç”Ÿä»€ä¹ˆäº‹æƒ…ï¼Œ å¾ˆå¤šæ—§ä»£ç å‡çº§ç¼–è¯‘ç¯å¢ƒåä¼šå‘ç°è¿è¡Œæ•ˆç‡ä¸‹é™äº†ï¼Œå°¤å…¶æ˜¯åœ¨å®¹å™¨ä¸­å…ƒç´ æ•°é‡ä¼—å¤šä¸”æ¯ä¸ªå…ƒç´ æ•°æ®é‡åºå¤§çš„æƒ…å†µä¸‹ã€‚ å¾ˆå°‘æœ‰ç¨‹åºå‘˜ä¼šæ³¨æ„åˆ°ä¸‰å‘æ¯”è¾ƒç®—æ³•çš„ç»†èŠ‚ï¼Œå¯¼è‡´è¿™ä¸ªæ€§èƒ½é—®é¢˜éš¾ä»¥æ’æŸ¥ã€‚åŸºäºè¿™ç§è€ƒè™‘ï¼ŒC++å§”å‘˜ä¼šä¿®æ”¹äº†åŸæ¥çš„ä¸‰å‘æ¯”è¾ƒææ¡ˆï¼Œ è§„å®šå£°æ˜ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°åªèƒ½å¤Ÿè‡ªåŠ¨ç”Ÿæˆ4ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚ç”±äºä¸éœ€è¦è´Ÿè´£åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œ å› æ­¤`std::strong_equality`å’Œ`std::weak_equality`ä¹Ÿé€€å‡ºäº†å†å²èˆå°ã€‚å¯¹äº`==å’Œ!=`ä¸¤ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œ åªéœ€è¦å¤šå£°æ˜ä¸€ä¸ª`==`è¿ç®—ç¬¦å‡½æ•°ï¼Œ`!=`è¿ç®—ç¬¦å‡½æ•°ä¼šæ ¹æ®å‰è€…è‡ªåŠ¨ç”Ÿæˆï¼š

```cpp
class CIString {
public:
  CIString(const char* s) : str_(s) {}

  std::weak_ordering operator<=>(const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
  }

  bool operator == (const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) == 0;
  }
private:

  std::string str_;
};

CIString s1{ "hello" }, s2{ "world" };
bool r1 = s1 >= s2; // è°ƒç”¨operator<=>
bool r2 = s1 == s2; // è°ƒç”¨operator ==
```

### å…¼å®¹æ—§ä»£ç 

ç°åœ¨C++20æ ‡å‡†å·²ç»æ¨èä½¿ç”¨`<=>å’Œ==`è¿ç®—ç¬¦è‡ªåŠ¨ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œè€Œä½¿ç”¨`<ã€==ä»¥åŠstd::rel_ops`ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¼šå› ä¸º`std::rel_ops`å·²ç»ä¸è¢«æ¨èä½¿ç”¨è€Œè¢«ç¼–è¯‘å™¨è­¦å‘Šã€‚åˆ™é‚£ä¹ˆå¯¹äºè€ä»£ç ï¼Œæˆ‘ä»¬æ˜¯å¦éœ€è¦å»å®ç°ä¸€å¥—`<=>å’Œ==`è¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå…¶å®å¤§å¯ä¸å¿…ï¼ŒC++å§”å‘˜ä¼šåœ¨è£å†³è¿™é¡¹ä¿®æ”¹çš„æ—¶å€™å·²ç»è€ƒè™‘åˆ°è€ä»£ç çš„ç»´æŠ¤æˆæœ¬ï¼Œæ‰€ä»¥åšäº†å…¼å®¹æ€§å¤„ç†ï¼Œå³åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ä¸­ï¼Œå®ç°äº†`<ã€==`è¿ç®—ç¬¦å‡½æ•°çš„æ•°æ®æˆå‘˜ç±»å‹ï¼Œåœ¨è¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒä¸­å°†è‡ªåŠ¨ç”Ÿæˆåˆé€‚çš„æ¯”è¾ƒä»£ç ã€‚æ¯”å¦‚ï¼š

```cpp
struct Legacy {
  int n;
  bool operator==(const Legacy& rhs) const
  {
       return n == rhs.n;
  }
  bool operator<(const Legacy& rhs) const
  {
       return n < rhs.n;
  }
};

struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay &) const = default;
};

TreeWay t1, t2;
bool r = t1 < t2;
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œç»“æ„ä½“TreeWayçš„ä¸‰å‘æ¯”è¾ƒæ“ä½œä¼šè°ƒç”¨ç»“æ„ä½“Legacyä¸­çš„`<å’Œ==`è¿ç®—ç¬¦æ¥å®Œæˆï¼Œå…¶ä»£ç ç±»ä¼¼äºï¼š

```cpp
struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay& rhs) const {
       if (m < rhs.m) return std::strong_ordering::less;
       if (m == rhs.m) return std::strong_ordering::equal;
       return std::strong_ordering::greater;
  }
};
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œ`operator<=>`å¿…é¡»æ˜¾å¼å£°æ˜è¿”å›ç±»å‹ä¸º`std::strong_ordering`ï¼Œä½¿ç”¨autoæ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘çš„ã€‚

### ä¸‰å‘æ¯”è¾ƒæ€»ç»“

C++20æ–°å¢çš„ä¸‰å‘æ¯”è¾ƒç‰¹æ€§ï¼Œè¯¥ç‰¹æ€§çš„å¼•å…¥ä¸ºå®ç°æ¯”è¾ƒè¿ç®—æä¾›äº†æ–¹ä¾¿ã€‚ æˆ‘ä»¬åªéœ€è¦å®ç°`==å’Œ<=>`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œå‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°å°±å¯ä»¥äº¤ç»™ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆäº†ã€‚ è™½è¯´`std::rel_ops`åœ¨å®ç°äº†`==å’Œ<`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ä»¥åä¹Ÿèƒ½è‡ªåŠ¨æä¾›å‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œ ä½†æ˜¾ç„¶ç”¨ä¸‰å‘æ¯”è¾ƒæ›´åŠ ä¾¿æ·ã€‚å¦å¤–ï¼Œä¸‰å‘æ¯”è¾ƒæä¾›çš„3ç§ç»“æœç±»å‹ä¹Ÿæ˜¯`std::rel_ops`æ— æ³•åª²ç¾çš„ã€‚ è¿›ä¸€æ­¥æ¥è¯´ï¼Œç”±äºä¸‰å‘æ¯”è¾ƒçš„å‡ºç°ï¼Œ`std::rel_ops`åœ¨C++20ä¸­å·²ç»ä¸è¢«æ¨èä½¿ç”¨äº†ã€‚ æœ€åï¼ŒC++å§”å‘˜ä¼šæ²¡æœ‰å¿˜è®°å…¼å®¹æ€§é—®é¢˜ï¼Œè¿™è®©ä¸‰å‘æ¯”è¾ƒèƒ½å¤Ÿé€šè¿‡è¿ç®—ç¬¦å‡½æ•°`<å’Œ==`æ¥è‡ªåŠ¨ç”Ÿæˆã€‚

## åç¨‹

éå¸¸niceçš„è®²è§£ <https://www.bilibili.com/video/BV1c8411f7dw>

### ä»€ä¹ˆæ˜¯åç¨‹

å…ˆå­¦ä¼šä½¿ç”¨ï¼Œç„¶ååœ¨å­¦ä¹ èƒŒåçš„å®ç°åŸç†ã€‚ç”±æµ…åˆ°æ·±æ‰æ˜¯å­¦ä¹ çš„æ­£ç¡®å§¿åŠ¿ã€‚

åç¨‹ï¼šæ˜¯ä¸€ç§å¯ä»¥è¢«æŒ‚èµ·å’Œå›å¤çš„å‡½æ•°ã€‚

ç”µè„‘æœ¬æœºæ²¡æœ‰ç¯å¢ƒå¯ä»¥ä½¿ç”¨ è½»æ¾ä½¿ç”¨C++2aç¯å¢ƒ:<https://godbolt.org/>

### å‡½æ•°è°ƒç”¨VSåç¨‹

![å‡½æ•°è°ƒç”¨VSåç¨‹](../.gitbook/assets/2024-03-27232828.png)

å‡½æ•°çš„è°ƒç”¨æ˜¯è°ƒç”¨çš„å‡½æ•°è¿›è¡Œreturnï¼Œç„¶åè¿”å›å›æ¥ï¼Œç»§ç»­æ‰§è¡Œï¼Œä¸”è°ƒç”¨çš„å‡½æ•°å·²ç»æ‰§è¡Œå®Œäº†ï¼Œä¸ä¼šä¸­æ–­ã€‚

è€Œåç¨‹æ˜¯å¯ä»¥æ‰§è¡Œåˆ°æŸå¤„co_yieldæˆ–co_awaitæ—¶ï¼Œç„¶åè·³è½¬åˆ°æŸä¸ªåœ°æ–¹(åç¨‹è¢«æŒ‚èµ·æ—¶ä¸æ˜¯å¿…é¡»å›åˆ°è¢«è°ƒç”¨çš„åœ°æ–¹ï¼Œå®Œå…¨å¯ä»¥æŒ‡å®šå…¶ä»–åç¨‹ï¼Œè¿™å°±æ˜¯åç¨‹è°ƒåº¦çš„å†…å®¹äº†)ï¼Œå½“åç¨‹è¢«æ‰§è¡Œresumeæ—¶ç»§ç»­æ‰§è¡Œåç¨‹
å½“co_returnæ—¶åç¨‹å°†ç»“æŸã€‚

### ç®€å•å®ä¾‹

ç®€å•è®¤è¯†

- åç¨‹è¿”å›å€¼ç±»å‹ä¸promise_typeã€initial_suspendã€final_suspendã€unhandled_exceptionã€get_return_objectã€yield_valueã€return_voidã€return_value
- std::coroutine_handleã€doneã€()ã€resumeã€from_promise
- co_awaitã€co_yieldã€co_return
- awaitableã€await_readyã€await_suspendã€await_resume

```CMake
project(main)

add_compile_options(-Wall)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -Wall -O0")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -std=c++2a -Wall -O0")

add_executable(main.exe main.cpp)
# target_link_libraries(main.exe)
```

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        int _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never initial_suspend()
        {
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            std::cout << "final_suspend" << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always yield_value(int r)
        {
            _out = r;
            return {};
        }

        void return_void() // å³co_return ;
        {
        }

        // void return_value(std::string str) // å³co_return str;
        // {
        // }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h();
    // ret._h.resume(); ä¸ ret._h() ç­‰ä»·
    std::cout << "over" << std::endl;
    return 0;
}

// co_yieldç­‰ä»·äº co_await promise.yield_value(expr)
// åç¨‹å¦‚æœè°ƒç”¨äº†co_return åˆ™ ret._h.done()å°†ä¼šè¿”å›çœŸ

// CoFunction() next line
// coroutine message=hello
// final_suspend
// over
```

### std::suspend_neverçš„å®ç°

std::suspend_neveræ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_never
{
  constexpr bool await_ready() const noexcept { return true; } // ä¸æŒ‚èµ·co_waitç›´æ¥æ— æ•ˆç»§ç»­æ‰§è¡Œco_waitåé¢çš„ä»£ç 
  constexpr void await_suspend(coroutine_handle<>) const noexcept {}
  constexpr void await_resume() const noexcept {}
};
```

### std::suspend_alwaysçš„å®ç°

std::suspend_alwaysä¹Ÿæ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_always
{
  constexpr bool await_ready() const noexcept { return false; } // co_waitæ—¶ç›´æ¥æŒ‚èµ·ç„¶åè§¦å‘await_suspend ç„¶åç­‰å¾…resumeå†å›æ¥
  constexpr void await_suspend(coroutine_handle<>) const noexcept {} 
  constexpr void await_resume() const noexcept {}
};
```

### è¿›ä¸€æ­¥ç†Ÿæ‚‰æµç¨‹

è¿™é‡Œå¯ä»¥è¿›ä¸€æ­¥äº†è§£final_suspendçš„è¿”å›å€¼

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_always initial_suspend()
        {
            std::cout << "initial_suspend" << std::endl;
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            // final_suspendè¿”å›å€¼å†³å®šäº†åç¨‹ä¼šä¸ä¼šè¢«destory å½“è¿”å›std::suspend_neveræ—¶final_suspendæ‰§è¡Œååç¨‹handleè¢«destory åœ¨è°ƒç”¨handle.done()è¿”å›0
            // å½“è¿”å›std::suspend_alwaysä¹Ÿå°±æ˜¯åç¨‹æœ€åæœ‰è¢«æŒ‚èµ·ï¼Œé‚£ä¹ˆhandle.done()ä¼šè¿”å›çœŸï¼Œè€Œä¸”å¦‚æœè¿”å›std::suspend_alwaysæˆ‘ä»¬æ˜¯éœ€è¦åœ¨å®ƒå¤„æ˜¾ç¤ºhandle.destory()
            std::cout << std::coroutine_handle<promise_type>::from_promise(*this).done() << std::endl;
            std::cout << "final_suspend" << std::endl;
            std::cout << "co_return " << _out << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void() // å³co_return ;
        // {
        // }

        void return_value(std::string_view str) // å³co_return str; å¯ä»¥å°†å†…å®¹é€šè¿‡co_returnå­˜åˆ°promiseä¸­
        {
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return "888888"; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    std::cout << "start main" << std::endl;
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h(); // å›åˆ° co_await promise.initial_suspend()
    // ä»co_await Awaitable()è·³è¿‡æ¥äº†
    std::cout << "=>" << ret._h.done() << std::endl; // 0

    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h.resume();                         // å›åˆ°co_await Awaitable();
    std::cout << "over" << std::endl;
    std::cout << ret._h.done() << std::endl; // 0
    std::cout << ret._h.promise()._out << std::endl; // 888888
    // åç¨‹ç»“æŸåä¸èƒ½åœ¨è¢«resumeäº†

    return 0;
}
// ret._h.destory()å¯ä»¥æå‰é”€æ¯åç¨‹handle

// start main
// initial_suspend
// CoFunction() next line
// =>0
// coroutine message=hello
// 1
// final_suspend
// co_return 888888
// over
// 0
// 888888
```

### ç®€å•ç†è§£åç¨‹è°ƒåº¦

ä»è¿™ä¸ªä¾‹å­ä¸­å…¶å®å¯ä»¥çœ‹ å…¶å®åç¨‹å¯ä»¥çœ‹æˆä»»åŠ¡çŠ¶æ€æœºï¼Œé€šè¿‡promiseä¸coroutine_handleä¸å¤–ç•Œäº¤äº’
åªä¸è¿‡æœ€å¤§ä¼˜åŠ¿å°±æ˜¯ å¯ä»¥è‡ªåŠ¨ç»´æŒä¸Šä¸‹æ–‡ï¼ŒçŠ¶æ€æœºæŒ‚èµ·çš„æ—¶å€™ï¼Œå¯ä»¥è‡ªåŠ¨å›åˆ°è§¦å‘çŠ¶æ€æœºçš„åœ°æ–¹å³è°ƒç”¨resume()çš„åœ°æ–¹ã€‚

è¿™ä¹ˆä¸€æ¥åƒåšæœåŠ¡å™¨çš„æœ‰ä»€ä¹ˆæ‰“çš„ä¼˜åŠ¿ï¼Œå…¶å®å°±æ˜¯epoll+åç¨‹+éé˜»å¡IOï¼Œè€Œä¸”å¯ä»¥åšåˆ°å•çº¿ç¨‹å¹¶å‘
ä¾‹å¦‚epoll æ¥äº†æ–°è¿æ¥ åˆ™ä¸ºæ–°è¿æ¥åˆ›å»ºåç¨‹ï¼Œepollç›‘å¬è¿æ¥å¥—æ¥å­—å¯è¯»æ—¶ å¯ä»¥å‘promiseä¸­æ ‡è®° ä½ å¯ä»¥è¯»äº† æˆ–è€… å¯ä»¥å†™äº†ã€‚ç„¶åè¿›è¡Œresume() æ¯ä¸ªåç¨‹å†…éƒ¨å…¶å®å°±æ˜¯æ­»å¾ªç¯ read process writeä¹‹ç±»çš„ç›¸å…³æ“ä½œï¼Œè¦æš‚æ—¶ä¸å¤„ç†äº†æ¯”å¦‚EAGAINäº†ï¼Œå®Œå…¨å¯ä»¥co_waitå‡ºå»å›åˆ°åŸæ¥è¦æ‰§è¡Œçš„åœ°æ–¹ï¼Œå¯èƒ½ä¼šå¤„ç†ä¸‹ä¸€ä¸ªåç¨‹ï¼Œè¿™ä¹ˆä¸€æ¥å¯ä»¥å‘ç° C++åç¨‹æ›´åƒæ˜¯ä¸€ç§çŠ¶æ€æœºçš„è¯­æ³•ç³–ä¸€æ ·çš„æ„Ÿè§‰ï¼Œè€Œä¸”å¾ˆå®¹æ˜“å›´ç»•éé˜»å¡IOå»åš
ä¸€äº›å¼‚æ­¥ä»»åŠ¡ï¼Œè€Œä¸”å®Œå…¨å¯ä»¥å•çº¿ç¨‹ï¼Œå®‰å…¨å¥½ç”¨ç®€å•ï¼Œåœ¨å¿…è¦çš„æ—¶å€™è¿›è¡Œresumeè§¦å‘æ‰§è¡Œï¼Œåç¨‹ä¹Ÿæœ‰è‡ªçŸ¥ä¹‹æ˜ è‡ªå·±ä¼šco_wait co_yield co_returnä¸ä¼šè¿›è¡Œé˜»å¡ ä¸æ˜¯åœ¨è¿è¡Œå°±æ˜¯åœ¨æŒ‚èµ·ç­‰å¾…è¢«resume è¿™æ‰æ˜¯å…³é”®ä¸ç²¾é«“ã€‚

```cpp

#include <coroutine>
#include <future>
#include <thread>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>


using namespace std;

struct CoRet
{
    struct promise_type
    {
        int _in;
        int _out;
        int _res;
        suspend_never initial_suspend() {return {};}
        suspend_always final_suspend() noexcept {return {};}
        void unhandled_exception() {}
        CoRet get_return_object()
        { return 
            {coroutine_handle<promise_type>::from_promise(*this)};
        }
        suspend_always yield_value(int r) {
            _out = r;
            return {};
        }
        void return_value(int r) {
            _res = r;
        }
    };

    coroutine_handle<promise_type> _h; // _h.resume(), _h()
};

struct Input
{
    int* _in;
    int* _out;
    bool await_ready() { return false; }
    void await_suspend(coroutine_handle<CoRet::promise_type> h) 
    { _in = &h.promise()._in; _out = &h.promise()._out; }
    int await_resume() { return *_in; }
};

// åç¨‹
CoRet Guess() {
    // co_await promise.initial_suspend();
    int res = (rand()%30)+1;
    Input input;
    int numGuess = 0;
    while(true)
    {
        int g = co_await input;
        
        ++numGuess;
        (*input._out) = (res>g ? 1: (res == g? 0 : -1));
        if((*input._out) == 0) co_return numGuess;
    }    
    // co_await promise.final_suspend();...
}



struct Hasher
{
    size_t operator() (const pair<int, int>& p) const
    {
        return (size_t)(p.first << 8) + (size_t)(p.second); 
    }
};
int main()
{
    srand(time(nullptr));

    unordered_map<pair<int, int>, vector<CoRet>, Hasher> buckets;
    for(auto i = 0; i<100; ++i) buckets[make_pair(1, 30)].push_back(Guess());

    while(!buckets.empty())
    {
        auto it = buckets.begin();
        auto& range = it->first;//1
        auto& handles = it->second;//vector<CoRet>å­˜æ”¾åç¨‹
                
        int g = (range.first+range.second)/2;//ä¸­é—´æ•°
        auto ur = make_pair(g+1, range.second);//å³è¾¹éƒ¨åˆ†
        auto lr = make_pair(range.first, g-1);//å·¦è¾¹éƒ¨åˆ†

        vector<future<int>> cmp;
        cmp.reserve(handles.size());

        // è¿™ä¸ªå¾ªç¯æ˜¯éé˜»å¡çš„éå¸¸å¿«
        for(auto& coret : handles)
        {
            // ä¸ºæ¯ä¸ªä»»åŠ¡å»å¼€çº¿ç¨‹ å»æ‰§è¡Œåç¨‹
            cmp.push_back(async(launch::async, [&coret, g]() { // åˆ¤æ–­ä¸­é—´æ•°
                coret._h.promise()._in = g;
                coret._h.resume(); // åç¨‹å†…éƒ¨é‡è§co_wait co_yieldä¼šè¿”å›æ¥               
                return coret._h.promise()._out;
            }));
            // è·å¾—è®¸å¤šfuture å³lamdaè¿”å›å€¼å‘æ¡ä»¶å˜é‡ä¸€æ ·
        }

        // éå†æ‰€æœ‰åç¨‹ï¼Œå‰é¢å·²ç»è®©åç¨‹å»å¼‚æ­¥è¿è¡Œäº†
        for(int i=0; i< handles.size(); ++i)
        {
            int r = cmp[i].get(); // ç­‰å¾…futureè¿”å›å€¼è¿™é‡Œæ˜¯é˜»å¡çš„ åªæœ‰ç›¸åº”åç¨‹è¢«resume lamdaè¿”å›æ‰å¯ä»¥get()è¿”å›
            
            if(r == 0) {//çŒœå¯¹äº†
                cout << "The secret number is " << handles[i]._h.promise()._in
                << ", total # guesses is " << handles[i]._h.promise()._res
                << endl;
            }            
            else if (r == 1) buckets[ur].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å³è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
            else buckets[lr].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å·¦è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
        }
        buckets.erase(it);//åˆ é™¤åŸæ¥èŒƒå›´çš„ï¼ŒçŒœä¸­äº†çš„ä¸ç”¨å†çŒœåç¨‹ä¸­çš„æ•°å­—äº†ï¼Œå‰©ä½™åç¨‹ä¸æ˜¯å»å·¦è¾¹å°±æ˜¯å³è¾¹
    }

/*
    auto ret = Guess();
    pair<int, int> range = {1,30};    
    int in, out;
    do
    {
        in = (range.first+range.second)/2;
        ret._h.promise()._in = in; 
        cout << "main: make a guess: " << ret._h.promise()._in << endl;

        ret._h.resume(); // resume from co_await

        out = ret._h.promise()._out;
        cout << "main: result is " << 
        ((out == 1) ? "larger" :
        ((out == 0) ? "the same" : "smaller"))
            << endl;
        if(out == 1) range.first = in+1;
        else if(out == -1) range.second = in-1;
    }
    while(out != 0);
*/
}
```

### ä¸åŒçº¿ç¨‹resumeåŒä¸€ä¸ªåç¨‹

ä¸€ä¸ªçº¿ç¨‹ç¨‹å°†ä¸€ä¸ªåç¨‹è¿è¡Œåˆ°æŸä¸ªä½ç½® ç„¶ååç¨‹æŒ‚èµ·äº†ã€‚
å®Œå…¨å¯ä»¥ä½¿ç”¨å…¶ä»–çº¿ç¨‹ ç»§ç»­å®Œæˆåç¨‹ã€‚
è°è¿›è¡Œresumeè°å°±æ‰§è¡Œåç¨‹ è€Œä¸”resumeå†…éƒ¨è¿˜å¯èƒ½è§¦å‘å¦ä¸€ä¸ªåç¨‹handleçš„resumeã€‚
è¿™é‡Œå°±å‘ç°äº†ï¼Œå…¶å®resumeéœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œé€šè¿‡ä¸€ä¸ªæŒ‚èµ·çš„åç¨‹handleè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶handle,ä¼šå‡ºç°é—®é¢˜çš„ã€‚
C++åç¨‹æ˜¯æ— æ ˆåç¨‹ å…¶åç¨‹frameå­˜æ”¾åœ¨å †ä¸Š è€Œä¸”æ˜¯å¯¹ç§°çš„åç¨‹ ä¹Ÿå°±æ˜¯åç¨‹ä¹‹é—´åœ°ä½æ˜¯å¹³ç­‰çš„ ä¸€ä¸ªåç¨‹å¯ä»¥éšä¾¿
è·³åˆ°å…¶ä»–åç¨‹ å“ªæ€•åœ¨ä¸¤ä¸ªåç¨‹è§åå¤æ¨ªè·³éƒ½æ²¡é—®é¢˜ ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç”¨ä¸€èµ·çš„å‡½æ•°è°ƒç”¨ è¿™æ ·loopå¤šäº†å°±ä¼šæ ˆæº¢å‡ºäº†
è€Œæ— æ ˆåç¨‹ä¸ä¼šï¼Œåªæ˜¯åœ¨ä¸¤ä¸ªçŠ¶æ€æœºä¹‹é—´åˆ‡æ¢è·³è½¬ã€‚

```cpp
#include <iostream>
#include <coroutine>
#include <string_view>
#include <thread>
#include <future>

class CoMessage
{
public:
    std::string_view str;
};

struct Awaitable;

struct CoRet
{
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        std::suspend_always initial_suspend()
        {
            std::cout << "3=>" << std::this_thread::get_id() << std::endl;
            return {};
        }

        std::suspend_never final_suspend() noexcept;

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            std::cout << "4=>" << std::this_thread::get_id() << std::endl;
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void()
        // {
        // }

        void return_value(std::string_view str)
        {
            std::cout << "5=>" << std::this_thread::get_id() << std::endl;
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h;
};

struct Awaitable
{
    CoMessage *_message;
    bool await_ready() noexcept
    {
        return false;
    }

    void await_suspend(std::coroutine_handle<CoRet::promise_type> h) noexcept
    {
        _message = &h.promise()._message;
    }

    CoMessage await_resume() noexcept
    {
        std::cout << "6=>" << std::this_thread::get_id() << std::endl;
        return *_message;
    }
};

std::suspend_never CoRet::promise_type::final_suspend() noexcept
{
    std::cout << "7=>" << std::this_thread::get_id() << std::endl;
    return {};
}

CoRet CoFunction()
{
    std::cout << "2=>" << std::this_thread::get_id() << std::endl;
    CoMessage message1 = co_await Awaitable();
    CoMessage message2 = co_await Awaitable();
    CoMessage message3 = co_await Awaitable();
    co_return "888888";
}

int main(int argc, char **argv)
{
    std::cout << "1=>" << std::this_thread::get_id() << std::endl;
    CoRet ret = CoFunction();
    ret._h();
    ret._h.promise()._message.str = "hello";
    ret._h.resume();
    // å¼€æ–°çº¿ç¨‹å»å¤„ç†åç¨‹
    std::future<int> fu = std::async(
        [&]
        {
            ret._h.resume();
            ret._h.resume();
            return 999;
        });
    fu.get(); // ç­‰å¾…å¼‚æ­¥ä»»åŠ¡
    return 0;
}

// 1=>140087387162432
// 4=>140087387162432
// 3=>140087387162432
// 2=>140087387162432
// 6=>140087387162432
// 6=>140087383815744
// 6=>140087383815744
// 5=>140087383815744
// 7=>140087383815744
```

### Cé£æ ¼æ­ç§˜åç¨‹

CppCon 2016 C++ Coroutines Under the Covers

Coroutines In C

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
int main()
{
    void* coro = f(1);
    for(int i = 0; i < 4; ++i)
    {
        CORO_RESUME(coro);
    }
    CORO_DESTROY(coro);
}
// è¾“å‡º 1,-1,2,-2

define i32 @main()
{
    call void @print(i32 1)
    call void @print(i32 -1)
    call void @print(i32 2)
    call void @print(i32 -2)
    ret i32 0
}
```

å¦‚ä½•å»ºç«‹åç¨‹çš„å¸§ Build Coroutine Frame

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
// åªéœ€è¦è®°å½•å£°æ˜å‘¨æœŸè·¨è¶ŠCORO_SUSPENDçš„
struct f.frame {
    int i;
};
```

è§£å¯†åˆ›å»ºåç¨‹å¸§

```cpp
struct f.frame {
    int i;
}
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        CORO_SUSPEND(hdl);
        print(frame->i);
        CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

è§£å¯†åˆ›å»ºè·³è·ƒç‚¹ Create Jump Pointsï¼Œåƒæ¸¸æˆå­˜æ¡£ä¸€æ ·

```cpp
struct f.frame
{
    int suspend_index;
    int i;
};
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

èƒŒåå¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†

```cpp
// Coroutine Start Function
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    //...
    return hdl;
}
// Coroutine Resume Function
void f.resume(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
}
// Coroutine Destroy Function
void f.destroy(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
    free(frame);
}
```

å‡è®¾ç¼–è¯‘å™¨ç”Ÿæˆçš„f.resume

```cpp
void f.resume(f.frame* frame)
{
    switch (frame->suspend_index)
    {
        case 0: goto r0;
        default: goto r1;
    }
    for(frame->i = n;;++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

After CleanUp

```cpp
void* f(int* n)
{
// è¿›ä¸€æ­¥æŠ½è±¡
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    frame->ResumeFn = &f.resume;
    frame->DestroyFn = &f.destroy;
    frame->i = n;
    frame->suspend_index = 0;
    return coro_hdl;
}
void f.destroy(f.frame* frame)
{
    free(frame);
}
void f.cleanup(f.frame* frame){}
void f.resume(f.frame* frame)
{
    if(frame->index == 0)
    {
        print(frame->i);
        frame->suspend_index = 1;
    }
    else
    {
        print(-frame->i);
        ++frame->i;
        frame->suspend_index = 0;
    }
}
struct f.frame
{
    FnPtr ResumeFn;
    FnPtr DestroyFn;
    int suspend_index;
    int i;
};
```

### std::noop_coroutine

std::noop_coroutine() æ˜¯ C++20 ä¸­å¼•å…¥çš„ä¸€ä¸ªå‡½æ•°ï¼Œä½äº <coroutine> å¤´æ–‡ä»¶ä¸­ã€‚å®ƒæ˜¯ä¸€ä¸ªç©ºçš„åç¨‹ï¼ˆcoroutineï¼‰ï¼Œç”¨ä½œåç¨‹ï¼ˆcoroutineï¼‰çš„å ä½ç¬¦æˆ–è€…ç©ºæ“ä½œã€‚

### å°½å¯èƒ½ç”¨åç¨‹æ›¿ä»£std::futureä¸std::promise

å› ä¸ºfutureå’Œpromise éœ€è¦åˆ†é…å†…å­˜ åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡ç­‰ï¼Œå¼€é”€æ¯”è¾ƒå¤§ã€‚ä¾‹å¦‚ï¼Œå‡è®¾åœ¨æŸäº›ä»£ç ä¸­éœ€è¦ä¼ é€’ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œä½†æ˜¯å®é™…ä¸Šä¸éœ€è¦æ‰§è¡Œè¯¥åç¨‹ï¼Œè¿™æ—¶å°±å¯ä»¥ä½¿ç”¨ std::noop_coroutine() æ¥ä»£æ›¿ï¼Œä»¥è¾¾åˆ°å ä½çš„ç›®çš„ã€‚

![futureä¸promise](../.gitbook/assets/2024-03-30172542.png)

å¯ä»¥å…å»é¢å¤–çš„å†…å­˜ç”³è¯· åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡çš„å¼€é”€

ä¸‹é¢ä»£ç æ•´ä½“ç»è¿‡æµç¨‹

1. åˆ›å»ºç‹å­åç¨‹ suspend_alwaysã€‚
2. åˆ›å»ºå…¬ä¸»åç¨‹ suspend_alwaysã€‚  
3. å°†å…¬ä¸»åç¨‹èµ‹å€¼åˆ°ç‹å­åç¨‹çš„promise _nextä¸Šå»
4. å…¬ä¸»åç¨‹å»co_awaitç‹å­
5. è¿›è€Œè§¦å‘ç‹å­çš„await_suspend åœ¨å…¶ä¸­è¿›è¡Œstd::asyncå¯¹ç‹å­è¿›è¡Œresume
ç‹å­ std::this_thread::sleep_for(500ms); ç„¶åco_returnå°†é‡‘å¸èµ‹å€¼åˆ°äº†promiseä¸Š
æœ€ååˆ©ç”¨ç‹å­ final_suspend è¿”å›ä¸€ä¸ªawaiter await_readyè¿”å›false è§¦å‘ await_suspend è¿”å›å€¼ å†³å®šè·³å¾€å“ªé‡Œç‹å­çš„æœ‰_nextåˆ™è·³å¾€å…¬ä¸»çš„int c = co_await future; å¾—åˆ°äº†ç‹å­co_returnçš„é‡‘å¸é‡ã€‚  
6. æœ€åå…¬ä¸»ä¹Ÿco_returnäº†ï¼Œå…¶è¿”å›awaiterçš„await_readyè¿”å›false,å…¬ä¸»åç¨‹è¢«doneäº†æ ‡è®°ä¸º1ï¼Œè€Œä¸”awaiter await_suspendè¿”å›ç©ºåç¨‹ï¼Œæœ€åæˆ‘ä»¬asyncåˆ›å»ºçš„åç¨‹å…¶å®ç»“æŸäº†,ä¸»çº¿ç¨‹ä¸€ç›´å¾ªç¯æ£€æŸ¥å…¬ä¸»done,æ­¤æ—¶å…¬ä¸»doneäº†ï¼Œä¸€åˆ‡éƒ½ç»“æŸäº†ã€‚

```cpp
#include <iostream>
#include <chrono>
#include <future>
#include <thread>
#include <coroutine>
using namespace std;

struct Task
{
    struct promise_type
    {
        int _result;
        coroutine_handle<> _next = nullptr;

        Task get_return_object()
        {
            return Task{coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend()
        {
            return {};
        }

        // åç¨‹ç»“æŸæ—¶ ç‹å­ç»“æŸæ—¶åˆ©ç”¨æœ€åçš„co_wait final_suspend() åˆ©ç”¨final_suspendè¿”å›å€¼è¿è¡Œå…¬ä¸»åç¨‹
        auto final_suspend() noexcept
        {
            struct next_awaiter
            {
                promise_type *me;
                bool await_ready() noexcept
                {
                    return false;
                }
                coroutine_handle<> await_suspend(coroutine_handle<promise_type> h) noexcept
                {
                    // è·³åˆ°å“ªé‡Œ
                    if (h.promise()._next)
                    {
                        return h.promise()._next; // æœ‰å…¬ä¸»å°±è·³åˆ°å…¬ä¸»æŒ‚èµ·å“ªé‡Œ
                    }
                    else
                    {
                        return std::noop_coroutine();
                    }
                }
                void await_resume() noexcept
                {
                }
            };
            return next_awaiter{this};
        }

        void return_value(int i) { _result = i; }
        void unhandled_exception() {}
    };

    using handle = coroutine_handle<promise_type>;
    handle _h;
    std::future<void> _t;

    // awaiter
    bool await_ready()
    {
        return false;
    }
    void await_suspend(handle h)
    {
        _h.promise()._next = h;
        _t = std::async(
            [&]()
            {
                _h.resume();
            });
    }
    int await_resume()
    {
        return _h.promise()._result;
    }
};

Task Prince()
{
    int coins = 1;
    std::this_thread::sleep_for(500ms);
    std::cout << std::this_thread::get_id() << "Prince - found treasure!" << std::endl;
    co_return coins;
}

Task Princess(Task &future)
{
    std::cout << std::this_thread::get_id() << "Princess - wait for Prince" << std::endl;
    int c = co_await future; // è§¦å‘Princeçš„await_suspend æŠŠå…¬ä¸»åç¨‹æŒ‚åˆ°ç‹å­çš„promiseçš„next ç„¶åå¼€ä¸€ä¸ªçº¿ç¨‹å»resumeç‹å­
    std::cout << std::this_thread::get_id() << "Princess - got" << c << " coins." << std::endl;
    co_return 0;
}

int main(int argc, char **argv)
{
    auto prince = Prince();           // åˆ›å»ºç‹å­åç¨‹
    auto princess = Princess(prince); // åˆ›å»ºå…¬ä¸»åç¨‹
    princess._h.resume();             // ä¼šæ‰§è¡Œåˆ°co_wait futureè¿”å›

    while (!princess._h.done())
    {
        cout << std::this_thread::get_id() << " main wait ...\n";
        std::this_thread::sleep_for(100ms);
    }
    std::cout << std::this_thread::get_id() << " main: done" << std::endl;
    return 0;
}

/*
140521947157440Princess - wait for Prince
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947141696Prince - found treasure!
140521947141696Princess - got1 coins.
140521947157440 main: done
*/
```

## C++20å…³äºconstexprçš„ä¼˜åŒ–

### å…è®¸constexprè™šå‡½æ•°

åœ¨C++20æ ‡å‡†å‰ï¼Œè™šå‡½æ•°æ˜¯ä¸å…è®¸å£°æ˜ä¸ºconstexprçš„ã€‚å¾ˆå¤šæ—¶å€™è™šå‡½æ•°æ˜¯æ— çŠ¶æ€çš„ï¼Œè¿™ç§æƒ…å†µä¸‹æ˜¯æœ‰æ¡ä»¶ä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¢«ä¼˜åŒ–çš„ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    virtual int f() const { return 1; }
};

int main(int argc, char **argv)
{
    X x;
    int i = x.f();
    return 0;
}
```

å¦‚æœä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¿›è¡Œä¼˜åŒ–ï¼Œåˆ™å¯ä»¥å‡å°‘å‡½æ•°è°ƒç”¨ã€‚å¯æƒœåœ¨C++17æ ‡å‡†ä¸­ä¸å…è®¸æˆ‘ä»¬è¿™ä¹ˆåšï¼Œç›´åˆ°C++20æ ‡å‡†æ˜ç¡®å…è®¸åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨è™šå‡½æ•°ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä»£ç å¯ä»¥ä¿®æ”¹ä¸ºï¼š

```cpp
#include <iostream>
using namespace std;

struct X
{
    constexpr virtual int f() const
    {
        int res = 999;
        return res;
    }
};

int main(int argc, char **argv)
{
    X x;
    constexpr int i = x.f();
    // æ­¤å¤„ç­‰ä»·äº
    // constexpr int i = 999;
    std::cout << i << std::endl; // 999
    return 0;
}
```

constexprè™šå‡½æ•°åœ¨ç»§æ‰¿é‡å†™ä¸Šå¹¶æ²¡æœ‰å…¶ä»–ç‰¹æ®Šçš„è¦æ±‚ï¼Œconstexprçš„è™šå‡½æ•°å¯ä»¥è¦†ç›–é‡å†™æ™®é€šè™šå‡½æ•°ï¼Œæ™®é€šè™šå‡½æ•°ä¹Ÿå¯ä»¥è¦†ç›–é‡å†™constexprçš„è™šå‡½æ•°ã€‚

```cpp
#include <iostream>
using namespace std;

struct X1
{
    virtual int f() const = 0;
};

struct X2 : public X1
{
    constexpr virtual int f() const { return 2; }
};

struct X3 : public X2
{
    constexpr virtual int f() const { return 4; }
};

struct X4 : public X3
{
    virtual int f() const { return 5; }
};

constexpr int (X1::*pf)() const = &X1::f;

constexpr X2 x2;
static_assert(x2.f() == 2);
static_assert((x2.*pf)() == 2);

constexpr X1 const &r2 = x2;
static_assert(r2.f() == 2);
static_assert((r2.*pf)() == 2);

constexpr const X1 *p2 = &x2;
static_assert(p2->f() == 2);
static_assert((p2->*pf)() == 2);

constexpr X3 x3;
static_assert(x3.f() == 4);

constexpr X4 x4;
// static_assert(x4.f() == 5); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr
constexpr const X1 *p4 = &x4;
// static_assert(p4->f() == 4); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr

int main(int argc, char **argv)
{
    return 0;
}
```

æ€»ä¹‹å°±æ˜¯constexprè¶Šæ¥è¶Šè‡ªç”±äº†ï¼Œå¦‚æœé‡‡ç”¨æ–°ç‰ˆæœ¬çš„C++ï¼Œå…¶å®ä¸ç”¨ç‰¹æ„å»è®°å¿†è¿™äº›ä¸œè¥¿ï¼Œæ¯•ç«ŸIDEä¼šæ™ºèƒ½æç¤ºæˆ‘ä»¬çš„ã€‚åªéœ€è¦çŸ¥é“æœ‰äº›åœºæ™¯ä¸­ä½¿ç”¨è¿™äº›ç‰¹æ€§å¯ä»¥å˜å¾—æ›´é«˜æ•ˆå°±å¥½äº†ã€‚

### å…è®¸åœ¨constexprå‡½æ•°ä¸­å‡ºç°try-catch

åœ¨C++20æ ‡å‡†ä»¥å‰try-catchæ˜¯ä¸èƒ½å‡ºç°åœ¨constexprå‡½æ•°ä¸­çš„ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

constexpr int f(int x)
{
    try
    {
        return x + 1;
    }
    catch (...)
    {
        return 0;
    }
}

int main(int argc, char **argv)
{
    constexpr int n = f(1);
    return 0;
}
```

C++17ç¼–è¯‘ä¸Šé¢ä»£ç ä¼šå¾—åˆ°ä¸€ä¸ªå‹å¥½çš„è­¦å‘Šï¼ŒC++20æ ‡å‡†ç¼–è¯‘æ—¶ï¼Œå…è®¸try-catchå­˜åœ¨äº
constexprå‡½æ•°ï¼Œä½†æ˜¯throwè¯­å¥ä¾æ—§æ˜¯è¢«ç¦æ­¢çš„ï¼Œä¹Ÿå°±æ˜¯catchéƒ¨åˆ†æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œï¼Œæ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚

### å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–

ä»C++20å¼€å§‹ï¼Œæ ‡å‡†å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    bool val;
};

constexpr void f()
{
    X x;
}

int main(int argc, char **argv)
{
    f();
    return 0;
}
```

C++17ç¼–è¯‘åˆ™ä¼šæŠ¥é”™ï¼Œæç¤ºxæ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦ç”¨æˆ·æä¾›ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œæˆ–è€…C++17è¿™æ ·å†™

```cpp
struct X
{
    bool value = false;
};
```

è™½ç„¶C++20æ ‡å‡†çš„ç¼–è¯‘å™¨æ˜¯èƒ½å¤Ÿç¼–è¯‘ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶åº”è¯¥å…»æˆå£°æ˜å¯¹è±¡æ—¶éšæ‰‹åˆå§‹åŒ–çš„ä¹ æƒ¯ï¼Œé¿å…è®©ä»£ç å‡ºç°æœªå®šä¹‰çš„è¡Œä¸ºã€‚ å¯ä»¥çœ‹ ä½ å¯èƒ½ä¸çŸ¥é“çš„C++éƒ¨åˆ† çš„ â€œä¸ºä»€ä¹ˆå£°æ˜çš„å˜é‡æ²¡æœ‰è¢«é»˜è®¤åˆå§‹åŒ–â€éƒ¨åˆ†ã€‚

### å…è®¸åœ¨constexprä¸­æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜

C++20ä¹‹å‰å¯¹constexprçš„å¦ä¸€ä¸ªé™åˆ¶å°±æ˜¯ç¦æ­¢æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

union Foo
{
    int i;
    float f;
};

constexpr int use()
{
    Foo foo{};
    foo.f = 1.2f;
    foo.i = 3; // C++20ä¹‹å‰å°†ä¼šç¼–è¯‘å¤±è´¥
    return foo.i;
}

int main(int argc, char **argv)
{
    int arr[use()] = {0};
    return 0;
}
```

åœ¨GCCå’ŒMSVC C++17ä¸­ä¸Šé¢ä»£ç æ˜¯èƒ½å¤Ÿç¼–è¯‘é€šè¿‡çš„ã€‚C++20é™¤æ­¤ä¹‹å¤–è¿˜å…è®¸è®¸å¤šç‰¹æ€§ï¼Œå¦‚å…è®¸dynamic_castå’Œtypeidå‡ºç°åœ¨
å¸¸é‡è¡¨è¾¾å¼ä¸­ï¼Œå…è®¸åœ¨constexprå‡½æ•°ä½¿ç”¨æœªç»è¯„ä¼°çš„å†…è”æ±‡ç¼–ã€‚

### ä½¿ç”¨constevalå£°æ˜ç«‹å³å‡½æ•°

constexprå£°æ˜å‡½æ•°å¹¶ä¸ä¸€æ¥å¸¸é‡è¡¨è¾¾å¼ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œåœ¨éå¸¸é‡è¡¨è¾¾å¼ç¯å¢ƒä¸­ï¼Œå‡½æ•°å¯ä»¥é€€åŒ–è¡¨ç°ä¸ºæ™®é€šå‡½æ•°ã€‚ä½†æ˜¯æœ‰æ—¶å€™
æˆ‘ä»¬å¸Œæœ›ç¡®ä¿å‡½æ•°åœ¨ç¼–è¯‘æœŸå°±æ‰§è¡Œè®¡ç®—ï¼Œæ— æ³•åœ¨ç¼–è¯‘æœŸç¡®å®šçš„ç›´æ¥è®©ç¼–è¯‘å™¨æŠ¥é”™ã€‚
C++20æ¨å‡ºäº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µ ç«‹å³å‡½æ•°ï¼Œç«‹å³å‡½æ•°éœ€è¦ä½¿ç”¨constevalè¯´æ˜ç¬¦æ¥å£°æ˜ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

constexpr int r = sqr(100);
int x = 100;
int r2 = sqr(x); // ç¼–è¯‘é”™è¯¯ è°ƒç”¨ consteval å‡½æ•° "sqr" ä¸ä¼šç”Ÿæˆæœ‰æ•ˆçš„å¸¸æ•°è¡¨è¾¾å¼
// å› ä¸ºxä¸æ˜¯constä¹Ÿä¸æ˜¯constexpr
// sqrç”¨constevalå£°æ˜ä¸ä¼šé€€åŒ–ä¸ºæ™®é€šå‡½æ•°

int main(int argc, char **argv)
{
    return 0;
}
```

å¦‚æœä¸€ä¸ªç«‹å³å‡½æ•°åœ¨å¦å¤–ä¸€ä¸ªç«‹å³å‡½æ•°ä¸­è¢«è°ƒç”¨ï¼Œåˆ™å‡½æ•°å®šä¹‰æ—¶çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä¸å¿…æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ã€‚æ€ä¹ˆç†è§£å‘¢ï¼Œå°±æ˜¯ä¼ å‚é—®é¢˜ï¼Œä¸‹é¢çš„nåœ¨sqrsqrå‡½æ•°ä¸­çœ‹ï¼Œä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼,ä½†æ˜¯æ˜¯æ²¡é—®é¢˜çš„ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

consteval int sqrsqr(int n)
{
    n = 5;//è¿™é‡Œæ²¡é—®é¢˜
    return sqr(sqr(n));
}

int main(int argc, char **argv)
{
    int arr[sqrsqr(10)]{0};
    std::cout << sizeof(arr) / sizeof(int) << std::endl; // 625
    return 0;
}
```

lambdaè¡¨è¾¾å¼ä¹Ÿå¯ä»¥ä½¿ç”¨constevalè¯´æ˜ç¬¦

```cpp
#include <iostream>
using namespace std;

auto sqr = [](int n) consteval
{ return n * n; };
int r = sqr(100);

int main(int argc, char **argv)
{
    std::cout << r << std::endl; // 10000
    auto ptr = sqr;//gccå®æµ‹è·å–ç«‹å³å‡½æ•°çš„å‡½æ•°åœ°å€æ˜¯æ²¡æœ‰é—®é¢˜çš„
    std::cout << ptr(100) << std::endl;
    return 0;
}
```

### ä½¿ç”¨constinitæ£€æŸ¥å¸¸é‡åˆå§‹åŒ–

C++ä¸­æœ‰ä¸€ç§å…¸å‹çš„é”™è¯¯å«åš â€œStatic Initialization Order Fiascoâ€,æŒ‡çš„æ˜¯å› ä¸ºé™æ€åˆå§‹åŒ–é¡ºåºé”™è¯¯å¯¼è‡´çš„é—®é¢˜ï¼Œ
å› ä¸ºè¿™ç§é”™è¯¯å¾€å¾€å‘ç”Ÿåœ¨mainå‡½æ•°ä¹‹å‰ï¼Œæ‰€ä»¥æ¯”è¾ƒéš¾ä»¥æ’æŸ¥ã€‚åœ¨Effective C++ä¸­ä¹Ÿæœ‰è®²åˆ°ã€‚

```cpp
//a.cpp
static int a = 100;
```

```cpp
//b.cpp
extern int a;
struct X
{
    X(){
        n = a;
    }
    int n{0};
};

static X x;
```

æ²¡é”™å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬æ²¡åŠæ³•æ§åˆ¶å“ªä¸ªå¯¹è±¡å…ˆæ„é€ ï¼Œå¦‚æœxåœ¨yä¹‹å‰æ„é€ ï¼Œå°±ä¼šå¼•å‘ä¸€ä¸ªæœªå®šä¹‰çš„ç»“æœã€‚
ä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›ä½¿ç”¨å¸¸é‡åˆå§‹åŒ–ç¨‹åºå»åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¸å¹¸çš„æ˜¯å¸¸é‡åˆå§‹åŒ–è§„åˆ™å¾ˆå¤æ‚ã€‚
C++20å¼•å…¥constinitè¯´æ˜ç¬¦ç”¨ï¼Œä¸»è¦ç”¨äºå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å˜é‡å£°æ˜ï¼Œå®ƒè¦æ±‚å˜é‡å…·æœ‰å¸¸é‡åˆå§‹åŒ–ç¨‹åºã€‚

```cpp
#include <iostream>
using namespace std;

constinit int x = 11; // ç¼–è¯‘æˆåŠŸï¼Œå…¨å±€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­

int main(int argc, char **argv)
{
    constinit static int y = 42; // ç¼–è¯‘æˆåŠŸï¼Œé™æ€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­
    constinit int z = 7;         // ç¼–è¯‘å¤±è´¥ï¼Œå±€éƒ¨å˜é‡æ˜¯åŠ¨æ€åˆ†é…çš„
    return 0;
}
```

å…¶æ¬¡ï¼Œconstinitè¦æ±‚å˜é‡ åˆå§‹åŒ–çš„ç¨‹åºéƒ¨åˆ†åº”è¯¥æ˜¯å¸¸é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
using namespace std;

const char *f()
{
    return "hello";
}

constexpr const char *g() { return "cpp"; }
constinit const char *str1 = f(); // ç¼–è¯‘é”™è¯¯ f()ä¸æ˜¯ä¸€ä¸ªå¸¸é‡åˆå§‹åŒ–ç¨‹åº
constinit const char *str2 = g(); // ç¼–è¯‘æˆåŠŸ

int main(int argc, char **argv)
{
    return 0;
}
```

constinitè¿˜èƒ½ç”¨äºéåˆå§‹åŒ–å£°æ˜ï¼Œå‘ŠçŸ¥ç¼–è¯‘å™¨thread_localå˜é‡å·²ç»è¢«åˆå§‹åŒ–

```cpp
#include <iostream>
using namespace std;

thread_local int x = 100;

extern thread_local constinit int x;

int f()
{
    return x;
}

// constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§
constinit int number = 999;

int main(int argc, char **argv)
{
    std::cout << number << std::endl;
    return 0;
}
```

constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§ã€‚

### åˆ¤æ–­å¸¸é‡æ±‚å€¼ç¯å¢ƒ

- `std:is_constant_evaluated`

ç”¨äºæ£€æŸ¥å½“å‰è¡¨è¾¾å¼æ˜¯å¦æ˜¯ä¸€ä¸ªå¸¸é‡æ±‚å€¼ç¯å¢ƒ è¿”å›boolç±»å‹

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main(int argc, char **argv)
{
    std::cout << std::pow(2.0, 3) << std::endl; // 8
    return 0;
}
```

```cpp
#include <iostream>
#include <cmath>
#include <type_traits>
using namespace std;

constexpr double power(double b, int x)
{
    if (std::is_constant_evaluated() && x >= 0)
    {
        double r = 1.0, p = b;
        unsigned int u = (unsigned int)x;
        while (u != 0)
        {
            if (u & 1)
                r *= p;
            u /= 2;
            p *= p;
        }
        return r;
    }
    else
    {
        return std::pow(b, (double)x);
    }
}

int main(int argc, char **argv)
{
    // å¸¸é‡ç¯å¢ƒ ç¼–è¯‘æœŸé—´å°±ç®—å¥½äº†
    constexpr double kilo = power(10.0, 3);
    int n = 3;
    // éå¸¸é‡ç¯å¢ƒ è¿è¡Œæ—¶ç®—
    double mucho = power(10.0, n);
    std::cout << kilo << std::endl;  // 1000
    std::cout << mucho << std::endl; // 1000

    int n1 = -1;
    constexpr double q = power(10.0, n1); // ç¼–è¯‘é”™è¯¯  â€˜int n1â€™ is not const
    std::cout << q << std::endl;
    // å› ä¸ºä¼šèµ°std::pow

    return 0;
}
```

æœ‰ä¸€ä¸ªæ¦‚å¿µå«åš æ˜æ˜¾å¸¸é‡æ±‚å€¼

1. å¸¸é‡è¡¨è¾¾å¼ï¼Œå¦‚æ•°ç»„é•¿åº¦ã€caseè¡¨è¾¾å¼ã€éç±»å‹æ¨¡æ¿å®å‚ç­‰
2. if constexprè¯­å¥ä¸­çš„æ¡ä»¶
3. constexprå˜é‡çš„åˆå§‹åŒ–ç¨‹åº
4. ç«‹å³å‡½æ•°çš„è°ƒç”¨
5. çº¦æŸæ¦‚å¿µè¡¨è¾¾å¼
6. å¯åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨æˆ–å…·æœ‰å¸¸é‡åˆå§‹åŒ–çš„å˜é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

template <bool>
struct X
{
};

X<std::is_constant_evaluated()> x;
// éç±»å‹æ¨¡æ¿å®å‚ï¼Œå‡½æ•°è¿”å›trueï¼Œæœ€ç»ˆç±»å‹ä¸ºX<true>

int main(int argc, char **argv)
{
    return 0;
}
```

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

constexpr int f()
{
    const int n = std::is_constant_evaluated() ? 13 : 17; // næ˜¯13
    int m = std::is_constant_evaluated() ? 13 : 17;       // må¯èƒ½æ˜¯13æˆ–è€…17ï¼Œå–å†³äºå‡½æ•°ç¯å¢ƒ
    char arr[n] = {};                                     // char[13]
    return m + sizeof(arr);
}

int main(int argc, char **argv)
{
    int p = f();     // mä¸º13ï¼Œpä¸º26
    int q = p + f(); // mä¸º17ï¼Œqä¸º56 å› ä¸ºè¿™é‡Œpæ˜¯éconstçš„ èµ‹å€¼å³è¾¹ä¸æ˜¯å¸¸é‡æ±‚å€¼ç¯å¢ƒ
    return 0;
}
```

å¦‚æœå½“åˆ¤æ–­æ˜¯å¦ä¸ºæ˜æ˜¾å¸¸é‡æ±‚å€¼æ—¶å­˜åœ¨å¤šä¸ªæ¡ä»¶ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šè¯•æ¢`std::is_constant_evaluated()`ä¸¤ç§æƒ…å†µæ±‚å€¼ï¼Œæ¯”å¦‚ï¼š

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int y = 1000;
const int a = std::is_constant_evaluated() ? y : 1;
const int b = std::is_constant_evaluated() ? 2 : y;

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 1
    std::cout << b << std::endl; // 2
    return 0;
}
```

- å½“å¯¹aæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°yä¼šæ”¹å˜açš„å€¼ï¼Œæ‰€ä»¥æœ€åé€‰æ‹©`std::is_constant_evaluated()==false`
- å½“å¯¹bæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°ç»“æœæ’ä¸º2ï¼Œäºæ˜¯ç›´æ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆåˆå§‹åŒ–

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int x = 2000;
int y = 1000;
const int a = std::is_constant_evaluated() ? y : 2; // (true,y)ä¸ç¬¦åˆ (false,2)ç¬¦åˆ
const int b = std::is_constant_evaluated() ? 5 : y; // (true,5)ç¬¦åˆ
const int c = std::is_constant_evaluated() ? 3 : 4; // (true,3)ç¬¦åˆ
const int d = std::is_constant_evaluated() ? x : y; // (true,x)ä¸ç¬¦åˆ (false,y)ç¬¦åˆ

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 2
    std::cout << b << std::endl; // 5
    std::cout << c << std::endl; // 3
    std::cout << d << std::endl; // 1000
    return 0;
}
```

### C++20constexpræ€»ç»“

æˆ‘åªæƒ³å–Šï¼Œä»€ä¹ˆç‹—å±C++ï¼Œå¤§å‚»é€¼ã€‚

## å±æ€§è¯´æ˜ç¬¦å’Œæ ‡å‡†å±æ€§

å„ç§ç¼–è¯‘å™¨GCCã€MSVCç­‰ç­‰ æä¾›äº†è‡ªå®¶çš„å±æ€§è¯­æ³•

GCC

```cpp
_attribute__((attribute-list))
// ä¾‹å¦‚
_attribute__((aligned(16))) class X
{
    int i;
};
```

MSVC

```cpp
__declspec(attribute-list)
```

ä¸è¿‡åˆ«ç®¡è¿™äº›ï¼Œä¹Ÿä¸è¦å…³å¿ƒï¼Œä¹Ÿä¸è¦äº†è§£ï¼Œç†è§£ä½¿ç”¨è¿™äº›ä¸œè¥¿åªä¼šå¢åŠ å¼€å‘çš„è´Ÿæ‹…ã€‚æˆ‘ä»¬åº”è¯¥åªå…³æ³¨C++æ ‡å‡†ï¼Œ
ä½¿ç”¨C++æ ‡å‡†ã€‚

### æ ‡å‡†å±æ€§è¯´æ˜ç¬¦è¯­æ³•

C++11æ ‡å‡†çš„å±æ€§è¡¨ç¤ºæ–¹æ³•æ˜¯

```cpp
[[attr]] [[attr1, attr2, attr3(args)]]
[[namespace:::attr(args)]]
```

æœ‰å±æ€§å‘½åç©ºé—´çš„æ¦‚å¿µå¦‚

```cpp
[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]]
inline int f();
// æˆ–è€…
[[gnu::always_inline, gnu::hot, gnu::const, nodiscard]]
inline int f();
```

C++17æ ‡å‡†å¯¹å‘½åç©ºé—´å±æ€§å£°æ˜åšäº†ä¼˜åŒ–å¼•å…¥äº†usingå…³é”®è¯æ‰“å¼€å±æ€§å‘½åç©ºé—´

```cpp
[[ using attribute-namespace : attribute-list]]
```

å¦‚æ”¹å†™å‡½æ•°f

```cpp
[[using gnu : always_inline, hot, const]]
[[nodiscard]]
inline int f();
```

### æ ‡å‡†å±æ€§

C++11åˆ°C++20ä¸€å…±å®šä¹‰äº†9ç§æ ‡å‡†å±æ€§ã€‚

### noreturn

C++11å¼•å…¥äº†noreturnå±æ€§ï¼Œå®ƒæ˜¯ä¸€ç§å‡½æ•°å±æ€§ï¼Œç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°ä¸ä¼šè¿”å›ã€‚è¿™åœ¨ç¼–å†™ç‰¹å®šç±»å‹çš„å‡½æ•°æ—¶éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚ç»ˆæ­¢ç¨‹åºçš„å‡½æ•°æˆ–è€…æ°¸è¿œä¸ä¼šè¿”å›çš„å‡½æ•°ã€‚ä¸€ä¸ªå¸¸è§çš„ç”¨ä¾‹æ˜¯åœ¨å‡½æ•°ä¸­ä½¿ç”¨`abort()`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šç«‹å³ç»ˆæ­¢ç¨‹åºæ‰§è¡Œã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œ`abort()`å‡½æ•°è¢«è°ƒç”¨åç¨‹åºä¸ä¼šå†ç»§ç»­æ‰§è¡Œï¼Œå› æ­¤å¯ä»¥å°†å…¶å£°æ˜ä¸ºnoreturnï¼Œä»¥ä¾¿é€šçŸ¥ç¼–è¯‘å™¨è¿™ä¸€ç‚¹ã€‚

è¿™æœ‰åŠ©äºç¼–è¯‘å™¨è¿›è¡Œæ›´å¥½çš„ä¼˜åŒ–ï¼ŒåŒæ—¶ä¹Ÿå‘ä»£ç çš„è¯»è€…ä¼ è¾¾äº†æ¸…æ™°çš„æ„å›¾ã€‚æ³¨æ„è¿™é‡Œçš„ä¸ä¼šè¿”å›ä¸æ˜¯è¿”å›voidï¼Œè€Œæ˜¯ä»€ä¹ˆéƒ½ä¸è¿”å›ä¸ä¼šè¿”å›ã€‚

```cpp
#include <iostream>
using namespace std;

[[noreturn]] void foo()
{
    std::cout << "foo()" << std::endl;
    abort();
}

void bar()
{
    std::cout << "bar()" << std::endl;
}

int main(int argc, char **argv)
{
    foo();
    bar();
    return 0;
}
```

### carries_dependency

æŒ‡ç¤ºé‡Šæ”¾æ¶ˆè´¹ `std::memory_order` ä¸­çš„ä¾èµ–é“¾ä¼ è¿›å’Œä¼ å‡ºè¯¥å‡½æ•°ï¼Œè¿™å…è®¸ç¼–è¯‘å™¨è·³è¿‡ä¸å¿…è¦çš„å†…å­˜æ …æ æŒ‡ä»¤ã€‚

æ­¤å±æ€§å¯åœ¨ä¸¤ç§æƒ…å½¢ä¸­å‡ºç°ï¼š

- å®ƒå¯åº”ç”¨äºå‡½æ•°æˆ– lambda è¡¨è¾¾å¼çš„å½¢å‚å£°æ˜ï¼Œè¯¥æƒ…å†µä¸‹å®ƒæŒ‡ç¤ºä»è¯¥å½¢å‚çš„åˆå§‹åŒ–å‘è¯¥å¯¹è±¡çš„å·¦å€¼åˆ°å³å€¼è½¬æ¢ä¸­æºå¸¦ä¾èµ–ã€‚
- å®ƒå¯åº”ç”¨äºå‡½æ•°å£°æ˜æ•´ä½“ï¼Œè¯¥æƒ…å†µä¸‹å®ƒæŒ‡ç¤ºä»è¿”å›å€¼å‘å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼çš„æ±‚å€¼ä¸­æºå¸¦ä¾èµ–ã€‚æ­¤å±æ€§å¿…é¡»å‡ºç°åœ¨ä»»æ„ç¿»è¯‘å•å…ƒä¸­æŸä¸ªå‡½æ•°æˆ–å…¶å½¢å‚ä¹‹ä¸€çš„é¦–ä¸ªå£°æ˜ä¸Šã€‚è‹¥å¦ä¸€ç¿»è¯‘å•å…ƒä¸­çš„è¯¥å‡½æ•°æˆ–å…¶å½¢å‚çš„é¦–ä¸ªå£°æ˜ä¸Šæœªä½¿ç”¨è¯¥å±æ€§ï¼Œåˆ™ç¨‹åºéè‰¯æ„ï¼›ä¸è¦æ±‚è¯Šæ–­ã€‚

åæ­£æˆ‘ç°åœ¨è¿™ä¸ªèœé¸¡æ˜¯ä¸ç†è§£ï¼Œåé¢å­¦è¿‡åŸå­æ“ä½œçš„å†çœ‹å§ã€‚

### deprecated

deprecatedæ˜¯åœ¨C++14æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œå¸¦æœ‰æ­¤å±æ€§çš„å®ä½“è¢«å£°æ˜ä¸ºå¼ƒç”¨ï¼Œè™½ç„¶åœ¨ä»£ç ä¸­ä¾ç„¶å¯ä»¥ä½¿ç”¨å®ƒä»¬ï¼Œä½†æ˜¯å¹¶ä¸é¼“åŠ±è¿™ä¹ˆåšã€‚å½“ä»£ç ä¸­å‡ºç°å¸¦æœ‰å¼ƒç”¨å±æ€§çš„å®ä½“æ—¶ï¼Œç¼–è¯‘å™¨é€šå¸¸ä¼šç»™å‡ºè­¦å‘Šè€Œä¸æ˜¯é”™è¯¯ã€‚

```cpp
#include <iostream>
using namespace std;

[[deprecated("foo was deprecated, use bar instead")]] void foo()
{
}
// warning: â€˜void foo()â€™ is deprecated: foo was deprecated, use bar instead [-Wdeprecated-declarations]

class [[deprecated]] X
{
};

int main(int argc, char **argv)
{
    X x;
    foo();
    return 0;
}
```

### fallthrough

fallthroughæ˜¯C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥åœ¨switchè¯­å¥çš„ä¸Šä¸‹æ–‡ä¸­æç¤ºç¼–è¯‘å™¨ç›´è½è¡Œä¸ºæ˜¯æœ‰æ„çš„ï¼Œå¹¶ä¸éœ€è¦ç»™å‡ºè­¦å‘Šã€‚

```cpp
#include <iostream>
using namespace std;

void bar()
{
    std::cout << "bar()" << std::endl;
}

void foo(int a)
{
    switch (a)
    {
    case 0:
        break;
    case 1:
        bar();
        [[fallthrough]];
    case 2:
        bar();
        break;
    default:
        break;
    }
}

int main(int argc, char **argv)
{
    foo(1);
    // bar()
    // bar()
    return 0;
}
```

### nodiscard

nodiscardæ˜¯åœ¨C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å£°æ˜å‡½æ•°çš„è¿”å›å€¼ä¸åº”è¯¥è¢«èˆå¼ƒï¼Œå¦åˆ™é¼“åŠ±ç¼–è¯‘å™¨ç»™å‡ºè­¦å‘Šæç¤ºã€‚nodiscardå±æ€§ä¹Ÿå¯ä»¥å£°æ˜åœ¨ç±»æˆ–è€…æšä¸¾ç±»å‹ä¸Šï¼Œä½†æ˜¯å®ƒå¯¹ç±»æˆ–è€…æšä¸¾ç±»å‹æœ¬èº«å¹¶ä¸èµ·ä½œç”¨ï¼Œåªæœ‰å½“è¢«å£°æ˜ä¸ºnodiscardå±æ€§çš„ç±»æˆ–è€…æšä¸¾ç±»å‹è¢«å½“ä½œå‡½æ•°è¿”å›å€¼çš„æ—¶å€™æ‰å‘æŒ¥ä½œç”¨ï¼š

```cpp
#include <iostream>
using namespace std;

class [[nodiscard]] X
{
};

[[nodiscard]] int foo()
{
    return 1;
}

X bar()
{
    return X();
}

int main(int argc, char **argv)
{
    X x;
    foo();
    // warning: ignoring return value of â€˜int foo()â€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    bar();
    // warning: ignoring returned value of type â€˜Xâ€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    return 0;
}
```

nodiscardå±æ€§åªé€‚ç”¨äºè¿”å›å€¼ç±»å‹çš„å‡½æ•°ï¼Œå¯¹äºè¿”å›å¼•ç”¨çš„å‡½æ•°ä½¿ç”¨nodiscardå±æ€§æ˜¯æ²¡æœ‰ä½œç”¨çš„

```cpp
#include <iostream>
using namespace std;

class [[nodiscard]] X
{
};

X &bar(X &x)
{
    return x;
}

int main(int argc, char **argv)
{
    X x;
    bar(x); // barè¿”å›å¼•ç”¨,nodiscardä¸èµ·ä½œç”¨ï¼Œç¼–è¯‘æ—¶ä¸ä¼šå¼•å‘è­¦å‘Š
    return 0;
}
```

nodiscardå±æ€§æœ‰å‡ ä¸ªå¸¸ç”¨åœºåˆ

1. é˜²æ­¢èµ„æºæ³„éœ²ï¼Œå¯¹äºåƒmallocæˆ–è€…newè¿™æ ·çš„å‡½æ•°æˆ–è€…è¿ç®—ç¬¦ï¼Œå®ƒä»¬è¿”å›çš„å†…å­˜æŒ‡é’ˆæ˜¯éœ€è¦åŠæ—¶é‡Šæ”¾çš„ï¼Œå¯ä»¥ä½¿ç”¨nodiscardå±æ€§æç¤ºè°ƒç”¨è€…ä¸è¦å¿½ç•¥è¿”å›å€¼ã€‚
2. å¯¹äºå·¥å‚å‡½æ•°è€Œè¨€ï¼ŒçœŸæ­£æœ‰æ„ä¹‰çš„æ˜¯å›è¿”çš„å¯¹è±¡è€Œä¸æ˜¯å·¥å‚å‡½æ•°ï¼Œå°†nodiscardå±æ€§åº”ç”¨åœ¨å·¥å‚å‡½æ•°ä¸­ä¹Ÿå¯ä»¥æç¤ºè°ƒç”¨è€…åˆ«å¿˜äº†ä½¿ç”¨å¯¹è±¡ï¼Œå¦åˆ™ç¨‹åºä»€ä¹ˆä¹Ÿä¸ä¼šåšã€‚
3. å¯¹äºè¿”å›å€¼ä¼šå½±å“ç¨‹åºè¿è¡Œæµç¨‹çš„å‡½æ•°è€Œè¨€ï¼Œnodiscardå±æ€§ä¹Ÿæ˜¯ç›¸å½“åˆé€‚çš„ï¼Œå®ƒå‘Šè¯‰è°ƒç”¨æ–¹å…¶è¿”å›å€¼åº”è¯¥ç”¨äºæ§åˆ¶åç»­çš„æµç¨‹ã€‚å¦‚è¿”å›é”™è¯¯ç ï¼Œä¿è¯ç¨‹åºæœ‰è¿›è¡Œåˆ¤æ–­

C++20å¼€å§‹ï¼Œnodiscardå±æ€§æ”¯æŒå°†ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢é‡ä½œä¸ºå±æ€§å‚æ•°ï¼Œå­—ç¬¦ä¸²ä¼šåŒ…åœ¨è­¦å‘Šä¸­

```cpp
#include <iostream>
using namespace std;

class [[nodiscard("my nodiscard alert")]] X
{
};

X bar(X &x)
{
    return x;
}

int main(int argc, char **argv)
{
    X x;
    bar(x);
    // warning: ignoring returned value of type â€˜Xâ€™, declared with attribute â€˜nodiscardâ€™: â€˜my nodiscard alertâ€™ [-Wunused-result]
    return 0;
}
```

C++20å¼€å§‹ï¼Œnodiscardå±æ€§è¿˜èƒ½ç”¨äºæ„é€ å‡½æ•°ï¼Œå®ƒä¼šåœ¨ç±»å‹æ„å»ºä¸´æ—¶å¯¹è±¡çš„æ—¶å€™è®©ç¼–è¯‘å™¨å‘å‡ºè­¦å‘Š

```cpp
#include <iostream>
using namespace std;

class X
{
public:
    [[nodiscard]] X() {}
    X(int a) {}
};

int main(int argc, char **argv)
{
    X x;
    X{}; // warning: ignoring return value of â€˜X::X()â€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    X{42};
    return 0;
}
// X {}
// æ„é€ äº†ä¸´æ—¶å¯¹è±¡ï¼Œäºæ˜¯ç¼–è¯‘å™¨ç»™å‡ºå¿½ç•¥X::X() è¿”å›å€¼çš„è­¦å‘Šï¼›X{42};
// ä¸ä¼šäº§ç”Ÿç¼–è¯‘è­¦å‘Šï¼Œå› ä¸ºX(int a) {}
// æ²¡æœ‰nodicardå±æ€§ã€‚
```

### maybe_unused

maybe_unusedæ˜¯åœ¨C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å£°æ˜å®ä½“å¯èƒ½ä¸ä¼šè¢«åº”ç”¨ä»¥æ¶ˆé™¤ç¼–è¯‘å™¨è­¦å‘Šã€‚

```cpp
#include <iostream>
using namespace std;

int foo(int a [[maybe_unused]], int b [[maybe_unused]])
{
    return 5;
}

int main(int argc, char **argv)
{
    foo(1, 2);
    int a [[maybe_unused]] = 9;
    return 0;
}
```

maybe_unusedå±æ€§é™¤ä½œä¸ºå‡½æ•°å½¢å‚å±æ€§å¤–ï¼Œè¿˜å¯ä»¥ç”¨åœ¨å¾ˆå¤šåœ°æ–¹ï¼Œæ¯”å¦‚ç±»ã€ç»“æ„ä½“ã€è”åˆç±»å‹ã€æšä¸¾ç±»å‹ã€å‡½æ•°ã€å˜é‡ç­‰ã€‚

### likelyå’Œunlikely

likelyå’Œunlikelyæ˜¯C++20æ ‡å‡†å¼•å…¥çš„å±æ€§ï¼Œä¸¤ä¸ªå±æ€§éƒ½æ˜¯å£°æ˜åœ¨æ ‡ç­¾æˆ–è€…è¯­å¥ä¸Šçš„ã€‚å…¶ä¸­likelyå±æ€§å…è®¸ç¼–è¯‘å™¨å¯¹è¯¥å±æ€§æ‰€åœ¨çš„æ‰§è¡Œè·¯å¾„ç›¸å¯¹äºå…¶ä»–æ‰§
è¡Œè·¯å¾„è¿›è¡Œä¼˜åŒ–ï¼›è€Œunlikelyå±æ€§æ°æ°ç›¸åã€‚é€šå¸¸ï¼Œlikelyå’Œunlikelyè¢«å£°æ˜åœ¨switchè¯­å¥ï¼š

é€šå¸¸æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šå‡å®šæ¡ä»¶åˆ†æ”¯çš„å¯èƒ½æ€§æ˜¯å‡ç­‰çš„ï¼Œä½†å®é™…æƒ…å†µä¸­ï¼ŒæŸäº›åˆ†æ”¯å¯èƒ½ä¼šæ›´æœ‰å¯èƒ½å‘ç”Ÿï¼Œè€ŒæŸäº›åˆ†æ”¯åˆ™è¾ƒå°‘å‘ç”Ÿã€‚é€šè¿‡ä½¿ç”¨`[[likely]]`å’Œ`[[unlikely]]`å±æ€§ï¼Œå¼€å‘äººå‘˜å¯ä»¥å‘ç¼–è¯‘å™¨æä¾›å…³äºæ¡ä»¶åˆ†æ”¯å¯èƒ½æ€§çš„æç¤ºï¼Œä»¥ä¾¿ç¼–è¯‘å™¨å¯ä»¥ç›¸åº”åœ°ä¼˜åŒ–ç”Ÿæˆçš„ä»£ç ã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int a = 1, b = 2;
    if (a < b) [[likely]]
    {
    }
    else if (a == b) [[unlikely]]
    {
    }
    else
    {
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;

int f(int i)
{
    switch (i)
    {
    case 1:
        [[fallthrough]];
    [[likely]] case 2:
        return 1;
    default:
        break;
    }
    return 2;
}

int main(int argc, char **argv)
{
    f(1);
    return 0;
}
```

### no_unique_address

no_unique_addressæ˜¯C++20æ ‡å‡†å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§æŒ‡ç¤ºç¼–è¯‘å™¨è¯¥æ•°æ®æˆå‘˜ä¸éœ€è¦å”¯ä¸€çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¸éœ€è¦ä¸å…¶ä»–éé™æ€æ•°æ®æˆå‘˜ä½¿ç”¨ä¸åŒçš„åœ°å€ã€‚æ³¨æ„ï¼Œè¯¥å±æ€§å£°æ˜çš„å¯¹è±¡å¿…é¡»æ˜¯éé™æ€æ•°æ®æˆå‘˜ä¸”ä¸ä¸ºä½åŸŸï¼š

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct X
{
    int i;
    Empty e;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 8
    X x;
    printf("%p\n", &x.i); // 0x7ffe56fc7510
    printf("%p\n", &x.e); // 0x7ffe56fc7514
    return 0;
}
```

æœ‰ä¸€ç§æ–¹æ³•æ˜¯è®©ç©ºçš„eæ²¡æœ‰è‡ªå·±çš„åœ°å€,ä½¿ç”¨no_unique_address

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct X
{
    int i;
    [[no_unique_address]] Empty e;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 4
    X x;
    printf("%p\n", &x.i); // 0x7ffc99948c04
    printf("%p\n", &x.e); // 0x7ffc99948c04
    return 0;
}
```

å¦‚æœå­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„ç±»å‹ä¸”å®ƒä»¬éƒ½å…·æœ‰no_unique_addresså±æ€§ï¼Œç¼–è¯‘å™¨ä¸ä¼šé‡å¤åœ°å°†å…¶å †åœ¨åŒä¸€ä¸ªåœ°å€

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct Empty1
{
};

struct X
{
    int i;
    [[no_unique_address]] Empty e, e1;
};

struct X1
{
    int i;
    [[no_unique_address]] Empty e;
    [[no_unique_address]] Empty1 e1;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 8
    X x;
    printf("%p\n", &x.i);  // 0x7fff305d0640
    printf("%p\n", &x.e);  // 0x7fff305d0640
    printf("%p\n", &x.e1); // 0x7fff305d0644

    X1 x1;
    printf("%p\n", &x1.i);  // 0x7ffe49f9036c
    printf("%p\n", &x1.e);  // 0x7ffe49f9036c
    printf("%p\n", &x1.e1); // 0x7ffe49f9036c

    return 0;
}
```

no_unique_addressè¿™ä¸ªå±æ€§çš„ä½¿ç”¨åœºæ™¯ã€‚è¯»è€…ä¸€å®šå†™è¿‡æ— çŠ¶æ€çš„ç±»ï¼Œè¿™ç§ç±»ä¸éœ€è¦æœ‰æ•°æ®æˆå‘˜ï¼Œå”¯ä¸€éœ€è¦åšçš„å°±æ˜¯å®ç°ä¸€äº›å¿…è¦çš„å‡½æ•°ï¼Œ
å¸¸è§çš„æ˜¯STLä¸­ä¸€äº›ç®—æ³•å‡½æ•°æ‰€éœ€çš„å‡½æ•°å¯¹è±¡ï¼ˆä»¿å‡½æ•°ï¼‰ã€‚è€Œè¿™ç§ç±»ä½œä¸ºæ•°æ®æˆå‘˜åŠ å…¥å…¶ä»–ç±»æ—¶ï¼Œä¼šå æ®ç‹¬ä¸€æ— äºŒçš„å†…å­˜åœ°å€ï¼Œå®é™…ä¸Šè¿™æ˜¯æ²¡æœ‰å¿…è¦çš„ã€‚
æ‰€ä»¥ï¼Œåœ¨C++20çš„ç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨no_unique_addresså±æ€§ï¼Œè®©å…¶ä¸éœ€è¦å ç”¨é¢å¤–çš„å†…å­˜åœ°å€ç©ºé—´ã€‚

## æ–°å¢é¢„å¤„ç†å™¨å’Œå®

### é¢„å¤„ç†å™¨__has_include

C++17ä¸ºé¢„å¤„ç†å™¨å¢åŠ äº†ä¸€ä¸ªæ–°ç‰¹æ€§ï¼Œ`__has_include`,ç”¨äºåˆ¤æ–­æŸä¸ªå¤´æ–‡ä»¶æ˜¯å¦èƒ½è¢«åŒ…å«è¿›æ¥

```cpp
#include <iostream>

#if __has_include(<optional>)
#include <optional>
#define have_optional 1
#elif __has_include(<experimental/optional>)
#include <experimental/optional>
#define have_optional 1
#define experimental_optional 1
#else
#define have_optional 0
#endif

using namespace std;

int main(int argc, char **argv)
{
    std::cout << have_optional << std::endl;
    return 0;
}
```

### ç‰¹æ€§æµ‹è¯•å®

C++20æ ‡å‡†æ·»åŠ äº†ä¸€ç»„ç”¨äºæµ‹è¯•åŠŸèƒ½ç‰¹æ€§çš„å®ï¼Œè¿™ç»„å®å¯ä»¥å¸®åŠ©æˆ‘ä»¬æµ‹è¯•å½“å‰çš„ç¼–è¯‘ç¯å¢ƒå¯¹å„ç§åŠŸèƒ½ç‰¹æ€§çš„æ”¯æŒç¨‹åº¦ã€‚

### å±æ€§ç‰¹æ€§æµ‹è¯•å®

```cpp
std::cout << __has_cpp_attribute(deprecated);
// å°†ä¼šè¾“å‡ºè¯¥å±æ€§æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ 201309
```

```cpp
å±æ€§        å€¼
carries_dependency 200809L
deprecated 201309L
fallthrough 201603L
likely 201803L
maybe_unused 201603L
no_unique_address 201803L
nodiscard 201603L
noreturn 200809L
unlikely 201803L
```

### è¯­è¨€åŠŸèƒ½ç‰¹æ€§æµ‹è¯•å®

ä»¥ä¸‹åˆ—è¡¨çš„å®ä»£è¡¨ç¼–è¯‘ç¯å¢ƒæ‰€æ”¯æŒçš„è¯­è¨€åŠŸèƒ½ç‰¹æ€§ï¼Œæ¯ä¸ªå®å°†è¢«å±•å¼€ä¸ºè¯¥ç‰¹æ€§
æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å®å±•å¼€çš„å€¼ä¼šéšç€ç‰¹æ€§çš„å˜æ›´è€Œæ›´æ–°ã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    std::cout << __cpp_aggregate_bases << std::endl; // 201603
    return 0;
}
```

<https://en.cppreference.com/w/cpp/feature_test>

```cpp
å®         å€¼
__cpp_aggregate_bases 201603L
__cpp_aggregate_nsdmi 201304L
__cpp_aggregate_paren_init 201902L
__cpp_alias_templates 200704L
__cpp_aligned_new 201606L
__cpp_attributes 200809L
__cpp_binary_literals 201304L
__cpp_capture_star_this 201603L
__cpp_char8_t 201811L
__cpp_concepts 201907L
__cpp_conditional_explicit 201806L
__cpp_consteval 201811L
__cpp_constexpr 201907L
__cpp_constexpr_dynamic_alloc 201907L
__cpp_constexpr_in_decltype 201711L
__cpp_constinit 201907L
__cpp_coroutines 201902L
__cpp_decltype 200707L
__cpp_decltype_auto 201304L
// ...............
```

### æ ‡å‡†åº“åŠŸèƒ½ç‰¹æ€§æµ‹è¯•å®

ä»¥ä¸‹åˆ—è¡¨çš„å®ä»£è¡¨ç¼–è¯‘ç¯å¢ƒæ‰€æ”¯æŒçš„æ ‡å‡†åº“åŠŸèƒ½ç‰¹æ€§ï¼Œé€šå¸¸åŒ…å«åœ¨`<version>`å¤´æ–‡ä»¶æˆ–è€…è¡¨ä¸­çš„ä»»æ„å¯¹åº”å¤´æ–‡ä»¶ä¸­ã€‚
æ¯ä¸ªå®å°†è¢«å±•å¼€ä¸ºè¯¥ç‰¹æ€§æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å®å±•å¼€çš„å€¼ä¼šéšç€ç‰¹æ€§çš„å˜æ›´è€Œæ›´æ–°ã€‚

<https://en.cppreference.com/w/cpp/utility/feature_test>

```cpp
å®      å€¼       å¤´æ–‡ä»¶
__cpp_lib_addressof_constexpr 201603L <memory>

__cpp_lib_allocator_traits_is_always_equal
201411L
<memory> <scoped_allocator> <string> <deque> <forward_list> <list> <vector> <map><set> <unordered_map> <unordered_set>

__cpp_lib_any 201606L <any>
__cpp_lib_apply 201603L <tuple>
// ...............
```

### æ–°å¢å®VA_OPT

ä»C99æ ‡å‡†å¼€å§‹ï¼ŒCè¯­è¨€å¼•å…¥äº†å¯å˜å‚æ•°å®`__VA_ARGS`,C++11æ ‡å‡†ä¹Ÿå°†å…¶çº³å…¥äº†æ ‡å‡†ã€‚`__VA_ARGS__`å¸¸è§çš„ç”¨æ³•å¦‚æ‰“å°æ—¥å¿—ä¸Šã€‚

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, __VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello %d", 2024); //["__FILE__":8]hello 2024
    printf("hello" "world\n");//helloworld
    return 0;
}
```

ä¸Šé¢æœ‰ä¸ªé—®é¢˜å°±æ˜¯å¦‚æœLOGåªç”¨ç¬¬ä¸€ä¸ªå‚æ•°ä¼šæŠ¥é”™,é—®é¢˜å°±æ˜¯å¤šäº†ä¸ª `,`

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, __VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello");
    // æ‰©å±•åˆ°printf("[\"__FILE__\":%d]" "hello" "\n", 8, )
    return 0;
}
```

å¯ä»¥ä½¿ç”¨ `##` è¿æ¥`__VA_ARGS__`

åœ¨C/C++ä¸­ï¼Œ`##` æ˜¯é¢„å¤„ç†å™¨ä¸­çš„è¿æ¥è¿ç®—ç¬¦ã€‚å®ƒçš„ä½œç”¨æ˜¯åœ¨å®å±•å¼€è¿‡ç¨‹ä¸­ï¼Œ
å°†å…¶å‰åçš„æ ‡è¯†ç¬¦è¿æ¥æˆä¸€ä¸ªå•ç‹¬çš„æ ‡è¯†ç¬¦æˆ–è€…åˆ é™¤å‰é¢çš„é€—å·ã€‚

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, ##__VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello"); // ["__FILE__":8]hello
    // æ‰©å±•åˆ°printf("[\"__FILE__\":%d]" "hello" "\n", 8)
    return 0;
}
```

C++20å¼•å…¥äº†ä¸€ä¸ªæ–°çš„å®`__VA_OPT__`ä»¤å¯å˜å‚æ•°å®æ›´å®¹æ˜“åœ¨å¯å˜å‚æ•°ä¸ºç©ºçš„æƒ…å†µä¸‹ä½¿ç”¨

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[" __FILE__      \
                             ":%d] " msg "\n", \
                             __LINE__ __VA_OPT__(, ) __VA_ARGS__)

int main(int argc, char **argv)
{
    // æ‰©å±•åˆ° printf("[" "/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp" ":%d] " "hello" "\n", 11  )
    LOG("hello");
    // [/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp:10] hello
    return 0;
}
```
