# ğŸŒ C++20 ç‰¹æ€§

C++20 å¼•å…¥äº†è®¸å¤šæ–°ç‰¹æ€§å’Œè¯­è¨€æ”¹è¿›ï¼Œä¸‹é¢æ˜¯å…¶ä¸­ä¸€äº›ä¸»è¦çš„ç‰¹æ€§ï¼š

1ã€æ¦‚å¿µï¼ˆConceptsï¼‰ï¼šC++20 å¼•å…¥äº†æ¦‚å¿µçš„æ¦‚å¿µï¼Œå…è®¸ç¨‹åºå‘˜åœ¨ç¼–å†™æ¨¡æ¿ä»£ç æ—¶æŒ‡å®šå‚æ•°å¿…é¡»æ»¡è¶³çš„ç±»å‹çº¦æŸã€‚

2ã€æ¨¡å—ï¼ˆModulesï¼‰ï¼šC++20 å¼•å…¥äº†æ¨¡å—ï¼Œå…è®¸ç¨‹åºå‘˜å°†ä»£ç åˆ†å‰²ä¸ºé€»è¾‘å•å…ƒï¼Œå‡å°‘äº†å¤´æ–‡ä»¶åŒ…å«å¸¦æ¥çš„ç¼–è¯‘æ—¶é—´å’ŒäºŒè¿›åˆ¶æ–‡ä»¶å¤§å°ã€‚

3ã€åç¨‹ï¼ˆCoroutinesï¼‰ï¼šC++20 å¼•å…¥äº†åç¨‹ï¼Œä½¿å¾—å¼‚æ­¥ç¼–ç¨‹å˜å¾—æ›´åŠ ç®€å•å’Œé«˜æ•ˆã€‚

4ã€åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°æ¨¡æ¿ï¼ˆTemplate for Initialization List Constructorsï¼‰ï¼šC++20 å…è®¸ä½¿ç”¨æ¨¡æ¿å®šä¹‰åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°ï¼Œä»è€Œæ”¯æŒæ›´å¤šçš„åˆå§‹åŒ–æ–¹å¼ã€‚

5ã€constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹ä¸å†æœ‰é™åˆ¶ï¼ˆRelaxing Constraints on constexpr Functionsï¼‰ï¼šC++20 å…è®¸ constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œè€Œä¸å†æœ‰é™åˆ¶ã€‚

6ã€ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ï¼ˆConstexpr Null Pointerï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€ä¸ªæ–°çš„ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ std::nullptr_tï¼Œå…è®¸åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ›´å®‰å…¨çš„ç©ºæŒ‡é’ˆæ£€æŸ¥ã€‚

7ã€ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼ˆCompile-Time String Operationsï¼‰ï¼šC++20 å¼•å…¥äº†ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œå­—ç¬¦ä¸²çš„æ‹¼æ¥ã€æˆªå–å’Œè½¬æ¢ç­‰æ“ä½œã€‚

8ã€å¤šçº¿ç¨‹åº“æ”¹è¿›ï¼ˆImprovements to the Thread Libraryï¼‰ï¼šC++20 æ”¹è¿›äº†å¤šçº¿ç¨‹åº“ï¼Œå¼•å…¥äº†ä¸€äº›æ–°çš„ç‰¹æ€§ï¼Œå¦‚åŒæ­¥é˜Ÿåˆ—ã€é”å‡çº§ã€çº¿ç¨‹å±€éƒ¨å­˜å‚¨ç­‰ã€‚

9ã€å…ƒç¼–ç¨‹æ”¹è¿›ï¼ˆImprovements to Metaprogrammingï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€äº›å…ƒç¼–ç¨‹æ”¹è¿›ï¼Œå¦‚ consteval å‡½æ•°ã€requires è¡¨è¾¾å¼ã€typename åœ¨æ¨¡æ¿å‚æ•°åˆ—è¡¨ä¸­çš„ä½ç½®æ›´åŠ çµæ´»ç­‰ã€‚

10ã€ä¸‰è·¯æ¯”è¾ƒæ“ä½œç¬¦

11ã€å¼‚å¸¸è§„èŒƒ

12ã€åˆå§‹åŒ–ä¸Šä¸‹æ–‡ä¼˜åŒ–

13ã€ç±»å‹ç‰¹æ€§ä¿®æ”¹å’Œå¢å¼º

14ã€std::rangesåº“

15ã€æ•è·åˆå§‹åŒ–

16ã€çº¿ç¨‹æœ¬åœ°å­˜å‚¨

17ã€ç»Ÿä¸€çš„æ„é€ å’Œææ„

18ã€æ•°å­¦åˆ†éš”ç¬¦

19ã€åŒæ­¥é˜Ÿåˆ—

20ã€å…¶ä»–ç»†èŠ‚æ”¹è¿›ï¼šC++20 è¿˜å¼•å…¥äº†ä¸€äº›å…¶ä»–çš„ç»†èŠ‚æ”¹è¿›ï¼Œå¦‚ä¸‰å‘æ¯”è¾ƒæ“ä½œç¬¦ã€æ ¼å¼åŒ–å­—ç¬¦ä¸²å‡½æ•° std::format()ã€std::span å®¹å™¨ã€æ ‡å‡†åº“ä¸­å¯¹æ–‡ä»¶ç³»ç»Ÿçš„æ”¯æŒç­‰ã€‚

## ä¸‰å‘æ¯”è¾ƒ

### å¤ªç©ºé£èˆ¹ spaceship è¿ç®—ç¬¦

C++20æ ‡å‡†æ–°å¼•å…¥äº†ä¸€åä¸ºâ€œå¤ªç©ºé£èˆ¹â€(spaceship)çš„è¿ç®—ç¬¦`<=>`ã€‚å®ƒæ˜¯ä¸€ä¸ªä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ã€‚`<=>`å¹¶ä¸æ˜¯C++20é¦–åˆ›çš„ï¼Œå®é™…ä¸ŠPerlã€PHPã€Rubyç­‰è¯­è¨€æ—©å·²æ”¯æŒäº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼ŒC++æ˜¯åæ¥çš„å­¦ä¹ è€…ã€‚

```cpp
// lhs <=> rhs
// å¯èƒ½äº§ç”Ÿä¸‰ç§ç»“æœ è¯¥ç»“æœå¯ä»¥å’Œ0æ¯”è¾ƒ
// å°äº0 lhs < rhs
// ç­‰äº0 lhs == rhs
// å¤§äº0 lhs > rhs
#include <iostream>
using namespace std;

int main()
{
    bool b = 7 <=> 11 < 0;
    std::cout << b << std::endl; // 1
    return 0;
}
```

è¿ç®—ç¬¦`<=>`çš„è¿”å›å€¼åªèƒ½ä¸0å’Œè‡ªèº«ç±»å‹æ¥æ¯”è¾ƒï¼Œå¦‚æœåŒå…¶ä»–æ•°å€¼æ¯”è¾ƒï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

```cpp
bool b = 7 <=> 11 < 100; // ç¼–è¯‘å¤±è´¥,<=>çš„ç»“æœä¸èƒ½ä¸0ä¹‹å¤–çš„æ•°å€¼æ¯”è¾ƒ
```

### ä¸‰å‘æ¯”è¾ƒçš„è¿”å›ç±»å‹

å¯ä»¥çœ‹å‡º`<=>`çš„è¿”å›ç»“æœå¹¶ä¸æ˜¯ä¸€ä¸ªæ™®é€šç±»å‹ï¼Œæ ¹æ®æ ‡å‡†ä¸‰å‘æ¯”è¾ƒä¼šè¿”å›3ç§ç±»å‹ï¼Œè€Œè¿™3ç§ç±»å‹åˆä¼šåˆ†ä¸ºæœ‰3ï½4ç§æœ€ç»ˆç»“æœã€‚

```cpp
std::strong_ordering
std::weak_ordering
std::partial_ordering
```

### std::strong_ordering

```cpp
// è¡¨è¾¾å¼ lsh <=> rhs
std::strong_ordering
    - std::strong_ordering::less    å¯¹åº” lhs  < rhs
    - std::strong_ordering::equal   å¯¹åº” lhs == rhs
    - std::strong_ordering::greater å¯¹åº” lhs  > rhs
```

`std::strong_ordering` ç±»å‹çš„ç»“æœå¼ºè°ƒçš„æ˜¯strongçš„å«ä¹‰ï¼Œè¡¨è¾¾çš„æ˜¯ä¸€ç§å¯æ›¿æ¢æ€§ï¼Œç®€å•æ¥è¯´ï¼Œè‹¥`lhs == rhs`ï¼Œé‚£ä¹ˆåœ¨ä»»ä½•æƒ…å†µä¸‹rhså’Œlhséƒ½å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) == fx(rhs)`ã€‚

å¯¹äºåŸºæœ¬ç±»å‹ä¸­çš„intç±»å‹ï¼Œä¸‰å‘æ¯”è¾ƒè¿”å›çš„æ˜¯`std::strong_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <iostream>

using namespace std;

int main()
{
    std::cout << typeid(decltype(7 <=> 11)).name();
    // St15strong_ordering
    return 0;
}
```

å¯¹äºæœ‰å¤æ‚ç»“æ„çš„ç±»å‹ï¼Œ`std::strong_ordering` è¦æ±‚å…¶æ•°æ®æˆå‘˜å’ŒåŸºç±»çš„ä¸‰å‘æ¯”è¾ƒç»“æœéƒ½ä¸º`std::strong_ordering`ã€‚ä¾‹å¦‚ï¼š

é»˜è®¤æƒ…å†µä¸‹è‡ªå®šä¹‰ç±»å‹æ˜¯ä¸å­˜åœ¨ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œéœ€è¦ç”¨æˆ·æ˜¾å¼é»˜è®¤å£°æ˜ã€‚

```cpp
#include <iostream>
#include <compare>

using namespace std;

class B
{
public:
    int a;
    long b;
    auto operator <=> (const B&) const = default;
};

class D : public B
{
public:
    short c;
    auto operator <=> (const D&) const = default;
};

int main()
{
    D x1, x2;
    std::cout << typeid(decltype(x1 <=> x2)).name() << std::endl;
    // St15strong_ordering
    return 0;
}
```

å¯¹ç»“æ„ä½“Bè€Œè¨€ï¼Œç”±äºintå’Œlongçš„æ¯”è¾ƒç»“æœéƒ½æ˜¯`std::strong_ordering`ï¼Œå› æ­¤ç»“æ„ä½“Bçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¹Ÿæ˜¯`std::strong_ordering`ã€‚  
å¯¹ç»“æ„ä½“Dï¼Œå…¶ åŸºç±» å’Œ æˆå‘˜ çš„æ¯”è¾ƒç»“æœæ˜¯`std::strong_ordering`ï¼ŒDçš„ä¸‰å‘æ¯”è¾ƒç»“æœåŒæ ·æ˜¯`std::strong_ordering`ã€‚

### std::weak_ordering

```cpp
lhs <=> rhs
    - std::weak_ ordering::less      å¯¹åº” lhs < rhs
    - std::weak_ordering::equivalent å¯¹åº” lhs == rhs
    - std::weak_ ordering::greater   å¯¹åº” lhs > rhs
```

weakè¡¨è¾¾çš„æ˜¯ä¸å¯æ›¿æ¢æ€§ã€‚å³è‹¥æœ‰`lhs == rhs`ï¼Œåˆ™rhså’Œlhsä¸å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) != fx(rhs)`ã€‚è¿™ç§æƒ…å†µåœ¨åŸºç¡€ç±»å‹ä¸­å¹¶æ²¡æœ‰ï¼Œä½†æ˜¯å®ƒå¸¸å¸¸å‘ç”Ÿåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»ä¸­ï¼Œæ¯”å¦‚ä¸€ä¸ªå¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼š

```cpp
#include <iostream>
#include <compare>
#include <string>

using namespace std;

int ci_compare(const char* s1, const char* s2)
{
    while(tolower(*s1) == tolower(*s2++))
    {
        if(*s1++ == '\0')
        {
            return 0;
        }
    }
    return tolower(*s1) - tolower(*--s2);
}

class CIString
{
public:
    CIString(const char*s) : str_(s){}
    std::weak_ordering operator<=>(const CIString& b) const
    {
        return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
    }
private:
    std::string str_;
};

int main()
{
    CIString s1{"HELLO"}, s2{"hello"};
    std::cout << (s1 <=> s2 == 0) << std::endl;
    // 1
    return 0;
}
```

ä»¥ä¸Šä»£ç å®ç°äº†ä¸€ä¸ªç®€å•çš„å¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼Œå®ƒå¯¹äºs1å’Œs2çš„æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering::equivalent`ï¼Œè¡¨ç¤ºä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç­‰ä»·çš„ã€‚ä½†æ˜¯å®ƒä»¬ä¸æ˜¯ç›¸ç­‰çš„ä¹Ÿä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚å½“`std::weak_ordering`å’Œ`std::strong_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
```

ç”¨MSVCç¼–è¯‘è¿è¡Œä¸Šé¢è¿™æ®µä»£ç ä¼šè¾“å‡º`class std::weak_ordering`ï¼Œå› ä¸ºDä¸­çš„æ•°æ®æˆå‘˜CIStringçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¸º`std::weak_ordering`ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœæ˜¾å¼å£°æ˜é»˜è®¤ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¸º`std::strong_ordering operator <=> (const D&) const = default;`é‚£ä¹ˆä¸€å®šä¼šé­é‡åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚

### std::partial_ordering

```cpp
std::partial_ordering
    - std::partial_ordering::less
    - std::partial_ordering::equivalent
    - std::partial_ ordering::greater
    - std::partial_ordering::unordered
```

`std::partial_ordering`çº¦æŸåŠ›æ¯”`std::weak_ordering`æ›´å¼±ï¼Œå®ƒå¯ä»¥æ¥å—å½“`lhs == rhs`æ—¶rhså’Œlhsä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚
åŒæ—¶å®ƒè¿˜èƒ½ç»™å‡ºç¬¬å››ä¸ªç»“æœ`std::partial_ordering::unordered`ï¼Œè¡¨ç¤ºè¿›è¡Œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°æ²¡æœ‰å…³ç³»ã€‚æ¯”å¦‚åŸºç¡€ç±»å‹ä¸­çš„æµ®ç‚¹æ•°ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << typeid(decltype(7.7 <=> 11.1)).name();
    // St16partial_ordering
    return 0;
}
```

ä¼šè¾“å‡º`class std::partial_ordering`è€Œä¸æ˜¯`std::strong_ordering`ï¼Œæ˜¯å› ä¸ºæµ®ç‚¹çš„é›†åˆä¸­å­˜åœ¨ä¸€ä¸ªç‰¹æ®Šçš„NaNï¼Œå®ƒå’Œå…¶ä»–æµ®ç‚¹æ•°å€¼æ˜¯æ²¡å…³ç³»çš„ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << ((0.0 / 0.0 <=> 1.0) == std::partial_ordering::unordered);
    // 1
    return 0;
}
```

å½“`std::weak_ordering`å’Œ`std::partial_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::partial_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  float u;
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
// class std::partial_ordering
```

å†æ¬¡å¼ºè°ƒä¸€ä¸‹ï¼Œ`std::strong_ordering`ã€`std::weak_ordering`å’Œ`std::partial_ordering`åªèƒ½ä¸0å’Œç±»å‹è‡ªèº«æ¯”è¾ƒã€‚æ·±ç©¶å…¶åŸå› ï¼Œæ˜¯è¿™3ä¸ªç±»åªå®ç°äº†å‚æ•°ç±»å‹ä¸ºè‡ªèº«ç±»å‹å’Œ`nullptr_t`çš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚

### std::variant

`std::variant`æ˜¯ C++17 å¼•å…¥çš„æ ‡å‡†åº“æ¨¡æ¿ï¼ˆä½¿ç”¨å‰è¯·ç¡®ä¿ä½ çš„ç¼–è¯‘å™¨æ”¯æŒ C++ 17ï¼‰ï¼Œå®ƒæä¾›äº†ä¸€ç§ç±»å‹å®‰å…¨çš„å˜ä½“ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ã€‚ `std::variant`è¡¨ç¤ºä¸€ä¸ªç±»å‹å®‰å…¨çš„è”åˆä½“ï¼Œå³å¯ä»¥åœ¨ä¸€ä¸ªå˜é‡ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ï¼Œè€Œä¸”ä¸€æ¬¡åªèƒ½å­˜å‚¨å®ƒå…¶ä¸­ä¸€ä¸ªå¯èƒ½çš„ç±»å‹çš„å€¼ã€‚ `std::variant`çš„ä¸»è¦ä¼˜ç‚¹æ˜¯æä¾›äº†ç±»å‹å®‰å…¨å’Œçµæ´»æ€§ã€‚å®ƒå¯ä»¥ç”¨äºå¤„ç†å…·æœ‰å¤šç§å¯èƒ½ç±»å‹çš„æ•°æ®ï¼Œä¾‹å¦‚åœ¨å‡½æ•°å‚æ•°ä¸­ä¼ é€’ä¸åŒç±»å‹çš„å‚æ•°ï¼Œæˆ–è€…åœ¨å¤„ç†å¼‚è´¨é›†åˆæ—¶å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ã€‚ ä»¥ä¸‹æ˜¯ä½¿ç”¨`std::variant`çš„ä¸€äº›ç¤ºä¾‹ä»£ç ï¼š

```cpp
#include <iostream>
#include <variant>
using namespace std;

void processVariant(const std::variant<int, double, std::string>& v)
{
    std::visit([](auto &value){
        std::cout << "Value: " << value << std::endl;
    }, v);
}

int main()
{
    std::variant<int, double, std::string> v = 42;
    processVariant(v);
    v = 3.14;
    processVariant(v);
    v = "Hello, world";
    processVariant(v);
    std::cout << typeid(std::get<0>(v)).name() << std::endl;
    // i
    std::cout << typeid(std::get<1>(v)).name() << std::endl;
    // d
    std::cout << typeid(std::get<2>(v)).name() << std::endl;
    // NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
    return 0;
}
/*
Value: 42
Value: 3.14
Value: Hello, world
*/
// https://en.cppreference.com/w/cpp/utility/variant
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`std::variant`åœ¨å­˜å‚¨ç±»å‹æ—¶ä½¿ç”¨äº†åŠ¨æ€å¤šæ€æ€§ï¼ˆå³è¿è¡Œæ—¶å¤šæ€ï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå­˜å‚¨çš„å…·ä½“ç±»å‹ï¼Œè€Œæ˜¯åœ¨è¿è¡Œæ—¶æ ¹æ®å®é™…èµ‹å€¼æ¥ç¡®å®šã€‚ è¿™ä¹Ÿæ„å‘³ç€åœ¨ä½¿ç”¨`std::variant`æ—¶ï¼Œéœ€è¦è°¨æ…å¤„ç†ç±»å‹è½¬æ¢å’Œæ“ä½œï¼Œä»¥ç¡®ä¿ç±»å‹å®‰å…¨ã€‚

### std::common_comparison_category

åœ¨C++20çš„æ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ªæ¨¡æ¿å…ƒå‡½æ•° `std::common_comparison_category` ï¼Œå®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬åœ¨ä¸€ä¸ªç±»å‹åˆé›†ä¸­åˆ¤æ–­å‡ºæœ€ç»ˆä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ï¼Œå½“ç±»å‹åˆé›†ä¸­å­˜åœ¨ä¸æ”¯æŒä¸‰å‘æ¯”è¾ƒçš„ç±»å‹æ—¶ï¼Œè¯¥æ¨¡æ¿å…ƒå‡½æ•°è¿”å›voidã€‚

```cpp
https://en.cppreference.com/w/cpp/utility/compare/common_comparison_category
```

### å¯¹åŸºç¡€ç±»å‹çš„æ”¯æŒ

1. å¯¹ä¸¤ä¸ªç®—æœ¯ç±»å‹çš„æ“ä½œæ•°è¿›è¡Œä¸€èˆ¬ç®—æœ¯è½¬æ¢ï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒã€‚å…¶ä¸­æ•´å‹çš„æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ï¼Œæµ®ç‚¹å‹çš„æ¯”è¾ƒç»“æœä¸º`std::partial_ordering`ã€‚ä¾‹å¦‚`7 <=> 11.1`ä¸­ï¼Œæ•´å‹7ä¼šè½¬æ¢ä¸ºæµ®ç‚¹ç±»å‹ï¼Œç„¶åå†è¿›è¡Œæ¯”è¾ƒï¼Œæœ€ç»ˆç»“æœä¸º`std::partial_ordering`ç±»å‹ã€‚
2. å¯¹äºæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹å’Œæ•´å‹æ“ä½œæ•°ï¼Œæšä¸¾ç±»å‹ä¼šè½¬æ¢ä¸ºæ•´å‹å†è¿›è¡Œæ¯”è¾ƒï¼Œæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹æ— æ³•ä¸æµ®ç‚¹ç±»å‹æ¯”è¾ƒã€‚

```cpp
enum color {
  red
};

auto r = red <=> 11;   //ç¼–è¯‘æˆåŠŸ
auto r = red <=> 11.1; //ç¼–è¯‘å¤±è´¥
```

3. å¯¹ä¸¤ä¸ªç›¸åŒæšä¸¾ç±»å‹çš„æ“ä½œæ•°æ¯”è¾ƒç»“æœï¼Œå¦‚æœæšä¸¾ç±»å‹ä¸åŒï¼Œåˆ™æ— æ³•ç¼–è¯‘ã€‚
4. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºboolç±»å‹çš„æƒ…å†µï¼Œå¦ä¸€ä¸ªæ“ä½œæ•°å¿…é¡»ä¹Ÿæ˜¯boolç±»å‹ï¼Œå¦åˆ™æ— æ³•ç¼–è¯‘ã€‚æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚
5. ä¸æ”¯æŒä½œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°ä¸ºæ•°ç»„çš„æƒ…å†µï¼Œä¼šå¯¼è‡´ç¼–è¯‘å‡ºé”™ï¼Œä¾‹å¦‚ï¼š

```cpp
int arr1[5];
int arr2[5];
auto r = arr1 <=> arr2; // ç¼–è¯‘å¤±è´¥
```

6. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºæŒ‡é’ˆç±»å‹çš„æƒ…å†µï¼Œéœ€è¦å¦ä¸€ä¸ªæ“ä½œæ•°æ˜¯åŒæ ·ç±»å‹çš„æŒ‡é’ˆï¼Œæˆ–è€…æ˜¯å¯ä»¥è½¬æ¢ä¸ºç›¸åŒç±»å‹çš„æŒ‡é’ˆï¼Œæ¯”å¦‚æ•°ç»„åˆ°æŒ‡é’ˆçš„è½¬æ¢ã€æ´¾ç”Ÿç±»æŒ‡é’ˆåˆ°åŸºç±»æŒ‡é’ˆçš„è½¬æ¢ç­‰ï¼Œæœ€ç»ˆæ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚

```cpp
char arr1[5];
char arr2[5];
char* ptr = arr2;
auto r = ptr <=> arr1;
// ä¸Šé¢çš„ä»£ç å¯ä»¥ç¼–è¯‘æˆåŠŸï¼Œè‹¥å°†ä»£ç ä¸­çš„arr1æ”¹å†™ä¸ºint arr1[5]ï¼Œåˆ™æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºint [5]æ— æ³•è½¬æ¢ä¸ºchar *ã€‚å¦‚æœå°†char * ptr = arr2;ä¿®æ”¹ä¸ºvoid * ptr = arr2;ï¼Œå°±å¯ä»¥ç¼–è¯‘æˆåŠŸäº†ã€‚
```

### è‡ªåŠ¨ç”Ÿæˆçš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°

æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªåä¸º`std::rel_ops`çš„å‘½åç©ºé—´ï¼Œåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹å·²ç»æä¾›äº†`==`è¿ç®—ç¬¦å‡½æ•°å’Œ<è¿ç®—ç¬¦å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå¸®åŠ©ç”¨æˆ·å®ç°å…¶ä»–4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œ åŒ…æ‹¬`!=ã€>ã€<=å’Œ>=`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <string>
#include <utility>
class CIString2 {
public:
  CIString2(const char* s) : str_(s) {}

  bool operator < (const CIString2& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) < 0;
  }
private:
  std::string str_;
};

using namespace std::rel_ops;
CIString2 s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

ä¸è¿‡å› ä¸ºC++20æ ‡å‡†æœ‰äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„å…³ç³»ï¼Œæ‰€ä»¥ä¸æ¨èä¸Šé¢è¿™ç§åšæ³•äº†ã€‚C++20æ ‡å‡†è§„å®šï¼Œå¦‚æœç”¨æˆ·ä¸ºè‡ªå®šä¹‰ç±»å‹å£°æ˜äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šä¸ºå…¶è‡ªåŠ¨ç”Ÿæˆ`<ã€>ã€<=å’Œ>=`è¿™4ç§è¿ç®—ç¬¦å‡½æ•°ã€‚å¯¹äºCIStringæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™4ç§è¿ç®—ç¬¦å‡½æ•°:

```cpp
CIString s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

é‚£ä¹ˆè¿™é‡Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªç–‘é—®ï¼Œå¾ˆæ˜æ˜¾ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦èƒ½è¡¨è¾¾ä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç›¸ç­‰æˆ–è€…ç­‰ä»·çš„å«ä¹‰ï¼Œä¸ºä»€ä¹ˆæ ‡å‡†åªå…è®¸è‡ªåŠ¨ç”Ÿæˆ4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œå´ä¸èƒ½è‡ªåŠ¨ç”Ÿæˆ`==å’Œ=!`è¿™ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå®é™…ä¸Šè¿™é‡Œå­˜åœ¨ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚åœ¨C++20æ ‡å‡†æ‹Ÿå®šä¸‰å‘æ¯”è¾ƒçš„æ—©æœŸï¼Œæ˜¯å…è®¸é€šè¿‡ä¸‰å‘æ¯”è¾ƒè‡ªåŠ¨ç”Ÿæˆ6ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œè€Œä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ä¹Ÿä¸æ˜¯3ç§è€Œæ˜¯5ç§ï¼Œå¤šå‡ºæ¥çš„ä¸¤ç§åˆ†åˆ«æ˜¯`std::strong_equality`å’Œ`std::weak_equality`ã€‚ä½†æ˜¯åœ¨ææ¡ˆæ–‡æ¡£p1190ä¸­æå‡ºäº†ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚ç®€å•æ¥è¯´ï¼Œå‡è®¾æœ‰ä¸€ä¸ªç»“æ„ä½“ï¼š

```cpp
struct S {
    std::vector<std::string> names;
    auto operator<=>(const S &) const = default;
};
```

å®ƒçš„ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„é»˜è®¤å®ç°è¿™æ ·çš„ï¼š

```cpp
template<typename T>
std::strong_ordering operator<=>(const std::vector<T>& lhs, const std::vector<T> & rhs)
{
    size_t min_size = min(lhs.size(), rhs.size());
    for (size_t i = 0; i != min_size; ++i) {
        if (auto const cmp = std::compare_3way(lhs[i], rhs[i]); cmp != 0) {
            return cmp;
        }
    }
    return lhs.size() <=> rhs.size();
}
```

è¿™ä¸ªå®ç°å¯¹äº`<å’Œ>`è¿™æ ·çš„è¿ç®—ç¬¦å‡½æ•°æ²¡æœ‰é—®é¢˜ï¼Œå› ä¸ºéœ€è¦æ¯”è¾ƒå®¹å™¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä½†æ˜¯`==`è¿ç®—ç¬¦å°±æ˜¾å¾—ååˆ†ä½æ•ˆï¼Œå¯¹äº`==`è¿ç®—ç¬¦é«˜æ•ˆçš„åšæ³•æ˜¯å…ˆæ¯”è¾ƒå®¹å™¨ä¸­çš„å…ƒç´ æ•°é‡æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœå…ƒç´ æ•°é‡ä¸åŒï¼Œåˆ™ç›´æ¥è¿”å›falseï¼š

```cpp
template<typename T>
bool operator==(const std::vector<T>& lhs, const std::vector<T>& rhs)
{
    const size_t size = lhs.size();
    if (size != rhs.size()) {
        return false;
    }

    for (size_t i = 0; i != size; ++i) {
        if (lhs[i] != rhs[i]) {
            return false;
        }
    }
    return true;
}
```

æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæ ‡å‡†å…è®¸ç”¨ä¸‰å‘æ¯”è¾ƒçš„ç®—æ³•è‡ªåŠ¨ç”Ÿæˆ`==`è¿ç®—ç¬¦å‡½æ•°ä¼šå‘ç”Ÿä»€ä¹ˆäº‹æƒ…ï¼Œ å¾ˆå¤šæ—§ä»£ç å‡çº§ç¼–è¯‘ç¯å¢ƒåä¼šå‘ç°è¿è¡Œæ•ˆç‡ä¸‹é™äº†ï¼Œå°¤å…¶æ˜¯åœ¨å®¹å™¨ä¸­å…ƒç´ æ•°é‡ä¼—å¤šä¸”æ¯ä¸ªå…ƒç´ æ•°æ®é‡åºå¤§çš„æƒ…å†µä¸‹ã€‚ å¾ˆå°‘æœ‰ç¨‹åºå‘˜ä¼šæ³¨æ„åˆ°ä¸‰å‘æ¯”è¾ƒç®—æ³•çš„ç»†èŠ‚ï¼Œå¯¼è‡´è¿™ä¸ªæ€§èƒ½é—®é¢˜éš¾ä»¥æ’æŸ¥ã€‚åŸºäºè¿™ç§è€ƒè™‘ï¼ŒC++å§”å‘˜ä¼šä¿®æ”¹äº†åŸæ¥çš„ä¸‰å‘æ¯”è¾ƒææ¡ˆï¼Œ è§„å®šå£°æ˜ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°åªèƒ½å¤Ÿè‡ªåŠ¨ç”Ÿæˆ4ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚ç”±äºä¸éœ€è¦è´Ÿè´£åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œ å› æ­¤`std::strong_equality`å’Œ`std::weak_equality`ä¹Ÿé€€å‡ºäº†å†å²èˆå°ã€‚å¯¹äº`==å’Œ!=`ä¸¤ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œ åªéœ€è¦å¤šå£°æ˜ä¸€ä¸ª`==`è¿ç®—ç¬¦å‡½æ•°ï¼Œ`!=`è¿ç®—ç¬¦å‡½æ•°ä¼šæ ¹æ®å‰è€…è‡ªåŠ¨ç”Ÿæˆï¼š

```cpp
class CIString {
public:
  CIString(const char* s) : str_(s) {}

  std::weak_ordering operator<=>(const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
  }

  bool operator == (const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) == 0;
  }
private:

  std::string str_;
};

CIString s1{ "hello" }, s2{ "world" };
bool r1 = s1 >= s2; // è°ƒç”¨operator<=>
bool r2 = s1 == s2; // è°ƒç”¨operator ==
```

### å…¼å®¹æ—§ä»£ç 

ç°åœ¨C++20æ ‡å‡†å·²ç»æ¨èä½¿ç”¨`<=>å’Œ==`è¿ç®—ç¬¦è‡ªåŠ¨ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œè€Œä½¿ç”¨`<ã€==ä»¥åŠstd::rel_ops`ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¼šå› ä¸º`std::rel_ops`å·²ç»ä¸è¢«æ¨èä½¿ç”¨è€Œè¢«ç¼–è¯‘å™¨è­¦å‘Šã€‚åˆ™é‚£ä¹ˆå¯¹äºè€ä»£ç ï¼Œæˆ‘ä»¬æ˜¯å¦éœ€è¦å»å®ç°ä¸€å¥—`<=>å’Œ==`è¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå…¶å®å¤§å¯ä¸å¿…ï¼ŒC++å§”å‘˜ä¼šåœ¨è£å†³è¿™é¡¹ä¿®æ”¹çš„æ—¶å€™å·²ç»è€ƒè™‘åˆ°è€ä»£ç çš„ç»´æŠ¤æˆæœ¬ï¼Œæ‰€ä»¥åšäº†å…¼å®¹æ€§å¤„ç†ï¼Œå³åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ä¸­ï¼Œå®ç°äº†`<ã€==`è¿ç®—ç¬¦å‡½æ•°çš„æ•°æ®æˆå‘˜ç±»å‹ï¼Œåœ¨è¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒä¸­å°†è‡ªåŠ¨ç”Ÿæˆåˆé€‚çš„æ¯”è¾ƒä»£ç ã€‚æ¯”å¦‚ï¼š

```cpp
struct Legacy {
  int n;
  bool operator==(const Legacy& rhs) const
  {
       return n == rhs.n;
  }
  bool operator<(const Legacy& rhs) const
  {
       return n < rhs.n;
  }
};

struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay &) const = default;
};

TreeWay t1, t2;
bool r = t1 < t2;
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œç»“æ„ä½“TreeWayçš„ä¸‰å‘æ¯”è¾ƒæ“ä½œä¼šè°ƒç”¨ç»“æ„ä½“Legacyä¸­çš„`<å’Œ==`è¿ç®—ç¬¦æ¥å®Œæˆï¼Œå…¶ä»£ç ç±»ä¼¼äºï¼š

```cpp
struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay& rhs) const {
       if (m < rhs.m) return std::strong_ordering::less;
       if (m == rhs.m) return std::strong_ordering::equal;
       return std::strong_ordering::greater;
  }
};
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œ`operator<=>`å¿…é¡»æ˜¾å¼å£°æ˜è¿”å›ç±»å‹ä¸º`std::strong_ordering`ï¼Œä½¿ç”¨autoæ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘çš„ã€‚

### ä¸‰å‘æ¯”è¾ƒæ€»ç»“

C++20æ–°å¢çš„ä¸‰å‘æ¯”è¾ƒç‰¹æ€§ï¼Œè¯¥ç‰¹æ€§çš„å¼•å…¥ä¸ºå®ç°æ¯”è¾ƒè¿ç®—æä¾›äº†æ–¹ä¾¿ã€‚ æˆ‘ä»¬åªéœ€è¦å®ç°`==å’Œ<=>`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œå‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°å°±å¯ä»¥äº¤ç»™ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆäº†ã€‚ è™½è¯´`std::rel_ops`åœ¨å®ç°äº†`==å’Œ<`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ä»¥åä¹Ÿèƒ½è‡ªåŠ¨æä¾›å‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œ ä½†æ˜¾ç„¶ç”¨ä¸‰å‘æ¯”è¾ƒæ›´åŠ ä¾¿æ·ã€‚å¦å¤–ï¼Œä¸‰å‘æ¯”è¾ƒæä¾›çš„3ç§ç»“æœç±»å‹ä¹Ÿæ˜¯`std::rel_ops`æ— æ³•åª²ç¾çš„ã€‚ è¿›ä¸€æ­¥æ¥è¯´ï¼Œç”±äºä¸‰å‘æ¯”è¾ƒçš„å‡ºç°ï¼Œ`std::rel_ops`åœ¨C++20ä¸­å·²ç»ä¸è¢«æ¨èä½¿ç”¨äº†ã€‚ æœ€åï¼ŒC++å§”å‘˜ä¼šæ²¡æœ‰å¿˜è®°å…¼å®¹æ€§é—®é¢˜ï¼Œè¿™è®©ä¸‰å‘æ¯”è¾ƒèƒ½å¤Ÿé€šè¿‡è¿ç®—ç¬¦å‡½æ•°`<å’Œ==`æ¥è‡ªåŠ¨ç”Ÿæˆã€‚

## åç¨‹

éå¸¸niceçš„è®²è§£ <https://www.bilibili.com/video/BV1c8411f7dw>

### ä»€ä¹ˆæ˜¯åç¨‹

å…ˆå­¦ä¼šä½¿ç”¨ï¼Œç„¶ååœ¨å­¦ä¹ èƒŒåçš„å®ç°åŸç†ã€‚ç”±æµ…åˆ°æ·±æ‰æ˜¯å­¦ä¹ çš„æ­£ç¡®å§¿åŠ¿ã€‚

åç¨‹ï¼šæ˜¯ä¸€ç§å¯ä»¥è¢«æŒ‚èµ·å’Œå›å¤çš„å‡½æ•°ã€‚

ç”µè„‘æœ¬æœºæ²¡æœ‰ç¯å¢ƒå¯ä»¥ä½¿ç”¨ è½»æ¾ä½¿ç”¨C++2aç¯å¢ƒ:<https://godbolt.org/>

### å‡½æ•°è°ƒç”¨VSåç¨‹

![å‡½æ•°è°ƒç”¨VSåç¨‹](../.gitbook/assets/2024-03-27232828.png)

å‡½æ•°çš„è°ƒç”¨æ˜¯è°ƒç”¨çš„å‡½æ•°è¿›è¡Œreturnï¼Œç„¶åè¿”å›å›æ¥ï¼Œç»§ç»­æ‰§è¡Œï¼Œä¸”è°ƒç”¨çš„å‡½æ•°å·²ç»æ‰§è¡Œå®Œäº†ï¼Œä¸ä¼šä¸­æ–­ã€‚

è€Œåç¨‹æ˜¯å¯ä»¥æ‰§è¡Œåˆ°æŸå¤„co_yieldæˆ–co_awaitæ—¶ï¼Œç„¶åè·³è½¬åˆ°æŸä¸ªåœ°æ–¹(åç¨‹è¢«æŒ‚èµ·æ—¶ä¸æ˜¯å¿…é¡»å›åˆ°è¢«è°ƒç”¨çš„åœ°æ–¹ï¼Œå®Œå…¨å¯ä»¥æŒ‡å®šå…¶ä»–åç¨‹ï¼Œè¿™å°±æ˜¯åç¨‹è°ƒåº¦çš„å†…å®¹äº†)ï¼Œå½“åç¨‹è¢«æ‰§è¡Œresumeæ—¶ç»§ç»­æ‰§è¡Œåç¨‹
å½“co_returnæ—¶åç¨‹å°†ç»“æŸã€‚

### ç®€å•å®ä¾‹

ç®€å•è®¤è¯†

- åç¨‹è¿”å›å€¼ç±»å‹ä¸promise_typeã€initial_suspendã€final_suspendã€unhandled_exceptionã€get_return_objectã€yield_valueã€return_voidã€return_value
- std::coroutine_handleã€doneã€()ã€resumeã€from_promise
- co_awaitã€co_yieldã€co_return
- awaitableã€await_readyã€await_suspendã€await_resume

```CMake
project(main)

add_compile_options(-Wall)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -Wall -O0")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -std=c++2a -Wall -O0")

add_executable(main.exe main.cpp)
# target_link_libraries(main.exe)
```

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        int _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never initial_suspend()
        {
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            std::cout << "final_suspend" << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always yield_value(int r)
        {
            _out = r;
            return {};
        }

        void return_void() // å³co_return ;
        {
        }

        // void return_value(std::string str) // å³co_return str;
        // {
        // }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h();
    // ret._h.resume(); ä¸ ret._h() ç­‰ä»·
    std::cout << "over" << std::endl;
    return 0;
}

// co_yieldç­‰ä»·äº co_await promise.yield_value(expr)
// åç¨‹å¦‚æœè°ƒç”¨äº†co_return åˆ™ ret._h.done()å°†ä¼šè¿”å›çœŸ

// CoFunction() next line
// coroutine message=hello
// final_suspend
// over
```

### std::suspend_neverçš„å®ç°

std::suspend_neveræ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_never
{
  constexpr bool await_ready() const noexcept { return true; } // ä¸æŒ‚èµ·co_waitç›´æ¥æ— æ•ˆç»§ç»­æ‰§è¡Œco_waitåé¢çš„ä»£ç 
  constexpr void await_suspend(coroutine_handle<>) const noexcept {}
  constexpr void await_resume() const noexcept {}
};
```

### std::suspend_alwaysçš„å®ç°

std::suspend_alwaysä¹Ÿæ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_always
{
  constexpr bool await_ready() const noexcept { return false; } // co_waitæ—¶ç›´æ¥æŒ‚èµ·ç„¶åè§¦å‘await_suspend ç„¶åç­‰å¾…resumeå†å›æ¥
  constexpr void await_suspend(coroutine_handle<>) const noexcept {} 
  constexpr void await_resume() const noexcept {}
};
```

### è¿›ä¸€æ­¥ç†Ÿæ‚‰æµç¨‹

è¿™é‡Œå¯ä»¥è¿›ä¸€æ­¥äº†è§£final_suspendçš„è¿”å›å€¼

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_always initial_suspend()
        {
            std::cout << "initial_suspend" << std::endl;
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            // final_suspendè¿”å›å€¼å†³å®šäº†åç¨‹ä¼šä¸ä¼šè¢«destory å½“è¿”å›std::suspend_neveræ—¶final_suspendæ‰§è¡Œååç¨‹handleè¢«destory åœ¨è°ƒç”¨handle.done()è¿”å›0
            // å½“è¿”å›std::suspend_alwaysä¹Ÿå°±æ˜¯åç¨‹æœ€åæœ‰è¢«æŒ‚èµ·ï¼Œé‚£ä¹ˆhandle.done()ä¼šè¿”å›çœŸï¼Œè€Œä¸”å¦‚æœè¿”å›std::suspend_alwaysæˆ‘ä»¬æ˜¯éœ€è¦åœ¨å®ƒå¤„æ˜¾ç¤ºhandle.destory()
            std::cout << std::coroutine_handle<promise_type>::from_promise(*this).done() << std::endl;
            std::cout << "final_suspend" << std::endl;
            std::cout << "co_return " << _out << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void() // å³co_return ;
        // {
        // }

        void return_value(std::string_view str) // å³co_return str; å¯ä»¥å°†å†…å®¹é€šè¿‡co_returnå­˜åˆ°promiseä¸­
        {
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return "888888"; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    std::cout << "start main" << std::endl;
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h(); // å›åˆ° co_await promise.initial_suspend()
    // ä»co_await Awaitable()è·³è¿‡æ¥äº†
    std::cout << "=>" << ret._h.done() << std::endl; // 0

    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h.resume();                         // å›åˆ°co_await Awaitable();
    std::cout << "over" << std::endl;
    std::cout << ret._h.done() << std::endl; // 0
    std::cout << ret._h.promise()._out << std::endl; // 888888
    // åç¨‹ç»“æŸåä¸èƒ½åœ¨è¢«resumeäº†

    return 0;
}
// ret._h.destory()å¯ä»¥æå‰é”€æ¯åç¨‹handle

// start main
// initial_suspend
// CoFunction() next line
// =>0
// coroutine message=hello
// 1
// final_suspend
// co_return 888888
// over
// 0
// 888888
```

### ç®€å•ç†è§£åç¨‹è°ƒåº¦

ä»è¿™ä¸ªä¾‹å­ä¸­å…¶å®å¯ä»¥çœ‹ å…¶å®åç¨‹å¯ä»¥çœ‹æˆä»»åŠ¡çŠ¶æ€æœºï¼Œé€šè¿‡promiseä¸coroutine_handleä¸å¤–ç•Œäº¤äº’
åªä¸è¿‡æœ€å¤§ä¼˜åŠ¿å°±æ˜¯ å¯ä»¥è‡ªåŠ¨ç»´æŒä¸Šä¸‹æ–‡ï¼ŒçŠ¶æ€æœºæŒ‚èµ·çš„æ—¶å€™ï¼Œå¯ä»¥è‡ªåŠ¨å›åˆ°è§¦å‘çŠ¶æ€æœºçš„åœ°æ–¹å³è°ƒç”¨resume()çš„åœ°æ–¹ã€‚

è¿™ä¹ˆä¸€æ¥åƒåšæœåŠ¡å™¨çš„æœ‰ä»€ä¹ˆæ‰“çš„ä¼˜åŠ¿ï¼Œå…¶å®å°±æ˜¯epoll+åç¨‹+éé˜»å¡IOï¼Œè€Œä¸”å¯ä»¥åšåˆ°å•çº¿ç¨‹å¹¶å‘
ä¾‹å¦‚epoll æ¥äº†æ–°è¿æ¥ åˆ™ä¸ºæ–°è¿æ¥åˆ›å»ºåç¨‹ï¼Œepollç›‘å¬è¿æ¥å¥—æ¥å­—å¯è¯»æ—¶ å¯ä»¥å‘promiseä¸­æ ‡è®° ä½ å¯ä»¥è¯»äº† æˆ–è€… å¯ä»¥å†™äº†ã€‚ç„¶åè¿›è¡Œresume() æ¯ä¸ªåç¨‹å†…éƒ¨å…¶å®å°±æ˜¯æ­»å¾ªç¯ read process writeä¹‹ç±»çš„ç›¸å…³æ“ä½œï¼Œè¦æš‚æ—¶ä¸å¤„ç†äº†æ¯”å¦‚EAGAINäº†ï¼Œå®Œå…¨å¯ä»¥co_waitå‡ºå»å›åˆ°åŸæ¥è¦æ‰§è¡Œçš„åœ°æ–¹ï¼Œå¯èƒ½ä¼šå¤„ç†ä¸‹ä¸€ä¸ªåç¨‹ï¼Œè¿™ä¹ˆä¸€æ¥å¯ä»¥å‘ç° C++åç¨‹æ›´åƒæ˜¯ä¸€ç§çŠ¶æ€æœºçš„è¯­æ³•ç³–ä¸€æ ·çš„æ„Ÿè§‰ï¼Œè€Œä¸”å¾ˆå®¹æ˜“å›´ç»•éé˜»å¡IOå»åš
ä¸€äº›å¼‚æ­¥ä»»åŠ¡ï¼Œè€Œä¸”å®Œå…¨å¯ä»¥å•çº¿ç¨‹ï¼Œå®‰å…¨å¥½ç”¨ç®€å•ï¼Œåœ¨å¿…è¦çš„æ—¶å€™è¿›è¡Œresumeè§¦å‘æ‰§è¡Œï¼Œåç¨‹ä¹Ÿæœ‰è‡ªçŸ¥ä¹‹æ˜ è‡ªå·±ä¼šco_wait co_yield co_returnä¸ä¼šè¿›è¡Œé˜»å¡ ä¸æ˜¯åœ¨è¿è¡Œå°±æ˜¯åœ¨æŒ‚èµ·ç­‰å¾…è¢«resume è¿™æ‰æ˜¯å…³é”®ä¸ç²¾é«“ã€‚

```cpp

#include <coroutine>
#include <future>
#include <thread>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>


using namespace std;

struct CoRet
{
    struct promise_type
    {
        int _in;
        int _out;
        int _res;
        suspend_never initial_suspend() {return {};}
        suspend_always final_suspend() noexcept {return {};}
        void unhandled_exception() {}
        CoRet get_return_object()
        { return 
            {coroutine_handle<promise_type>::from_promise(*this)};
        }
        suspend_always yield_value(int r) {
            _out = r;
            return {};
        }
        void return_value(int r) {
            _res = r;
        }
    };

    coroutine_handle<promise_type> _h; // _h.resume(), _h()
};

struct Input
{
    int* _in;
    int* _out;
    bool await_ready() { return false; }
    void await_suspend(coroutine_handle<CoRet::promise_type> h) 
    { _in = &h.promise()._in; _out = &h.promise()._out; }
    int await_resume() { return *_in; }
};

// åç¨‹
CoRet Guess() {
    // co_await promise.initial_suspend();
    int res = (rand()%30)+1;
    Input input;
    int numGuess = 0;
    while(true)
    {
        int g = co_await input;
        
        ++numGuess;
        (*input._out) = (res>g ? 1: (res == g? 0 : -1));
        if((*input._out) == 0) co_return numGuess;
    }    
    // co_await promise.final_suspend();...
}



struct Hasher
{
    size_t operator() (const pair<int, int>& p) const
    {
        return (size_t)(p.first << 8) + (size_t)(p.second); 
    }
};
int main()
{
    srand(time(nullptr));

    unordered_map<pair<int, int>, vector<CoRet>, Hasher> buckets;
    for(auto i = 0; i<100; ++i) buckets[make_pair(1, 30)].push_back(Guess());

    while(!buckets.empty())
    {
        auto it = buckets.begin();
        auto& range = it->first;//1
        auto& handles = it->second;//vector<CoRet>å­˜æ”¾åç¨‹
                
        int g = (range.first+range.second)/2;//ä¸­é—´æ•°
        auto ur = make_pair(g+1, range.second);//å³è¾¹éƒ¨åˆ†
        auto lr = make_pair(range.first, g-1);//å·¦è¾¹éƒ¨åˆ†

        vector<future<int>> cmp;
        cmp.reserve(handles.size());

        // è¿™ä¸ªå¾ªç¯æ˜¯éé˜»å¡çš„éå¸¸å¿«
        for(auto& coret : handles)
        {
            // ä¸ºæ¯ä¸ªä»»åŠ¡å»å¼€çº¿ç¨‹ å»æ‰§è¡Œåç¨‹
            cmp.push_back(async(launch::async, [&coret, g]() { // åˆ¤æ–­ä¸­é—´æ•°
                coret._h.promise()._in = g;
                coret._h.resume(); // åç¨‹å†…éƒ¨é‡è§co_wait co_yieldä¼šè¿”å›æ¥               
                return coret._h.promise()._out;
            }));
            // è·å¾—è®¸å¤šfuture å³lamdaè¿”å›å€¼å‘æ¡ä»¶å˜é‡ä¸€æ ·
        }

        // éå†æ‰€æœ‰åç¨‹ï¼Œå‰é¢å·²ç»è®©åç¨‹å»å¼‚æ­¥è¿è¡Œäº†
        for(int i=0; i< handles.size(); ++i)
        {
            int r = cmp[i].get(); // ç­‰å¾…futureè¿”å›å€¼è¿™é‡Œæ˜¯é˜»å¡çš„ åªæœ‰ç›¸åº”åç¨‹è¢«resume lamdaè¿”å›æ‰å¯ä»¥get()è¿”å›
            
            if(r == 0) {//çŒœå¯¹äº†
                cout << "The secret number is " << handles[i]._h.promise()._in
                << ", total # guesses is " << handles[i]._h.promise()._res
                << endl;
            }            
            else if (r == 1) buckets[ur].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å³è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
            else buckets[lr].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å·¦è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
        }
        buckets.erase(it);//åˆ é™¤åŸæ¥èŒƒå›´çš„ï¼ŒçŒœä¸­äº†çš„ä¸ç”¨å†çŒœåç¨‹ä¸­çš„æ•°å­—äº†ï¼Œå‰©ä½™åç¨‹ä¸æ˜¯å»å·¦è¾¹å°±æ˜¯å³è¾¹
    }

/*
    auto ret = Guess();
    pair<int, int> range = {1,30};    
    int in, out;
    do
    {
        in = (range.first+range.second)/2;
        ret._h.promise()._in = in; 
        cout << "main: make a guess: " << ret._h.promise()._in << endl;

        ret._h.resume(); // resume from co_await

        out = ret._h.promise()._out;
        cout << "main: result is " << 
        ((out == 1) ? "larger" :
        ((out == 0) ? "the same" : "smaller"))
            << endl;
        if(out == 1) range.first = in+1;
        else if(out == -1) range.second = in-1;
    }
    while(out != 0);
*/
}
```

### ä¸åŒçº¿ç¨‹resumeåŒä¸€ä¸ªåç¨‹

ä¸€ä¸ªçº¿ç¨‹ç¨‹å°†ä¸€ä¸ªåç¨‹è¿è¡Œåˆ°æŸä¸ªä½ç½® ç„¶ååç¨‹æŒ‚èµ·äº†ã€‚
å®Œå…¨å¯ä»¥ä½¿ç”¨å…¶ä»–çº¿ç¨‹ ç»§ç»­å®Œæˆåç¨‹ã€‚
è°è¿›è¡Œresumeè°å°±æ‰§è¡Œåç¨‹ è€Œä¸”resumeå†…éƒ¨è¿˜å¯èƒ½è§¦å‘å¦ä¸€ä¸ªåç¨‹handleçš„resumeã€‚
è¿™é‡Œå°±å‘ç°äº†ï¼Œå…¶å®resumeéœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œé€šè¿‡ä¸€ä¸ªæŒ‚èµ·çš„åç¨‹handleè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶handle,ä¼šå‡ºç°é—®é¢˜çš„ã€‚
C++åç¨‹æ˜¯æ— æ ˆåç¨‹ å…¶åç¨‹frameå­˜æ”¾åœ¨å †ä¸Š è€Œä¸”æ˜¯å¯¹ç§°çš„åç¨‹ ä¹Ÿå°±æ˜¯åç¨‹ä¹‹é—´åœ°ä½æ˜¯å¹³ç­‰çš„ ä¸€ä¸ªåç¨‹å¯ä»¥éšä¾¿
è·³åˆ°å…¶ä»–åç¨‹ å“ªæ€•åœ¨ä¸¤ä¸ªåç¨‹è§åå¤æ¨ªè·³éƒ½æ²¡é—®é¢˜ ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç”¨ä¸€èµ·çš„å‡½æ•°è°ƒç”¨ è¿™æ ·loopå¤šäº†å°±ä¼šæ ˆæº¢å‡ºäº†
è€Œæ— æ ˆåç¨‹ä¸ä¼šï¼Œåªæ˜¯åœ¨ä¸¤ä¸ªçŠ¶æ€æœºä¹‹é—´åˆ‡æ¢è·³è½¬ã€‚

```cpp
#include <iostream>
#include <coroutine>
#include <string_view>
#include <thread>
#include <future>

class CoMessage
{
public:
    std::string_view str;
};

struct Awaitable;

struct CoRet
{
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        std::suspend_always initial_suspend()
        {
            std::cout << "3=>" << std::this_thread::get_id() << std::endl;
            return {};
        }

        std::suspend_never final_suspend() noexcept;

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            std::cout << "4=>" << std::this_thread::get_id() << std::endl;
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void()
        // {
        // }

        void return_value(std::string_view str)
        {
            std::cout << "5=>" << std::this_thread::get_id() << std::endl;
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h;
};

struct Awaitable
{
    CoMessage *_message;
    bool await_ready() noexcept
    {
        return false;
    }

    void await_suspend(std::coroutine_handle<CoRet::promise_type> h) noexcept
    {
        _message = &h.promise()._message;
    }

    CoMessage await_resume() noexcept
    {
        std::cout << "6=>" << std::this_thread::get_id() << std::endl;
        return *_message;
    }
};

std::suspend_never CoRet::promise_type::final_suspend() noexcept
{
    std::cout << "7=>" << std::this_thread::get_id() << std::endl;
    return {};
}

CoRet CoFunction()
{
    std::cout << "2=>" << std::this_thread::get_id() << std::endl;
    CoMessage message1 = co_await Awaitable();
    CoMessage message2 = co_await Awaitable();
    CoMessage message3 = co_await Awaitable();
    co_return "888888";
}

int main(int argc, char **argv)
{
    std::cout << "1=>" << std::this_thread::get_id() << std::endl;
    CoRet ret = CoFunction();
    ret._h();
    ret._h.promise()._message.str = "hello";
    ret._h.resume();
    // å¼€æ–°çº¿ç¨‹å»å¤„ç†åç¨‹
    std::future<int> fu = std::async(
        [&]
        {
            ret._h.resume();
            ret._h.resume();
            return 999;
        });
    fu.get(); // ç­‰å¾…å¼‚æ­¥ä»»åŠ¡
    return 0;
}

// 1=>140087387162432
// 4=>140087387162432
// 3=>140087387162432
// 2=>140087387162432
// 6=>140087387162432
// 6=>140087383815744
// 6=>140087383815744
// 5=>140087383815744
// 7=>140087383815744
```

### Cé£æ ¼æ­ç§˜åç¨‹

CppCon 2016 C++ Coroutines Under the Covers

Coroutines In C

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
int main()
{
    void* coro = f(1);
    for(int i = 0; i < 4; ++i)
    {
        CORO_RESUME(coro);
    }
    CORO_DESTROY(coro);
}
// è¾“å‡º 1,-1,2,-2

define i32 @main()
{
    call void @print(i32 1)
    call void @print(i32 -1)
    call void @print(i32 2)
    call void @print(i32 -2)
    ret i32 0
}
```

å¦‚ä½•å»ºç«‹åç¨‹çš„å¸§ Build Coroutine Frame

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
// åªéœ€è¦è®°å½•å£°æ˜å‘¨æœŸè·¨è¶ŠCORO_SUSPENDçš„
struct f.frame {
    int i;
};
```

è§£å¯†åˆ›å»ºåç¨‹å¸§

```cpp
struct f.frame {
    int i;
}
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        CORO_SUSPEND(hdl);
        print(frame->i);
        CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

è§£å¯†åˆ›å»ºè·³è·ƒç‚¹ Create Jump Pointsï¼Œåƒæ¸¸æˆå­˜æ¡£ä¸€æ ·

```cpp
struct f.frame
{
    int suspend_index;
    int i;
};
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

èƒŒåå¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†

```cpp
// Coroutine Start Function
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    //...
    return hdl;
}
// Coroutine Resume Function
void f.resume(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
}
// Coroutine Destroy Function
void f.destroy(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
    free(frame);
}
```

å‡è®¾ç¼–è¯‘å™¨ç”Ÿæˆçš„f.resume

```cpp
void f.resume(f.frame* frame)
{
    switch (frame->suspend_index)
    {
        case 0: goto r0;
        default: goto r1;
    }
    for(frame->i = n;;++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

After CleanUp

```cpp
void* f(int* n)
{
// è¿›ä¸€æ­¥æŠ½è±¡
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    frame->ResumeFn = &f.resume;
    frame->DestroyFn = &f.destroy;
    frame->i = n;
    frame->suspend_index = 0;
    return coro_hdl;
}
void f.destroy(f.frame* frame)
{
    free(frame);
}
void f.cleanup(f.frame* frame){}
void f.resume(f.frame* frame)
{
    if(frame->index == 0)
    {
        print(frame->i);
        frame->suspend_index = 1;
    }
    else
    {
        print(-frame->i);
        ++frame->i;
        frame->suspend_index = 0;
    }
}
struct f.frame
{
    FnPtr ResumeFn;
    FnPtr DestroyFn;
    int suspend_index;
    int i;
};
```

### std::noop_coroutine

std::noop_coroutine() æ˜¯ C++20 ä¸­å¼•å…¥çš„ä¸€ä¸ªå‡½æ•°ï¼Œä½äº <coroutine> å¤´æ–‡ä»¶ä¸­ã€‚å®ƒæ˜¯ä¸€ä¸ªç©ºçš„åç¨‹ï¼ˆcoroutineï¼‰ï¼Œç”¨ä½œåç¨‹ï¼ˆcoroutineï¼‰çš„å ä½ç¬¦æˆ–è€…ç©ºæ“ä½œã€‚

### å°½å¯èƒ½ç”¨åç¨‹æ›¿ä»£std::futureä¸std::promise

å› ä¸ºfutureå’Œpromise éœ€è¦åˆ†é…å†…å­˜ åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡ç­‰ï¼Œå¼€é”€æ¯”è¾ƒå¤§ã€‚ä¾‹å¦‚ï¼Œå‡è®¾åœ¨æŸäº›ä»£ç ä¸­éœ€è¦ä¼ é€’ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œä½†æ˜¯å®é™…ä¸Šä¸éœ€è¦æ‰§è¡Œè¯¥åç¨‹ï¼Œè¿™æ—¶å°±å¯ä»¥ä½¿ç”¨ std::noop_coroutine() æ¥ä»£æ›¿ï¼Œä»¥è¾¾åˆ°å ä½çš„ç›®çš„ã€‚

![futureä¸promise](../.gitbook/assets/2024-03-30172542.png)

å¯ä»¥å…å»é¢å¤–çš„å†…å­˜ç”³è¯· åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡çš„å¼€é”€

ä¸‹é¢ä»£ç æ•´ä½“ç»è¿‡æµç¨‹

1. åˆ›å»ºç‹å­åç¨‹ suspend_alwaysã€‚
2. åˆ›å»ºå…¬ä¸»åç¨‹ suspend_alwaysã€‚  
3. å°†å…¬ä¸»åç¨‹èµ‹å€¼åˆ°ç‹å­åç¨‹çš„promise _nextä¸Šå»
4. å…¬ä¸»åç¨‹å»co_awaitç‹å­
5. è¿›è€Œè§¦å‘ç‹å­çš„await_suspend åœ¨å…¶ä¸­è¿›è¡Œstd::asyncå¯¹ç‹å­è¿›è¡Œresume
ç‹å­ std::this_thread::sleep_for(500ms); ç„¶åco_returnå°†é‡‘å¸èµ‹å€¼åˆ°äº†promiseä¸Š
æœ€ååˆ©ç”¨ç‹å­ final_suspend è¿”å›ä¸€ä¸ªawaiter await_readyè¿”å›false è§¦å‘ await_suspend è¿”å›å€¼ å†³å®šè·³å¾€å“ªé‡Œç‹å­çš„æœ‰_nextåˆ™è·³å¾€å…¬ä¸»çš„int c = co_await future; å¾—åˆ°äº†ç‹å­co_returnçš„é‡‘å¸é‡ã€‚  
6. æœ€åå…¬ä¸»ä¹Ÿco_returnäº†ï¼Œå…¶è¿”å›awaiterçš„await_readyè¿”å›false,å…¬ä¸»åç¨‹è¢«doneäº†æ ‡è®°ä¸º1ï¼Œè€Œä¸”awaiter await_suspendè¿”å›ç©ºåç¨‹ï¼Œæœ€åæˆ‘ä»¬asyncåˆ›å»ºçš„åç¨‹å…¶å®ç»“æŸäº†,ä¸»çº¿ç¨‹ä¸€ç›´å¾ªç¯æ£€æŸ¥å…¬ä¸»done,æ­¤æ—¶å…¬ä¸»doneäº†ï¼Œä¸€åˆ‡éƒ½ç»“æŸäº†ã€‚

```cpp
#include <iostream>
#include <chrono>
#include <future>
#include <thread>
#include <coroutine>
using namespace std;

struct Task
{
    struct promise_type
    {
        int _result;
        coroutine_handle<> _next = nullptr;

        Task get_return_object()
        {
            return Task{coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend()
        {
            return {};
        }

        // åç¨‹ç»“æŸæ—¶ ç‹å­ç»“æŸæ—¶åˆ©ç”¨æœ€åçš„co_wait final_suspend() åˆ©ç”¨final_suspendè¿”å›å€¼è¿è¡Œå…¬ä¸»åç¨‹
        auto final_suspend() noexcept
        {
            struct next_awaiter
            {
                promise_type *me;
                bool await_ready() noexcept
                {
                    return false;
                }
                coroutine_handle<> await_suspend(coroutine_handle<promise_type> h) noexcept
                {
                    // è·³åˆ°å“ªé‡Œ
                    if (h.promise()._next)
                    {
                        return h.promise()._next; // æœ‰å…¬ä¸»å°±è·³åˆ°å…¬ä¸»æŒ‚èµ·å“ªé‡Œ
                    }
                    else
                    {
                        return std::noop_coroutine();
                    }
                }
                void await_resume() noexcept
                {
                }
            };
            return next_awaiter{this};
        }

        void return_value(int i) { _result = i; }
        void unhandled_exception() {}
    };

    using handle = coroutine_handle<promise_type>;
    handle _h;
    std::future<void> _t;

    // awaiter
    bool await_ready()
    {
        return false;
    }
    void await_suspend(handle h)
    {
        _h.promise()._next = h;
        _t = std::async(
            [&]()
            {
                _h.resume();
            });
    }
    int await_resume()
    {
        return _h.promise()._result;
    }
};

Task Prince()
{
    int coins = 1;
    std::this_thread::sleep_for(500ms);
    std::cout << std::this_thread::get_id() << "Prince - found treasure!" << std::endl;
    co_return coins;
}

Task Princess(Task &future)
{
    std::cout << std::this_thread::get_id() << "Princess - wait for Prince" << std::endl;
    int c = co_await future; // è§¦å‘Princeçš„await_suspend æŠŠå…¬ä¸»åç¨‹æŒ‚åˆ°ç‹å­çš„promiseçš„next ç„¶åå¼€ä¸€ä¸ªçº¿ç¨‹å»resumeç‹å­
    std::cout << std::this_thread::get_id() << "Princess - got" << c << " coins." << std::endl;
    co_return 0;
}

int main(int argc, char **argv)
{
    auto prince = Prince();           // åˆ›å»ºç‹å­åç¨‹
    auto princess = Princess(prince); // åˆ›å»ºå…¬ä¸»åç¨‹
    princess._h.resume();             // ä¼šæ‰§è¡Œåˆ°co_wait futureè¿”å›

    while (!princess._h.done())
    {
        cout << std::this_thread::get_id() << " main wait ...\n";
        std::this_thread::sleep_for(100ms);
    }
    std::cout << std::this_thread::get_id() << " main: done" << std::endl;
    return 0;
}

/*
140521947157440Princess - wait for Prince
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947141696Prince - found treasure!
140521947141696Princess - got1 coins.
140521947157440 main: done
*/
```

## C++20å…³äºconstexprçš„ä¼˜åŒ–

### å…è®¸constexprè™šå‡½æ•°

åœ¨C++20æ ‡å‡†å‰ï¼Œè™šå‡½æ•°æ˜¯ä¸å…è®¸å£°æ˜ä¸ºconstexprçš„ã€‚å¾ˆå¤šæ—¶å€™è™šå‡½æ•°æ˜¯æ— çŠ¶æ€çš„ï¼Œè¿™ç§æƒ…å†µä¸‹æ˜¯æœ‰æ¡ä»¶ä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¢«ä¼˜åŒ–çš„ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    virtual int f() const { return 1; }
};

int main(int argc, char **argv)
{
    X x;
    int i = x.f();
    return 0;
}
```

å¦‚æœä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¿›è¡Œä¼˜åŒ–ï¼Œåˆ™å¯ä»¥å‡å°‘å‡½æ•°è°ƒç”¨ã€‚å¯æƒœåœ¨C++17æ ‡å‡†ä¸­ä¸å…è®¸æˆ‘ä»¬è¿™ä¹ˆåšï¼Œç›´åˆ°C++20æ ‡å‡†æ˜ç¡®å…è®¸åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨è™šå‡½æ•°ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä»£ç å¯ä»¥ä¿®æ”¹ä¸ºï¼š

```cpp
#include <iostream>
using namespace std;

struct X
{
    constexpr virtual int f() const
    {
        int res = 999;
        return res;
    }
};

int main(int argc, char **argv)
{
    X x;
    constexpr int i = x.f();
    // æ­¤å¤„ç­‰ä»·äº
    // constexpr int i = 999;
    std::cout << i << std::endl; // 999
    return 0;
}
```

constexprè™šå‡½æ•°åœ¨ç»§æ‰¿é‡å†™ä¸Šå¹¶æ²¡æœ‰å…¶ä»–ç‰¹æ®Šçš„è¦æ±‚ï¼Œconstexprçš„è™šå‡½æ•°å¯ä»¥è¦†ç›–é‡å†™æ™®é€šè™šå‡½æ•°ï¼Œæ™®é€šè™šå‡½æ•°ä¹Ÿå¯ä»¥è¦†ç›–é‡å†™constexprçš„è™šå‡½æ•°ã€‚

```cpp
#include <iostream>
using namespace std;

struct X1
{
    virtual int f() const = 0;
};

struct X2 : public X1
{
    constexpr virtual int f() const { return 2; }
};

struct X3 : public X2
{
    constexpr virtual int f() const { return 4; }
};

struct X4 : public X3
{
    virtual int f() const { return 5; }
};

constexpr int (X1::*pf)() const = &X1::f;

constexpr X2 x2;
static_assert(x2.f() == 2);
static_assert((x2.*pf)() == 2);

constexpr X1 const &r2 = x2;
static_assert(r2.f() == 2);
static_assert((r2.*pf)() == 2);

constexpr const X1 *p2 = &x2;
static_assert(p2->f() == 2);
static_assert((p2->*pf)() == 2);

constexpr X3 x3;
static_assert(x3.f() == 4);

constexpr X4 x4;
// static_assert(x4.f() == 5); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr
constexpr const X1 *p4 = &x4;
// static_assert(p4->f() == 4); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr

int main(int argc, char **argv)
{
    return 0;
}
```

æ€»ä¹‹å°±æ˜¯constexprè¶Šæ¥è¶Šè‡ªç”±äº†ï¼Œå¦‚æœé‡‡ç”¨æ–°ç‰ˆæœ¬çš„C++ï¼Œå…¶å®ä¸ç”¨ç‰¹æ„å»è®°å¿†è¿™äº›ä¸œè¥¿ï¼Œæ¯•ç«ŸIDEä¼šæ™ºèƒ½æç¤ºæˆ‘ä»¬çš„ã€‚åªéœ€è¦çŸ¥é“æœ‰äº›åœºæ™¯ä¸­ä½¿ç”¨è¿™äº›ç‰¹æ€§å¯ä»¥å˜å¾—æ›´é«˜æ•ˆå°±å¥½äº†ã€‚

### å…è®¸åœ¨constexprå‡½æ•°ä¸­å‡ºç°try-catch

åœ¨C++20æ ‡å‡†ä»¥å‰try-catchæ˜¯ä¸èƒ½å‡ºç°åœ¨constexprå‡½æ•°ä¸­çš„ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

constexpr int f(int x)
{
    try
    {
        return x + 1;
    }
    catch (...)
    {
        return 0;
    }
}

int main(int argc, char **argv)
{
    constexpr int n = f(1);
    return 0;
}
```

C++17ç¼–è¯‘ä¸Šé¢ä»£ç ä¼šå¾—åˆ°ä¸€ä¸ªå‹å¥½çš„è­¦å‘Šï¼ŒC++20æ ‡å‡†ç¼–è¯‘æ—¶ï¼Œå…è®¸try-catchå­˜åœ¨äº
constexprå‡½æ•°ï¼Œä½†æ˜¯throwè¯­å¥ä¾æ—§æ˜¯è¢«ç¦æ­¢çš„ï¼Œä¹Ÿå°±æ˜¯catchéƒ¨åˆ†æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œï¼Œæ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚

### å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–

ä»C++20å¼€å§‹ï¼Œæ ‡å‡†å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    bool val;
};

constexpr void f()
{
    X x;
}

int main(int argc, char **argv)
{
    f();
    return 0;
}
```

C++17ç¼–è¯‘åˆ™ä¼šæŠ¥é”™ï¼Œæç¤ºxæ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦ç”¨æˆ·æä¾›ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œæˆ–è€…C++17è¿™æ ·å†™

```cpp
struct X
{
    bool value = false;
};
```

è™½ç„¶C++20æ ‡å‡†çš„ç¼–è¯‘å™¨æ˜¯èƒ½å¤Ÿç¼–è¯‘ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶åº”è¯¥å…»æˆå£°æ˜å¯¹è±¡æ—¶éšæ‰‹åˆå§‹åŒ–çš„ä¹ æƒ¯ï¼Œé¿å…è®©ä»£ç å‡ºç°æœªå®šä¹‰çš„è¡Œä¸ºã€‚ å¯ä»¥çœ‹ ä½ å¯èƒ½ä¸çŸ¥é“çš„C++éƒ¨åˆ† çš„ â€œä¸ºä»€ä¹ˆå£°æ˜çš„å˜é‡æ²¡æœ‰è¢«é»˜è®¤åˆå§‹åŒ–â€éƒ¨åˆ†ã€‚

### å…è®¸åœ¨constexprä¸­æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜

C++20ä¹‹å‰å¯¹constexprçš„å¦ä¸€ä¸ªé™åˆ¶å°±æ˜¯ç¦æ­¢æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

union Foo
{
    int i;
    float f;
};

constexpr int use()
{
    Foo foo{};
    foo.f = 1.2f;
    foo.i = 3; // C++20ä¹‹å‰å°†ä¼šç¼–è¯‘å¤±è´¥
    return foo.i;
}

int main(int argc, char **argv)
{
    int arr[use()] = {0};
    return 0;
}
```

åœ¨GCCå’ŒMSVC C++17ä¸­ä¸Šé¢ä»£ç æ˜¯èƒ½å¤Ÿç¼–è¯‘é€šè¿‡çš„ã€‚C++20é™¤æ­¤ä¹‹å¤–è¿˜å…è®¸è®¸å¤šç‰¹æ€§ï¼Œå¦‚å…è®¸dynamic_castå’Œtypeidå‡ºç°åœ¨
å¸¸é‡è¡¨è¾¾å¼ä¸­ï¼Œå…è®¸åœ¨constexprå‡½æ•°ä½¿ç”¨æœªç»è¯„ä¼°çš„å†…è”æ±‡ç¼–ã€‚

### ä½¿ç”¨constevalå£°æ˜ç«‹å³å‡½æ•°

constexprå£°æ˜å‡½æ•°å¹¶ä¸ä¸€æ¥å¸¸é‡è¡¨è¾¾å¼ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œåœ¨éå¸¸é‡è¡¨è¾¾å¼ç¯å¢ƒä¸­ï¼Œå‡½æ•°å¯ä»¥é€€åŒ–è¡¨ç°ä¸ºæ™®é€šå‡½æ•°ã€‚ä½†æ˜¯æœ‰æ—¶å€™
æˆ‘ä»¬å¸Œæœ›ç¡®ä¿å‡½æ•°åœ¨ç¼–è¯‘æœŸå°±æ‰§è¡Œè®¡ç®—ï¼Œæ— æ³•åœ¨ç¼–è¯‘æœŸç¡®å®šçš„ç›´æ¥è®©ç¼–è¯‘å™¨æŠ¥é”™ã€‚
C++20æ¨å‡ºäº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µ ç«‹å³å‡½æ•°ï¼Œç«‹å³å‡½æ•°éœ€è¦ä½¿ç”¨constevalè¯´æ˜ç¬¦æ¥å£°æ˜ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

constexpr int r = sqr(100);
int x = 100;
int r2 = sqr(x); // ç¼–è¯‘é”™è¯¯ è°ƒç”¨ consteval å‡½æ•° "sqr" ä¸ä¼šç”Ÿæˆæœ‰æ•ˆçš„å¸¸æ•°è¡¨è¾¾å¼
// å› ä¸ºxä¸æ˜¯constä¹Ÿä¸æ˜¯constexpr
// sqrç”¨constevalå£°æ˜ä¸ä¼šé€€åŒ–ä¸ºæ™®é€šå‡½æ•°

int main(int argc, char **argv)
{
    return 0;
}
```

å¦‚æœä¸€ä¸ªç«‹å³å‡½æ•°åœ¨å¦å¤–ä¸€ä¸ªç«‹å³å‡½æ•°ä¸­è¢«è°ƒç”¨ï¼Œåˆ™å‡½æ•°å®šä¹‰æ—¶çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä¸å¿…æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ã€‚æ€ä¹ˆç†è§£å‘¢ï¼Œå°±æ˜¯ä¼ å‚é—®é¢˜ï¼Œä¸‹é¢çš„nåœ¨sqrsqrå‡½æ•°ä¸­çœ‹ï¼Œä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼,ä½†æ˜¯æ˜¯æ²¡é—®é¢˜çš„ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

consteval int sqrsqr(int n)
{
    n = 5;//è¿™é‡Œæ²¡é—®é¢˜
    return sqr(sqr(n));
}

int main(int argc, char **argv)
{
    int arr[sqrsqr(10)]{0};
    std::cout << sizeof(arr) / sizeof(int) << std::endl; // 625
    return 0;
}
```

lambdaè¡¨è¾¾å¼ä¹Ÿå¯ä»¥ä½¿ç”¨constevalè¯´æ˜ç¬¦

```cpp
#include <iostream>
using namespace std;

auto sqr = [](int n) consteval
{ return n * n; };
int r = sqr(100);

int main(int argc, char **argv)
{
    std::cout << r << std::endl; // 10000
    auto ptr = sqr;//gccå®æµ‹è·å–ç«‹å³å‡½æ•°çš„å‡½æ•°åœ°å€æ˜¯æ²¡æœ‰é—®é¢˜çš„
    std::cout << ptr(100) << std::endl;
    return 0;
}
```

### ä½¿ç”¨constinitæ£€æŸ¥å¸¸é‡åˆå§‹åŒ–

C++ä¸­æœ‰ä¸€ç§å…¸å‹çš„é”™è¯¯å«åš â€œStatic Initialization Order Fiascoâ€,æŒ‡çš„æ˜¯å› ä¸ºé™æ€åˆå§‹åŒ–é¡ºåºé”™è¯¯å¯¼è‡´çš„é—®é¢˜ï¼Œ
å› ä¸ºè¿™ç§é”™è¯¯å¾€å¾€å‘ç”Ÿåœ¨mainå‡½æ•°ä¹‹å‰ï¼Œæ‰€ä»¥æ¯”è¾ƒéš¾ä»¥æ’æŸ¥ã€‚åœ¨Effective C++ä¸­ä¹Ÿæœ‰è®²åˆ°ã€‚

```cpp
//a.cpp
static int a = 100;
```

```cpp
//b.cpp
extern int a;
struct X
{
    X(){
        n = a;
    }
    int n{0};
};

static X x;
```

æ²¡é”™å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬æ²¡åŠæ³•æ§åˆ¶å“ªä¸ªå¯¹è±¡å…ˆæ„é€ ï¼Œå¦‚æœxåœ¨yä¹‹å‰æ„é€ ï¼Œå°±ä¼šå¼•å‘ä¸€ä¸ªæœªå®šä¹‰çš„ç»“æœã€‚
ä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›ä½¿ç”¨å¸¸é‡åˆå§‹åŒ–ç¨‹åºå»åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¸å¹¸çš„æ˜¯å¸¸é‡åˆå§‹åŒ–è§„åˆ™å¾ˆå¤æ‚ã€‚
C++20å¼•å…¥constinitè¯´æ˜ç¬¦ç”¨ï¼Œä¸»è¦ç”¨äºå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å˜é‡å£°æ˜ï¼Œå®ƒè¦æ±‚å˜é‡å…·æœ‰å¸¸é‡åˆå§‹åŒ–ç¨‹åºã€‚

```cpp
#include <iostream>
using namespace std;

constinit int x = 11; // ç¼–è¯‘æˆåŠŸï¼Œå…¨å±€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­

int main(int argc, char **argv)
{
    constinit static int y = 42; // ç¼–è¯‘æˆåŠŸï¼Œé™æ€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­
    constinit int z = 7;         // ç¼–è¯‘å¤±è´¥ï¼Œå±€éƒ¨å˜é‡æ˜¯åŠ¨æ€åˆ†é…çš„
    return 0;
}
```

å…¶æ¬¡ï¼Œconstinitè¦æ±‚å˜é‡ åˆå§‹åŒ–çš„ç¨‹åºéƒ¨åˆ†åº”è¯¥æ˜¯å¸¸é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
using namespace std;

const char *f()
{
    return "hello";
}

constexpr const char *g() { return "cpp"; }
constinit const char *str1 = f(); // ç¼–è¯‘é”™è¯¯ f()ä¸æ˜¯ä¸€ä¸ªå¸¸é‡åˆå§‹åŒ–ç¨‹åº
constinit const char *str2 = g(); // ç¼–è¯‘æˆåŠŸ

int main(int argc, char **argv)
{
    return 0;
}
```

constinitè¿˜èƒ½ç”¨äºéåˆå§‹åŒ–å£°æ˜ï¼Œå‘ŠçŸ¥ç¼–è¯‘å™¨thread_localå˜é‡å·²ç»è¢«åˆå§‹åŒ–

```cpp
#include <iostream>
using namespace std;

thread_local int x = 100;

extern thread_local constinit int x;

int f()
{
    return x;
}

// constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§
constinit int number = 999;

int main(int argc, char **argv)
{
    std::cout << number << std::endl;
    return 0;
}
```

constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§ã€‚

### åˆ¤æ–­å¸¸é‡æ±‚å€¼ç¯å¢ƒ

- `std:is_constant_evaluated`

ç”¨äºæ£€æŸ¥å½“å‰è¡¨è¾¾å¼æ˜¯å¦æ˜¯ä¸€ä¸ªå¸¸é‡æ±‚å€¼ç¯å¢ƒ è¿”å›boolç±»å‹

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main(int argc, char **argv)
{
    std::cout << std::pow(2.0, 3) << std::endl; // 8
    return 0;
}
```

```cpp
#include <iostream>
#include <cmath>
#include <type_traits>
using namespace std;

constexpr double power(double b, int x)
{
    if (std::is_constant_evaluated() && x >= 0)
    {
        double r = 1.0, p = b;
        unsigned int u = (unsigned int)x;
        while (u != 0)
        {
            if (u & 1)
                r *= p;
            u /= 2;
            p *= p;
        }
        return r;
    }
    else
    {
        return std::pow(b, (double)x);
    }
}

int main(int argc, char **argv)
{
    // å¸¸é‡ç¯å¢ƒ ç¼–è¯‘æœŸé—´å°±ç®—å¥½äº†
    constexpr double kilo = power(10.0, 3);
    int n = 3;
    // éå¸¸é‡ç¯å¢ƒ è¿è¡Œæ—¶ç®—
    double mucho = power(10.0, n);
    std::cout << kilo << std::endl;  // 1000
    std::cout << mucho << std::endl; // 1000

    int n1 = -1;
    constexpr double q = power(10.0, n1); // ç¼–è¯‘é”™è¯¯  â€˜int n1â€™ is not const
    std::cout << q << std::endl;
    // å› ä¸ºä¼šèµ°std::pow

    return 0;
}
```

æœ‰ä¸€ä¸ªæ¦‚å¿µå«åš æ˜æ˜¾å¸¸é‡æ±‚å€¼

1. å¸¸é‡è¡¨è¾¾å¼ï¼Œå¦‚æ•°ç»„é•¿åº¦ã€caseè¡¨è¾¾å¼ã€éç±»å‹æ¨¡æ¿å®å‚ç­‰
2. if constexprè¯­å¥ä¸­çš„æ¡ä»¶
3. constexprå˜é‡çš„åˆå§‹åŒ–ç¨‹åº
4. ç«‹å³å‡½æ•°çš„è°ƒç”¨
5. çº¦æŸæ¦‚å¿µè¡¨è¾¾å¼
6. å¯åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨æˆ–å…·æœ‰å¸¸é‡åˆå§‹åŒ–çš„å˜é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

template <bool>
struct X
{
};

X<std::is_constant_evaluated()> x;
// éç±»å‹æ¨¡æ¿å®å‚ï¼Œå‡½æ•°è¿”å›trueï¼Œæœ€ç»ˆç±»å‹ä¸ºX<true>

int main(int argc, char **argv)
{
    return 0;
}
```

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

constexpr int f()
{
    const int n = std::is_constant_evaluated() ? 13 : 17; // næ˜¯13
    int m = std::is_constant_evaluated() ? 13 : 17;       // må¯èƒ½æ˜¯13æˆ–è€…17ï¼Œå–å†³äºå‡½æ•°ç¯å¢ƒ
    char arr[n] = {};                                     // char[13]
    return m + sizeof(arr);
}

int main(int argc, char **argv)
{
    int p = f();     // mä¸º13ï¼Œpä¸º26
    int q = p + f(); // mä¸º17ï¼Œqä¸º56 å› ä¸ºè¿™é‡Œpæ˜¯éconstçš„ èµ‹å€¼å³è¾¹ä¸æ˜¯å¸¸é‡æ±‚å€¼ç¯å¢ƒ
    return 0;
}
```

å¦‚æœå½“åˆ¤æ–­æ˜¯å¦ä¸ºæ˜æ˜¾å¸¸é‡æ±‚å€¼æ—¶å­˜åœ¨å¤šä¸ªæ¡ä»¶ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šè¯•æ¢`std::is_constant_evaluated()`ä¸¤ç§æƒ…å†µæ±‚å€¼ï¼Œæ¯”å¦‚ï¼š

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int y = 1000;
const int a = std::is_constant_evaluated() ? y : 1;
const int b = std::is_constant_evaluated() ? 2 : y;

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 1
    std::cout << b << std::endl; // 2
    return 0;
}
```

- å½“å¯¹aæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°yä¼šæ”¹å˜açš„å€¼ï¼Œæ‰€ä»¥æœ€åé€‰æ‹©`std::is_constant_evaluated()==false`
- å½“å¯¹bæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°ç»“æœæ’ä¸º2ï¼Œäºæ˜¯ç›´æ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆåˆå§‹åŒ–

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int x = 2000;
int y = 1000;
const int a = std::is_constant_evaluated() ? y : 2; // (true,y)ä¸ç¬¦åˆ (false,2)ç¬¦åˆ
const int b = std::is_constant_evaluated() ? 5 : y; // (true,5)ç¬¦åˆ
const int c = std::is_constant_evaluated() ? 3 : 4; // (true,3)ç¬¦åˆ
const int d = std::is_constant_evaluated() ? x : y; // (true,x)ä¸ç¬¦åˆ (false,y)ç¬¦åˆ

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 2
    std::cout << b << std::endl; // 5
    std::cout << c << std::endl; // 3
    std::cout << d << std::endl; // 1000
    return 0;
}
```

### C++20constexpræ€»ç»“

æˆ‘åªæƒ³å–Šï¼Œä»€ä¹ˆç‹—å±C++ï¼Œå¤§å‚»é€¼ã€‚
