# ğŸŒ C++20 ç‰¹æ€§

C++20 å¼•å…¥äº†è®¸å¤šæ–°ç‰¹æ€§å’Œè¯­è¨€æ”¹è¿›ï¼Œä¸‹é¢æ˜¯å…¶ä¸­ä¸€äº›ä¸»è¦çš„ç‰¹æ€§ï¼š

1ã€æ¦‚å¿µï¼ˆConceptsï¼‰ï¼šC++20 å¼•å…¥äº†æ¦‚å¿µçš„æ¦‚å¿µï¼Œå…è®¸ç¨‹åºå‘˜åœ¨ç¼–å†™æ¨¡æ¿ä»£ç æ—¶æŒ‡å®šå‚æ•°å¿…é¡»æ»¡è¶³çš„ç±»å‹çº¦æŸã€‚

2ã€æ¨¡å—ï¼ˆModulesï¼‰ï¼šC++20 å¼•å…¥äº†æ¨¡å—ï¼Œå…è®¸ç¨‹åºå‘˜å°†ä»£ç åˆ†å‰²ä¸ºé€»è¾‘å•å…ƒï¼Œå‡å°‘äº†å¤´æ–‡ä»¶åŒ…å«å¸¦æ¥çš„ç¼–è¯‘æ—¶é—´å’ŒäºŒè¿›åˆ¶æ–‡ä»¶å¤§å°ã€‚

3ã€åç¨‹ï¼ˆCoroutinesï¼‰ï¼šC++20 å¼•å…¥äº†åç¨‹ï¼Œä½¿å¾—å¼‚æ­¥ç¼–ç¨‹å˜å¾—æ›´åŠ ç®€å•å’Œé«˜æ•ˆã€‚

4ã€åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°æ¨¡æ¿ï¼ˆTemplate for Initialization List Constructorsï¼‰ï¼šC++20 å…è®¸ä½¿ç”¨æ¨¡æ¿å®šä¹‰åˆå§‹åŒ–åˆ—è¡¨æ„é€ å‡½æ•°ï¼Œä»è€Œæ”¯æŒæ›´å¤šçš„åˆå§‹åŒ–æ–¹å¼ã€‚

5ã€constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹ä¸å†æœ‰é™åˆ¶ï¼ˆRelaxing Constraints on constexpr Functionsï¼‰ï¼šC++20 å…è®¸ constexpr å‡½æ•°çš„å‚æ•°å’Œè¿”å›å€¼ç±»å‹å¯ä»¥æ˜¯ä»»æ„çš„ï¼Œè€Œä¸å†æœ‰é™åˆ¶ã€‚

6ã€ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ï¼ˆConstexpr Null Pointerï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€ä¸ªæ–°çš„ç©ºæŒ‡é’ˆå¸¸é‡è¡¨è¾¾å¼ std::nullptr_tï¼Œå…è®¸åœ¨ç¼–è¯‘æ—¶è¿›è¡Œæ›´å®‰å…¨çš„ç©ºæŒ‡é’ˆæ£€æŸ¥ã€‚

7ã€ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼ˆCompile-Time String Operationsï¼‰ï¼šC++20 å¼•å…¥äº†ç¼–è¯‘æ—¶å­—ç¬¦ä¸²æ“ä½œï¼Œå¯ä»¥åœ¨ç¼–è¯‘æ—¶è¿›è¡Œå­—ç¬¦ä¸²çš„æ‹¼æ¥ã€æˆªå–å’Œè½¬æ¢ç­‰æ“ä½œã€‚

8ã€å¤šçº¿ç¨‹åº“æ”¹è¿›ï¼ˆImprovements to the Thread Libraryï¼‰ï¼šC++20 æ”¹è¿›äº†å¤šçº¿ç¨‹åº“ï¼Œå¼•å…¥äº†ä¸€äº›æ–°çš„ç‰¹æ€§ï¼Œå¦‚åŒæ­¥é˜Ÿåˆ—ã€é”å‡çº§ã€çº¿ç¨‹å±€éƒ¨å­˜å‚¨ç­‰ã€‚

9ã€å…ƒç¼–ç¨‹æ”¹è¿›ï¼ˆImprovements to Metaprogrammingï¼‰ï¼šC++20 å¼•å…¥äº†ä¸€äº›å…ƒç¼–ç¨‹æ”¹è¿›ï¼Œå¦‚ consteval å‡½æ•°ã€requires è¡¨è¾¾å¼ã€typename åœ¨æ¨¡æ¿å‚æ•°åˆ—è¡¨ä¸­çš„ä½ç½®æ›´åŠ çµæ´»ç­‰ã€‚

10ã€ä¸‰è·¯æ¯”è¾ƒæ“ä½œç¬¦

11ã€å¼‚å¸¸è§„èŒƒ

12ã€åˆå§‹åŒ–ä¸Šä¸‹æ–‡ä¼˜åŒ–

13ã€ç±»å‹ç‰¹æ€§ä¿®æ”¹å’Œå¢å¼º

14ã€std::rangesåº“

15ã€æ•è·åˆå§‹åŒ–

16ã€çº¿ç¨‹æœ¬åœ°å­˜å‚¨

17ã€ç»Ÿä¸€çš„æ„é€ å’Œææ„

18ã€æ•°å­¦åˆ†éš”ç¬¦

19ã€åŒæ­¥é˜Ÿåˆ—

20ã€å…¶ä»–ç»†èŠ‚æ”¹è¿›ï¼šC++20 è¿˜å¼•å…¥äº†ä¸€äº›å…¶ä»–çš„ç»†èŠ‚æ”¹è¿›ï¼Œå¦‚ä¸‰å‘æ¯”è¾ƒæ“ä½œç¬¦ã€æ ¼å¼åŒ–å­—ç¬¦ä¸²å‡½æ•° std::format()ã€std::span å®¹å™¨ã€æ ‡å‡†åº“ä¸­å¯¹æ–‡ä»¶ç³»ç»Ÿçš„æ”¯æŒç­‰ã€‚

## ä¸‰å‘æ¯”è¾ƒ

### å¤ªç©ºé£èˆ¹ spaceship è¿ç®—ç¬¦

C++20æ ‡å‡†æ–°å¼•å…¥äº†ä¸€åä¸ºâ€œå¤ªç©ºé£èˆ¹â€(spaceship)çš„è¿ç®—ç¬¦`<=>`ã€‚å®ƒæ˜¯ä¸€ä¸ªä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ã€‚`<=>`å¹¶ä¸æ˜¯C++20é¦–åˆ›çš„ï¼Œå®é™…ä¸ŠPerlã€PHPã€Rubyç­‰è¯­è¨€æ—©å·²æ”¯æŒäº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼ŒC++æ˜¯åæ¥çš„å­¦ä¹ è€…ã€‚

```cpp
// lhs <=> rhs
// å¯èƒ½äº§ç”Ÿä¸‰ç§ç»“æœ è¯¥ç»“æœå¯ä»¥å’Œ0æ¯”è¾ƒ
// å°äº0 lhs < rhs
// ç­‰äº0 lhs == rhs
// å¤§äº0 lhs > rhs
#include <iostream>
using namespace std;

int main()
{
    bool b = 7 <=> 11 < 0;
    std::cout << b << std::endl; // 1
    return 0;
}
```

è¿ç®—ç¬¦`<=>`çš„è¿”å›å€¼åªèƒ½ä¸0å’Œè‡ªèº«ç±»å‹æ¥æ¯”è¾ƒï¼Œå¦‚æœåŒå…¶ä»–æ•°å€¼æ¯”è¾ƒï¼Œç¼–è¯‘å™¨ä¼šæŠ¥é”™ã€‚

```cpp
bool b = 7 <=> 11 < 100; // ç¼–è¯‘å¤±è´¥,<=>çš„ç»“æœä¸èƒ½ä¸0ä¹‹å¤–çš„æ•°å€¼æ¯”è¾ƒ
```

### ä¸‰å‘æ¯”è¾ƒçš„è¿”å›ç±»å‹

å¯ä»¥çœ‹å‡º`<=>`çš„è¿”å›ç»“æœå¹¶ä¸æ˜¯ä¸€ä¸ªæ™®é€šç±»å‹ï¼Œæ ¹æ®æ ‡å‡†ä¸‰å‘æ¯”è¾ƒä¼šè¿”å›3ç§ç±»å‹ï¼Œè€Œè¿™3ç§ç±»å‹åˆä¼šåˆ†ä¸ºæœ‰3ï½4ç§æœ€ç»ˆç»“æœã€‚

```cpp
std::strong_ordering
std::weak_ordering
std::partial_ordering
```

### std::strong_ordering

```cpp
// è¡¨è¾¾å¼ lsh <=> rhs
std::strong_ordering
    - std::strong_ordering::less    å¯¹åº” lhs  < rhs
    - std::strong_ordering::equal   å¯¹åº” lhs == rhs
    - std::strong_ordering::greater å¯¹åº” lhs  > rhs
```

`std::strong_ordering` ç±»å‹çš„ç»“æœå¼ºè°ƒçš„æ˜¯strongçš„å«ä¹‰ï¼Œè¡¨è¾¾çš„æ˜¯ä¸€ç§å¯æ›¿æ¢æ€§ï¼Œç®€å•æ¥è¯´ï¼Œè‹¥`lhs == rhs`ï¼Œé‚£ä¹ˆåœ¨ä»»ä½•æƒ…å†µä¸‹rhså’Œlhséƒ½å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) == fx(rhs)`ã€‚

å¯¹äºåŸºæœ¬ç±»å‹ä¸­çš„intç±»å‹ï¼Œä¸‰å‘æ¯”è¾ƒè¿”å›çš„æ˜¯`std::strong_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <iostream>

using namespace std;

int main()
{
    std::cout << typeid(decltype(7 <=> 11)).name();
    // St15strong_ordering
    return 0;
}
```

å¯¹äºæœ‰å¤æ‚ç»“æ„çš„ç±»å‹ï¼Œ`std::strong_ordering` è¦æ±‚å…¶æ•°æ®æˆå‘˜å’ŒåŸºç±»çš„ä¸‰å‘æ¯”è¾ƒç»“æœéƒ½ä¸º`std::strong_ordering`ã€‚ä¾‹å¦‚ï¼š

é»˜è®¤æƒ…å†µä¸‹è‡ªå®šä¹‰ç±»å‹æ˜¯ä¸å­˜åœ¨ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œéœ€è¦ç”¨æˆ·æ˜¾å¼é»˜è®¤å£°æ˜ã€‚

```cpp
#include <iostream>
#include <compare>

using namespace std;

class B
{
public:
    int a;
    long b;
    auto operator <=> (const B&) const = default;
};

class D : public B
{
public:
    short c;
    auto operator <=> (const D&) const = default;
};

int main()
{
    D x1, x2;
    std::cout << typeid(decltype(x1 <=> x2)).name() << std::endl;
    // St15strong_ordering
    return 0;
}
```

å¯¹ç»“æ„ä½“Bè€Œè¨€ï¼Œç”±äºintå’Œlongçš„æ¯”è¾ƒç»“æœéƒ½æ˜¯`std::strong_ordering`ï¼Œå› æ­¤ç»“æ„ä½“Bçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¹Ÿæ˜¯`std::strong_ordering`ã€‚  
å¯¹ç»“æ„ä½“Dï¼Œå…¶ åŸºç±» å’Œ æˆå‘˜ çš„æ¯”è¾ƒç»“æœæ˜¯`std::strong_ordering`ï¼ŒDçš„ä¸‰å‘æ¯”è¾ƒç»“æœåŒæ ·æ˜¯`std::strong_ordering`ã€‚

### std::weak_ordering

```cpp
lhs <=> rhs
    - std::weak_ ordering::less      å¯¹åº” lhs < rhs
    - std::weak_ordering::equivalent å¯¹åº” lhs == rhs
    - std::weak_ ordering::greater   å¯¹åº” lhs > rhs
```

weakè¡¨è¾¾çš„æ˜¯ä¸å¯æ›¿æ¢æ€§ã€‚å³è‹¥æœ‰`lhs == rhs`ï¼Œåˆ™rhså’Œlhsä¸å¯ä»¥ç›¸äº’æ›¿æ¢ï¼Œä¹Ÿå°±æ˜¯`fx(lhs) != fx(rhs)`ã€‚è¿™ç§æƒ…å†µåœ¨åŸºç¡€ç±»å‹ä¸­å¹¶æ²¡æœ‰ï¼Œä½†æ˜¯å®ƒå¸¸å¸¸å‘ç”Ÿåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»ä¸­ï¼Œæ¯”å¦‚ä¸€ä¸ªå¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼š

```cpp
#include <iostream>
#include <compare>
#include <string>

using namespace std;

int ci_compare(const char* s1, const char* s2)
{
    while(tolower(*s1) == tolower(*s2++))
    {
        if(*s1++ == '\0')
        {
            return 0;
        }
    }
    return tolower(*s1) - tolower(*--s2);
}

class CIString
{
public:
    CIString(const char*s) : str_(s){}
    std::weak_ordering operator<=>(const CIString& b) const
    {
        return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
    }
private:
    std::string str_;
};

int main()
{
    CIString s1{"HELLO"}, s2{"hello"};
    std::cout << (s1 <=> s2 == 0) << std::endl;
    // 1
    return 0;
}
```

ä»¥ä¸Šä»£ç å®ç°äº†ä¸€ä¸ªç®€å•çš„å¤§å°å†™ä¸æ•æ„Ÿçš„å­—ç¬¦ä¸²ç±»ï¼Œå®ƒå¯¹äºs1å’Œs2çš„æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering::equivalent`ï¼Œè¡¨ç¤ºä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç­‰ä»·çš„ã€‚ä½†æ˜¯å®ƒä»¬ä¸æ˜¯ç›¸ç­‰çš„ä¹Ÿä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚å½“`std::weak_ordering`å’Œ`std::strong_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::weak_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
```

ç”¨MSVCç¼–è¯‘è¿è¡Œä¸Šé¢è¿™æ®µä»£ç ä¼šè¾“å‡º`class std::weak_ordering`ï¼Œå› ä¸ºDä¸­çš„æ•°æ®æˆå‘˜CIStringçš„ä¸‰å‘æ¯”è¾ƒç»“æœä¸º`std::weak_ordering`ã€‚è¯·æ³¨æ„ï¼Œå¦‚æœæ˜¾å¼å£°æ˜é»˜è®¤ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¸º`std::strong_ordering operator <=> (const D&) const = default;`é‚£ä¹ˆä¸€å®šä¼šé­é‡åˆ°ä¸€ä¸ªç¼–è¯‘é”™è¯¯ã€‚

### std::partial_ordering

```cpp
std::partial_ordering
    - std::partial_ordering::less
    - std::partial_ordering::equivalent
    - std::partial_ ordering::greater
    - std::partial_ordering::unordered
```

`std::partial_ordering`çº¦æŸåŠ›æ¯”`std::weak_ordering`æ›´å¼±ï¼Œå®ƒå¯ä»¥æ¥å—å½“`lhs == rhs`æ—¶rhså’Œlhsä¸èƒ½ç›¸äº’æ›¿æ¢ã€‚
åŒæ—¶å®ƒè¿˜èƒ½ç»™å‡ºç¬¬å››ä¸ªç»“æœ`std::partial_ordering::unordered`ï¼Œè¡¨ç¤ºè¿›è¡Œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°æ²¡æœ‰å…³ç³»ã€‚æ¯”å¦‚åŸºç¡€ç±»å‹ä¸­çš„æµ®ç‚¹æ•°ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << typeid(decltype(7.7 <=> 11.1)).name();
    // St16partial_ordering
    return 0;
}
```

ä¼šè¾“å‡º`class std::partial_ordering`è€Œä¸æ˜¯`std::strong_ordering`ï¼Œæ˜¯å› ä¸ºæµ®ç‚¹çš„é›†åˆä¸­å­˜åœ¨ä¸€ä¸ªç‰¹æ®Šçš„NaNï¼Œå®ƒå’Œå…¶ä»–æµ®ç‚¹æ•°å€¼æ˜¯æ²¡å…³ç³»çš„ï¼š

```cpp
#include <iostream>
using namespace std;

int main()
{
    std::cout << ((0.0 / 0.0 <=> 1.0) == std::partial_ordering::unordered);
    // 1
    return 0;
}
```

å½“`std::weak_ordering`å’Œ`std::partial_ordering`åŒæ—¶å‡ºç°åœ¨åŸºç±»å’Œæ•°æ®æˆå‘˜çš„ç±»å‹ä¸­æ—¶ï¼Œè¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒç»“æœæ˜¯`std::partial_ordering`ï¼Œä¾‹å¦‚ï¼š

```cpp
struct D : B 
{
  CIString c{""};
  float u;
  auto operator <=> (const D&) const = default;
};

D w1, w2;
std::cout << typeid(decltype(w1 <=> w2)).name();
// class std::partial_ordering
```

å†æ¬¡å¼ºè°ƒä¸€ä¸‹ï¼Œ`std::strong_ordering`ã€`std::weak_ordering`å’Œ`std::partial_ordering`åªèƒ½ä¸0å’Œç±»å‹è‡ªèº«æ¯”è¾ƒã€‚æ·±ç©¶å…¶åŸå› ï¼Œæ˜¯è¿™3ä¸ªç±»åªå®ç°äº†å‚æ•°ç±»å‹ä¸ºè‡ªèº«ç±»å‹å’Œ`nullptr_t`çš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚

### std::variant

`std::variant`æ˜¯ C++17 å¼•å…¥çš„æ ‡å‡†åº“æ¨¡æ¿ï¼ˆä½¿ç”¨å‰è¯·ç¡®ä¿ä½ çš„ç¼–è¯‘å™¨æ”¯æŒ C++ 17ï¼‰ï¼Œå®ƒæä¾›äº†ä¸€ç§ç±»å‹å®‰å…¨çš„å˜ä½“ç±»å‹ï¼Œå¯ä»¥å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ã€‚ `std::variant`è¡¨ç¤ºä¸€ä¸ªç±»å‹å®‰å…¨çš„è”åˆä½“ï¼Œå³å¯ä»¥åœ¨ä¸€ä¸ªå˜é‡ä¸­å­˜å‚¨ä¸åŒç±»å‹çš„å€¼ï¼Œè€Œä¸”ä¸€æ¬¡åªèƒ½å­˜å‚¨å®ƒå…¶ä¸­ä¸€ä¸ªå¯èƒ½çš„ç±»å‹çš„å€¼ã€‚ `std::variant`çš„ä¸»è¦ä¼˜ç‚¹æ˜¯æä¾›äº†ç±»å‹å®‰å…¨å’Œçµæ´»æ€§ã€‚å®ƒå¯ä»¥ç”¨äºå¤„ç†å…·æœ‰å¤šç§å¯èƒ½ç±»å‹çš„æ•°æ®ï¼Œä¾‹å¦‚åœ¨å‡½æ•°å‚æ•°ä¸­ä¼ é€’ä¸åŒç±»å‹çš„å‚æ•°ï¼Œæˆ–è€…åœ¨å¤„ç†å¼‚è´¨é›†åˆæ—¶å­˜å‚¨ä¸åŒç±»å‹çš„å…ƒç´ ã€‚ ä»¥ä¸‹æ˜¯ä½¿ç”¨`std::variant`çš„ä¸€äº›ç¤ºä¾‹ä»£ç ï¼š

```cpp
#include <iostream>
#include <variant>
using namespace std;

void processVariant(const std::variant<int, double, std::string>& v)
{
    std::visit([](auto &value){
        std::cout << "Value: " << value << std::endl;
    }, v);
}

int main()
{
    std::variant<int, double, std::string> v = 42;
    processVariant(v);
    v = 3.14;
    processVariant(v);
    v = "Hello, world";
    processVariant(v);
    std::cout << typeid(std::get<0>(v)).name() << std::endl;
    // i
    std::cout << typeid(std::get<1>(v)).name() << std::endl;
    // d
    std::cout << typeid(std::get<2>(v)).name() << std::endl;
    // NSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE
    return 0;
}
/*
Value: 42
Value: 3.14
Value: Hello, world
*/
// https://en.cppreference.com/w/cpp/utility/variant
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œ`std::variant`åœ¨å­˜å‚¨ç±»å‹æ—¶ä½¿ç”¨äº†åŠ¨æ€å¤šæ€æ€§ï¼ˆå³è¿è¡Œæ—¶å¤šæ€ï¼‰ï¼Œè¿™æ„å‘³ç€åœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå­˜å‚¨çš„å…·ä½“ç±»å‹ï¼Œè€Œæ˜¯åœ¨è¿è¡Œæ—¶æ ¹æ®å®é™…èµ‹å€¼æ¥ç¡®å®šã€‚ è¿™ä¹Ÿæ„å‘³ç€åœ¨ä½¿ç”¨`std::variant`æ—¶ï¼Œéœ€è¦è°¨æ…å¤„ç†ç±»å‹è½¬æ¢å’Œæ“ä½œï¼Œä»¥ç¡®ä¿ç±»å‹å®‰å…¨ã€‚

### std::common_comparison_category

åœ¨C++20çš„æ ‡å‡†åº“ä¸­æœ‰ä¸€ä¸ªæ¨¡æ¿å…ƒå‡½æ•° `std::common_comparison_category` ï¼Œå®ƒå¯ä»¥å¸®åŠ©æˆ‘ä»¬åœ¨ä¸€ä¸ªç±»å‹åˆé›†ä¸­åˆ¤æ–­å‡ºæœ€ç»ˆä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ï¼Œå½“ç±»å‹åˆé›†ä¸­å­˜åœ¨ä¸æ”¯æŒä¸‰å‘æ¯”è¾ƒçš„ç±»å‹æ—¶ï¼Œè¯¥æ¨¡æ¿å…ƒå‡½æ•°è¿”å›voidã€‚

```cpp
https://en.cppreference.com/w/cpp/utility/compare/common_comparison_category
```

### å¯¹åŸºç¡€ç±»å‹çš„æ”¯æŒ

1. å¯¹ä¸¤ä¸ªç®—æœ¯ç±»å‹çš„æ“ä½œæ•°è¿›è¡Œä¸€èˆ¬ç®—æœ¯è½¬æ¢ï¼Œç„¶åè¿›è¡Œæ¯”è¾ƒã€‚å…¶ä¸­æ•´å‹çš„æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ï¼Œæµ®ç‚¹å‹çš„æ¯”è¾ƒç»“æœä¸º`std::partial_ordering`ã€‚ä¾‹å¦‚`7 <=> 11.1`ä¸­ï¼Œæ•´å‹7ä¼šè½¬æ¢ä¸ºæµ®ç‚¹ç±»å‹ï¼Œç„¶åå†è¿›è¡Œæ¯”è¾ƒï¼Œæœ€ç»ˆç»“æœä¸º`std::partial_ordering`ç±»å‹ã€‚
2. å¯¹äºæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹å’Œæ•´å‹æ“ä½œæ•°ï¼Œæšä¸¾ç±»å‹ä¼šè½¬æ¢ä¸ºæ•´å‹å†è¿›è¡Œæ¯”è¾ƒï¼Œæ— ä½œç”¨åŸŸæšä¸¾ç±»å‹æ— æ³•ä¸æµ®ç‚¹ç±»å‹æ¯”è¾ƒã€‚

```cpp
enum color {
  red
};

auto r = red <=> 11;   //ç¼–è¯‘æˆåŠŸ
auto r = red <=> 11.1; //ç¼–è¯‘å¤±è´¥
```

3. å¯¹ä¸¤ä¸ªç›¸åŒæšä¸¾ç±»å‹çš„æ“ä½œæ•°æ¯”è¾ƒç»“æœï¼Œå¦‚æœæšä¸¾ç±»å‹ä¸åŒï¼Œåˆ™æ— æ³•ç¼–è¯‘ã€‚
4. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºboolç±»å‹çš„æƒ…å†µï¼Œå¦ä¸€ä¸ªæ“ä½œæ•°å¿…é¡»ä¹Ÿæ˜¯boolç±»å‹ï¼Œå¦åˆ™æ— æ³•ç¼–è¯‘ã€‚æ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚
5. ä¸æ”¯æŒä½œæ¯”è¾ƒçš„ä¸¤ä¸ªæ“ä½œæ•°ä¸ºæ•°ç»„çš„æƒ…å†µï¼Œä¼šå¯¼è‡´ç¼–è¯‘å‡ºé”™ï¼Œä¾‹å¦‚ï¼š

```cpp
int arr1[5];
int arr2[5];
auto r = arr1 <=> arr2; // ç¼–è¯‘å¤±è´¥
```

6. å¯¹äºå…¶ä¸­ä¸€ä¸ªæ“ä½œæ•°ä¸ºæŒ‡é’ˆç±»å‹çš„æƒ…å†µï¼Œéœ€è¦å¦ä¸€ä¸ªæ“ä½œæ•°æ˜¯åŒæ ·ç±»å‹çš„æŒ‡é’ˆï¼Œæˆ–è€…æ˜¯å¯ä»¥è½¬æ¢ä¸ºç›¸åŒç±»å‹çš„æŒ‡é’ˆï¼Œæ¯”å¦‚æ•°ç»„åˆ°æŒ‡é’ˆçš„è½¬æ¢ã€æ´¾ç”Ÿç±»æŒ‡é’ˆåˆ°åŸºç±»æŒ‡é’ˆçš„è½¬æ¢ç­‰ï¼Œæœ€ç»ˆæ¯”è¾ƒç»“æœä¸º`std::strong_ordering`ã€‚

```cpp
char arr1[5];
char arr2[5];
char* ptr = arr2;
auto r = ptr <=> arr1;
// ä¸Šé¢çš„ä»£ç å¯ä»¥ç¼–è¯‘æˆåŠŸï¼Œè‹¥å°†ä»£ç ä¸­çš„arr1æ”¹å†™ä¸ºint arr1[5]ï¼Œåˆ™æ— æ³•ç¼–è¯‘ï¼Œå› ä¸ºint [5]æ— æ³•è½¬æ¢ä¸ºchar *ã€‚å¦‚æœå°†char * ptr = arr2;ä¿®æ”¹ä¸ºvoid * ptr = arr2;ï¼Œå°±å¯ä»¥ç¼–è¯‘æˆåŠŸäº†ã€‚
```

### è‡ªåŠ¨ç”Ÿæˆçš„æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°

æ ‡å‡†åº“ä¸­æä¾›äº†ä¸€ä¸ªåä¸º`std::rel_ops`çš„å‘½åç©ºé—´ï¼Œåœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹å·²ç»æä¾›äº†`==`è¿ç®—ç¬¦å‡½æ•°å’Œ<è¿ç®—ç¬¦å‡½æ•°çš„æƒ…å†µä¸‹ï¼Œå¸®åŠ©ç”¨æˆ·å®ç°å…¶ä»–4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œ åŒ…æ‹¬`!=ã€>ã€<=å’Œ>=`ï¼Œä¾‹å¦‚ï¼š

```cpp
#include <string>
#include <utility>
class CIString2 {
public:
  CIString2(const char* s) : str_(s) {}

  bool operator < (const CIString2& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) < 0;
  }
private:
  std::string str_;
};

using namespace std::rel_ops;
CIString2 s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

ä¸è¿‡å› ä¸ºC++20æ ‡å‡†æœ‰äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„å…³ç³»ï¼Œæ‰€ä»¥ä¸æ¨èä¸Šé¢è¿™ç§åšæ³•äº†ã€‚C++20æ ‡å‡†è§„å®šï¼Œå¦‚æœç”¨æˆ·ä¸ºè‡ªå®šä¹‰ç±»å‹å£°æ˜äº†ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šä¸ºå…¶è‡ªåŠ¨ç”Ÿæˆ`<ã€>ã€<=å’Œ>=`è¿™4ç§è¿ç®—ç¬¦å‡½æ•°ã€‚å¯¹äºCIStringæˆ‘ä»¬å¯ä»¥ç›´æ¥ä½¿ç”¨è¿™4ç§è¿ç®—ç¬¦å‡½æ•°:

```cpp
CIString s1{ "hello" }, s2{ "world" };
bool r = s1 >= s2;
```

é‚£ä¹ˆè¿™é‡Œå°±ä¼šäº§ç”Ÿä¸€ä¸ªç–‘é—®ï¼Œå¾ˆæ˜æ˜¾ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦èƒ½è¡¨è¾¾ä¸¤ä¸ªæ“ä½œæ•°æ˜¯ç›¸ç­‰æˆ–è€…ç­‰ä»·çš„å«ä¹‰ï¼Œä¸ºä»€ä¹ˆæ ‡å‡†åªå…è®¸è‡ªåŠ¨ç”Ÿæˆ4ç§è¿ç®—ç¬¦å‡½æ•°ï¼Œå´ä¸èƒ½è‡ªåŠ¨ç”Ÿæˆ`==å’Œ=!`è¿™ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå®é™…ä¸Šè¿™é‡Œå­˜åœ¨ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚åœ¨C++20æ ‡å‡†æ‹Ÿå®šä¸‰å‘æ¯”è¾ƒçš„æ—©æœŸï¼Œæ˜¯å…è®¸é€šè¿‡ä¸‰å‘æ¯”è¾ƒè‡ªåŠ¨ç”Ÿæˆ6ä¸ªæ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°çš„ï¼Œè€Œä¸‰å‘æ¯”è¾ƒçš„ç»“æœç±»å‹ä¹Ÿä¸æ˜¯3ç§è€Œæ˜¯5ç§ï¼Œå¤šå‡ºæ¥çš„ä¸¤ç§åˆ†åˆ«æ˜¯`std::strong_equality`å’Œ`std::weak_equality`ã€‚ä½†æ˜¯åœ¨ææ¡ˆæ–‡æ¡£p1190ä¸­æå‡ºäº†ä¸€ä¸ªä¸¥é‡çš„æ€§èƒ½é—®é¢˜ã€‚ç®€å•æ¥è¯´ï¼Œå‡è®¾æœ‰ä¸€ä¸ªç»“æ„ä½“ï¼š

```cpp
struct S {
    std::vector<std::string> names;
    auto operator<=>(const S &) const = default;
};
```

å®ƒçš„ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦çš„é»˜è®¤å®ç°è¿™æ ·çš„ï¼š

```cpp
template<typename T>
std::strong_ordering operator<=>(const std::vector<T>& lhs, const std::vector<T> & rhs)
{
    size_t min_size = min(lhs.size(), rhs.size());
    for (size_t i = 0; i != min_size; ++i) {
        if (auto const cmp = std::compare_3way(lhs[i], rhs[i]); cmp != 0) {
            return cmp;
        }
    }
    return lhs.size() <=> rhs.size();
}
```

è¿™ä¸ªå®ç°å¯¹äº`<å’Œ>`è¿™æ ·çš„è¿ç®—ç¬¦å‡½æ•°æ²¡æœ‰é—®é¢˜ï¼Œå› ä¸ºéœ€è¦æ¯”è¾ƒå®¹å™¨ä¸­çš„æ¯ä¸ªå…ƒç´ ã€‚ä½†æ˜¯`==`è¿ç®—ç¬¦å°±æ˜¾å¾—ååˆ†ä½æ•ˆï¼Œå¯¹äº`==`è¿ç®—ç¬¦é«˜æ•ˆçš„åšæ³•æ˜¯å…ˆæ¯”è¾ƒå®¹å™¨ä¸­çš„å…ƒç´ æ•°é‡æ˜¯å¦ç›¸ç­‰ï¼Œå¦‚æœå…ƒç´ æ•°é‡ä¸åŒï¼Œåˆ™ç›´æ¥è¿”å›falseï¼š

```cpp
template<typename T>
bool operator==(const std::vector<T>& lhs, const std::vector<T>& rhs)
{
    const size_t size = lhs.size();
    if (size != rhs.size()) {
        return false;
    }

    for (size_t i = 0; i != size; ++i) {
        if (lhs[i] != rhs[i]) {
            return false;
        }
    }
    return true;
}
```

æƒ³è±¡ä¸€ä¸‹ï¼Œå¦‚æœæ ‡å‡†å…è®¸ç”¨ä¸‰å‘æ¯”è¾ƒçš„ç®—æ³•è‡ªåŠ¨ç”Ÿæˆ`==`è¿ç®—ç¬¦å‡½æ•°ä¼šå‘ç”Ÿä»€ä¹ˆäº‹æƒ…ï¼Œ å¾ˆå¤šæ—§ä»£ç å‡çº§ç¼–è¯‘ç¯å¢ƒåä¼šå‘ç°è¿è¡Œæ•ˆç‡ä¸‹é™äº†ï¼Œå°¤å…¶æ˜¯åœ¨å®¹å™¨ä¸­å…ƒç´ æ•°é‡ä¼—å¤šä¸”æ¯ä¸ªå…ƒç´ æ•°æ®é‡åºå¤§çš„æƒ…å†µä¸‹ã€‚ å¾ˆå°‘æœ‰ç¨‹åºå‘˜ä¼šæ³¨æ„åˆ°ä¸‰å‘æ¯”è¾ƒç®—æ³•çš„ç»†èŠ‚ï¼Œå¯¼è‡´è¿™ä¸ªæ€§èƒ½é—®é¢˜éš¾ä»¥æ’æŸ¥ã€‚åŸºäºè¿™ç§è€ƒè™‘ï¼ŒC++å§”å‘˜ä¼šä¿®æ”¹äº†åŸæ¥çš„ä¸‰å‘æ¯”è¾ƒææ¡ˆï¼Œ è§„å®šå£°æ˜ä¸‰å‘æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°åªèƒ½å¤Ÿè‡ªåŠ¨ç”Ÿæˆ4ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ã€‚ç”±äºä¸éœ€è¦è´Ÿè´£åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œ å› æ­¤`std::strong_equality`å’Œ`std::weak_equality`ä¹Ÿé€€å‡ºäº†å†å²èˆå°ã€‚å¯¹äº`==å’Œ!=`ä¸¤ç§æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œ åªéœ€è¦å¤šå£°æ˜ä¸€ä¸ª`==`è¿ç®—ç¬¦å‡½æ•°ï¼Œ`!=`è¿ç®—ç¬¦å‡½æ•°ä¼šæ ¹æ®å‰è€…è‡ªåŠ¨ç”Ÿæˆï¼š

```cpp
class CIString {
public:
  CIString(const char* s) : str_(s) {}

  std::weak_ordering operator<=>(const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) <=> 0;
  }

  bool operator == (const CIString& b) const {
       return ci_compare(str_.c_str(), b.str_.c_str()) == 0;
  }
private:

  std::string str_;
};

CIString s1{ "hello" }, s2{ "world" };
bool r1 = s1 >= s2; // è°ƒç”¨operator<=>
bool r2 = s1 == s2; // è°ƒç”¨operator ==
```

### å…¼å®¹æ—§ä»£ç 

ç°åœ¨C++20æ ‡å‡†å·²ç»æ¨èä½¿ç”¨`<=>å’Œ==`è¿ç®—ç¬¦è‡ªåŠ¨ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ï¼Œè€Œä½¿ç”¨`<ã€==ä»¥åŠstd::rel_ops`ç”Ÿæˆå…¶ä»–æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°ä¼šå› ä¸º`std::rel_ops`å·²ç»ä¸è¢«æ¨èä½¿ç”¨è€Œè¢«ç¼–è¯‘å™¨è­¦å‘Šã€‚åˆ™é‚£ä¹ˆå¯¹äºè€ä»£ç ï¼Œæˆ‘ä»¬æ˜¯å¦éœ€è¦å»å®ç°ä¸€å¥—`<=>å’Œ==`è¿ç®—ç¬¦å‡½æ•°å‘¢ï¼Ÿå…¶å®å¤§å¯ä¸å¿…ï¼ŒC++å§”å‘˜ä¼šåœ¨è£å†³è¿™é¡¹ä¿®æ”¹çš„æ—¶å€™å·²ç»è€ƒè™‘åˆ°è€ä»£ç çš„ç»´æŠ¤æˆæœ¬ï¼Œæ‰€ä»¥åšäº†å…¼å®¹æ€§å¤„ç†ï¼Œå³åœ¨ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ä¸­ï¼Œå®ç°äº†`<ã€==`è¿ç®—ç¬¦å‡½æ•°çš„æ•°æ®æˆå‘˜ç±»å‹ï¼Œåœ¨è¯¥ç±»å‹çš„ä¸‰å‘æ¯”è¾ƒä¸­å°†è‡ªåŠ¨ç”Ÿæˆåˆé€‚çš„æ¯”è¾ƒä»£ç ã€‚æ¯”å¦‚ï¼š

```cpp
struct Legacy {
  int n;
  bool operator==(const Legacy& rhs) const
  {
       return n == rhs.n;
  }
  bool operator<(const Legacy& rhs) const
  {
       return n < rhs.n;
  }
};

struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay &) const = default;
};

TreeWay t1, t2;
bool r = t1 < t2;
```

åœ¨ä¸Šé¢çš„ä»£ç ä¸­ï¼Œç»“æ„ä½“TreeWayçš„ä¸‰å‘æ¯”è¾ƒæ“ä½œä¼šè°ƒç”¨ç»“æ„ä½“Legacyä¸­çš„`<å’Œ==`è¿ç®—ç¬¦æ¥å®Œæˆï¼Œå…¶ä»£ç ç±»ä¼¼äºï¼š

```cpp
struct TreeWay {
  Legacy m;
  std::strong_ordering operator<=>(const TreeWay& rhs) const {
       if (m < rhs.m) return std::strong_ordering::less;
       if (m == rhs.m) return std::strong_ordering::equal;
       return std::strong_ordering::greater;
  }
};
```

éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œ`operator<=>`å¿…é¡»æ˜¾å¼å£°æ˜è¿”å›ç±»å‹ä¸º`std::strong_ordering`ï¼Œä½¿ç”¨autoæ˜¯æ— æ³•é€šè¿‡ç¼–è¯‘çš„ã€‚

### ä¸‰å‘æ¯”è¾ƒæ€»ç»“

C++20æ–°å¢çš„ä¸‰å‘æ¯”è¾ƒç‰¹æ€§ï¼Œè¯¥ç‰¹æ€§çš„å¼•å…¥ä¸ºå®ç°æ¯”è¾ƒè¿ç®—æä¾›äº†æ–¹ä¾¿ã€‚ æˆ‘ä»¬åªéœ€è¦å®ç°`==å’Œ<=>`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œå‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°å°±å¯ä»¥äº¤ç»™ç¼–è¯‘å™¨è‡ªåŠ¨ç”Ÿæˆäº†ã€‚ è™½è¯´`std::rel_ops`åœ¨å®ç°äº†`==å’Œ<`ä¸¤ä¸ªè¿ç®—ç¬¦å‡½æ•°ä»¥åä¹Ÿèƒ½è‡ªåŠ¨æä¾›å‰©ä¸‹çš„4ä¸ªè¿ç®—ç¬¦å‡½æ•°ï¼Œ ä½†æ˜¾ç„¶ç”¨ä¸‰å‘æ¯”è¾ƒæ›´åŠ ä¾¿æ·ã€‚å¦å¤–ï¼Œä¸‰å‘æ¯”è¾ƒæä¾›çš„3ç§ç»“æœç±»å‹ä¹Ÿæ˜¯`std::rel_ops`æ— æ³•åª²ç¾çš„ã€‚ è¿›ä¸€æ­¥æ¥è¯´ï¼Œç”±äºä¸‰å‘æ¯”è¾ƒçš„å‡ºç°ï¼Œ`std::rel_ops`åœ¨C++20ä¸­å·²ç»ä¸è¢«æ¨èä½¿ç”¨äº†ã€‚ æœ€åï¼ŒC++å§”å‘˜ä¼šæ²¡æœ‰å¿˜è®°å…¼å®¹æ€§é—®é¢˜ï¼Œè¿™è®©ä¸‰å‘æ¯”è¾ƒèƒ½å¤Ÿé€šè¿‡è¿ç®—ç¬¦å‡½æ•°`<å’Œ==`æ¥è‡ªåŠ¨ç”Ÿæˆã€‚

## åç¨‹

éå¸¸niceçš„è®²è§£ <https://www.bilibili.com/video/BV1c8411f7dw>

### ä»€ä¹ˆæ˜¯åç¨‹

å…ˆå­¦ä¼šä½¿ç”¨ï¼Œç„¶ååœ¨å­¦ä¹ èƒŒåçš„å®ç°åŸç†ã€‚ç”±æµ…åˆ°æ·±æ‰æ˜¯å­¦ä¹ çš„æ­£ç¡®å§¿åŠ¿ã€‚

åç¨‹ï¼šæ˜¯ä¸€ç§å¯ä»¥è¢«æŒ‚èµ·å’Œå›å¤çš„å‡½æ•°ã€‚

ç”µè„‘æœ¬æœºæ²¡æœ‰ç¯å¢ƒå¯ä»¥ä½¿ç”¨ è½»æ¾ä½¿ç”¨C++2aç¯å¢ƒ:<https://godbolt.org/>

### å‡½æ•°è°ƒç”¨VSåç¨‹

![å‡½æ•°è°ƒç”¨VSåç¨‹](../.gitbook/assets/2024-03-27232828.png)

å‡½æ•°çš„è°ƒç”¨æ˜¯è°ƒç”¨çš„å‡½æ•°è¿›è¡Œreturnï¼Œç„¶åè¿”å›å›æ¥ï¼Œç»§ç»­æ‰§è¡Œï¼Œä¸”è°ƒç”¨çš„å‡½æ•°å·²ç»æ‰§è¡Œå®Œäº†ï¼Œä¸ä¼šä¸­æ–­ã€‚

è€Œåç¨‹æ˜¯å¯ä»¥æ‰§è¡Œåˆ°æŸå¤„co_yieldæˆ–co_awaitæ—¶ï¼Œç„¶åè·³è½¬åˆ°æŸä¸ªåœ°æ–¹(åç¨‹è¢«æŒ‚èµ·æ—¶ä¸æ˜¯å¿…é¡»å›åˆ°è¢«è°ƒç”¨çš„åœ°æ–¹ï¼Œå®Œå…¨å¯ä»¥æŒ‡å®šå…¶ä»–åç¨‹ï¼Œè¿™å°±æ˜¯åç¨‹è°ƒåº¦çš„å†…å®¹äº†)ï¼Œå½“åç¨‹è¢«æ‰§è¡Œresumeæ—¶ç»§ç»­æ‰§è¡Œåç¨‹
å½“co_returnæ—¶åç¨‹å°†ç»“æŸã€‚

### ç®€å•å®ä¾‹

ç®€å•è®¤è¯†

- åç¨‹è¿”å›å€¼ç±»å‹ä¸promise_typeã€initial_suspendã€final_suspendã€unhandled_exceptionã€get_return_objectã€yield_valueã€return_voidã€return_value
- std::coroutine_handleã€doneã€()ã€resumeã€from_promise
- co_awaitã€co_yieldã€co_return
- awaitableã€await_readyã€await_suspendã€await_resume

```CMake
project(main)

add_compile_options(-Wall)

set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -g -Wall -O0")
set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g -std=c++2a -Wall -O0")

add_executable(main.exe main.cpp)
# target_link_libraries(main.exe)
```

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        int _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never initial_suspend()
        {
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            std::cout << "final_suspend" << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always yield_value(int r)
        {
            _out = r;
            return {};
        }

        void return_void() // å³co_return ;
        {
        }

        // void return_value(std::string str) // å³co_return str;
        // {
        // }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h();
    // ret._h.resume(); ä¸ ret._h() ç­‰ä»·
    std::cout << "over" << std::endl;
    return 0;
}

// co_yieldç­‰ä»·äº co_await promise.yield_value(expr)
// åç¨‹å¦‚æœè°ƒç”¨äº†co_return åˆ™ ret._h.done()å°†ä¼šè¿”å›çœŸ

// CoFunction() next line
// coroutine message=hello
// final_suspend
// over
```

### std::suspend_neverçš„å®ç°

std::suspend_neveræ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_never
{
  constexpr bool await_ready() const noexcept { return true; } // ä¸æŒ‚èµ·co_waitç›´æ¥æ— æ•ˆç»§ç»­æ‰§è¡Œco_waitåé¢çš„ä»£ç 
  constexpr void await_suspend(coroutine_handle<>) const noexcept {}
  constexpr void await_resume() const noexcept {}
};
```

### std::suspend_alwaysçš„å®ç°

std::suspend_alwaysä¹Ÿæ˜¯ä¸€ä¸ªstdé»˜è®¤å®ç°çš„ä¸€ä¸ªawaitable

```cpp
struct suspend_always
{
  constexpr bool await_ready() const noexcept { return false; } // co_waitæ—¶ç›´æ¥æŒ‚èµ·ç„¶åè§¦å‘await_suspend ç„¶åç­‰å¾…resumeå†å›æ¥
  constexpr void await_suspend(coroutine_handle<>) const noexcept {} 
  constexpr void await_resume() const noexcept {}
};
```

### è¿›ä¸€æ­¥ç†Ÿæ‚‰æµç¨‹

è¿™é‡Œå¯ä»¥è¿›ä¸€æ­¥äº†è§£final_suspendçš„è¿”å›å€¼

```cpp
// main.cpp
// æµ‹è¯•gcc12.1å¯ä»¥ç¼–è¯‘é€šè¿‡ æµ‹è¯•æ”¯æŒæœ€ä½ç‰ˆæœ¬gcc11.1
#include <iostream>
#include <coroutine>
#include <string_view>

class CoMessage
{
public:
    std::string_view str;
};

// åç¨‹è¿”å›ç±»å‹
struct CoRet
{
    // åç¨‹è¿”å›ç±»å‹ä¸­éœ€è¦æœ‰ä¸€ä¸ªpromise_typeç±»å‹
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_always initial_suspend()
        {
            std::cout << "initial_suspend" << std::endl;
            return {};
        }

        // è¿”å›ç±»å‹ä¸ºawaitable
        std::suspend_never final_suspend() noexcept
        {
            // final_suspendè¿”å›å€¼å†³å®šäº†åç¨‹ä¼šä¸ä¼šè¢«destory å½“è¿”å›std::suspend_neveræ—¶final_suspendæ‰§è¡Œååç¨‹handleè¢«destory åœ¨è°ƒç”¨handle.done()è¿”å›0
            // å½“è¿”å›std::suspend_alwaysä¹Ÿå°±æ˜¯åç¨‹æœ€åæœ‰è¢«æŒ‚èµ·ï¼Œé‚£ä¹ˆhandle.done()ä¼šè¿”å›çœŸï¼Œè€Œä¸”å¦‚æœè¿”å›std::suspend_alwaysæˆ‘ä»¬æ˜¯éœ€è¦åœ¨å®ƒå¤„æ˜¾ç¤ºhandle.destory()
            std::cout << std::coroutine_handle<promise_type>::from_promise(*this).done() << std::endl;
            std::cout << "final_suspend" << std::endl;
            std::cout << "co_return " << _out << std::endl;
            return {};
        }

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void() // å³co_return ;
        // {
        // }

        void return_value(std::string_view str) // å³co_return str; å¯ä»¥å°†å†…å®¹é€šè¿‡co_returnå­˜åˆ°promiseä¸­
        {
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h; //_h.resume() æˆ– _h() åç¨‹ä¼šåœ¨è¢«æŒ‚èµ·çš„åœ°æ–¹æ¢å¤

    // ~CoRet()
    // {
    //     if (_h)
    //     {
    //         _h.destroy();
    //     }
    // }
};

// è‡ªå®šä¹‰awaitableç±»å‹
struct Awaitable
{
    CoMessage *_message;
    // å…¶è¿”å›å€¼å†³å®šco_waitæ—¶æ˜¯å¦è¢«æŒ‚èµ· trueä¸ºä¸æŒ‚èµ· falseä¸ºæŒ‚èµ·
    bool await_ready()
    {
        return false;
    }

    // åœ¨cowaitæ—¶è¦æŒ‚èµ· å³å°†è·³è½¬èµ°ä¹‹å‰è¢«æ‰§è¡Œ è¿”å›å€¼ä¸ºvoidåˆ™è·³è½¬åˆ°è¢«è°ƒç”¨å¤„
    // ä¹Ÿå¯ä»¥è¿”å›å…¶ä»–std::coroutine_handleæ‰§è¡Œè¦è·³è½¬åˆ°çš„ä½ç½®
    void await_suspend(std::coroutine_handle<CoRet::promise_type> h)
    {
        _message = &h.promise()._message;
    }

    // co_waitæ—¶çš„è¿”å›å€¼
    CoMessage await_resume()
    {
        return *_message;
    }
};

CoRet CoFunction()
{
    // åç¨‹å¼€å§‹è¢«è°ƒåº¦æ—¶å°±ä¼šéšå¼åˆ›å»ºä¸€ä¸ªè¿”å›ç±»å‹ä¸­çš„promise_typeå¯¹è±¡
    // åˆ›å»ºçš„è¿™ä¸ªpromise_typeå¯¹è±¡å°±ä¼šæ§åˆ¶åç¨‹çš„è¿è¡Œä»¥åŠå†…å¤–çš„æ•°æ®äº¤æ¢
    // CoRet::promise_type promise;
    // CoRet coRet = promise.get_return_object(); å³åç¨‹çš„è¿”å›å€¼
    // ç„¶åä¼šè¿›è¡Œ co_await promise.initial_suspend()

    // è€Œgcc12.1ä»¥ä¸Šå¯ä»¥è¿™æ ·å†™
    // Awaitable awaitable;
    // CoMessage message = co_await awaitable; // ä»awaitable.await_resume()è¿”å›çš„
    // ä¸ç„¶è¦è¿™æ ·å†™
    CoMessage message = co_await Awaitable();

    std::cout << "coroutine message=" << message.str << std::endl;

    co_return "888888"; // è°ƒç”¨promiseçš„return_voidæˆ–return_value
    // æœ€åä¼šè¿›è¡Œ co_await promise.final_suspend()
}

int main(int argc, char **argv)
{
    std::cout << "start main" << std::endl;
    CoRet ret = CoFunction();
    std::cout << "CoFunction() next line" << std::endl;
    ret._h(); // å›åˆ° co_await promise.initial_suspend()
    // ä»co_await Awaitable()è·³è¿‡æ¥äº†
    std::cout << "=>" << ret._h.done() << std::endl; // 0

    ret._h.promise()._message.str = "hello"; // å†™åˆ°åç¨‹çš„promiseå¯¹è±¡ä¸­
    ret._h.resume();                         // å›åˆ°co_await Awaitable();
    std::cout << "over" << std::endl;
    std::cout << ret._h.done() << std::endl; // 0
    std::cout << ret._h.promise()._out << std::endl; // 888888
    // åç¨‹ç»“æŸåä¸èƒ½åœ¨è¢«resumeäº†

    return 0;
}
// ret._h.destory()å¯ä»¥æå‰é”€æ¯åç¨‹handle

// start main
// initial_suspend
// CoFunction() next line
// =>0
// coroutine message=hello
// 1
// final_suspend
// co_return 888888
// over
// 0
// 888888
```

### ç®€å•ç†è§£åç¨‹è°ƒåº¦

ä»è¿™ä¸ªä¾‹å­ä¸­å…¶å®å¯ä»¥çœ‹ å…¶å®åç¨‹å¯ä»¥çœ‹æˆä»»åŠ¡çŠ¶æ€æœºï¼Œé€šè¿‡promiseä¸coroutine_handleä¸å¤–ç•Œäº¤äº’
åªä¸è¿‡æœ€å¤§ä¼˜åŠ¿å°±æ˜¯ å¯ä»¥è‡ªåŠ¨ç»´æŒä¸Šä¸‹æ–‡ï¼ŒçŠ¶æ€æœºæŒ‚èµ·çš„æ—¶å€™ï¼Œå¯ä»¥è‡ªåŠ¨å›åˆ°è§¦å‘çŠ¶æ€æœºçš„åœ°æ–¹å³è°ƒç”¨resume()çš„åœ°æ–¹ã€‚

è¿™ä¹ˆä¸€æ¥åƒåšæœåŠ¡å™¨çš„æœ‰ä»€ä¹ˆæ‰“çš„ä¼˜åŠ¿ï¼Œå…¶å®å°±æ˜¯epoll+åç¨‹+éé˜»å¡IOï¼Œè€Œä¸”å¯ä»¥åšåˆ°å•çº¿ç¨‹å¹¶å‘
ä¾‹å¦‚epoll æ¥äº†æ–°è¿æ¥ åˆ™ä¸ºæ–°è¿æ¥åˆ›å»ºåç¨‹ï¼Œepollç›‘å¬è¿æ¥å¥—æ¥å­—å¯è¯»æ—¶ å¯ä»¥å‘promiseä¸­æ ‡è®° ä½ å¯ä»¥è¯»äº† æˆ–è€… å¯ä»¥å†™äº†ã€‚ç„¶åè¿›è¡Œresume() æ¯ä¸ªåç¨‹å†…éƒ¨å…¶å®å°±æ˜¯æ­»å¾ªç¯ read process writeä¹‹ç±»çš„ç›¸å…³æ“ä½œï¼Œè¦æš‚æ—¶ä¸å¤„ç†äº†æ¯”å¦‚EAGAINäº†ï¼Œå®Œå…¨å¯ä»¥co_waitå‡ºå»å›åˆ°åŸæ¥è¦æ‰§è¡Œçš„åœ°æ–¹ï¼Œå¯èƒ½ä¼šå¤„ç†ä¸‹ä¸€ä¸ªåç¨‹ï¼Œè¿™ä¹ˆä¸€æ¥å¯ä»¥å‘ç° C++åç¨‹æ›´åƒæ˜¯ä¸€ç§çŠ¶æ€æœºçš„è¯­æ³•ç³–ä¸€æ ·çš„æ„Ÿè§‰ï¼Œè€Œä¸”å¾ˆå®¹æ˜“å›´ç»•éé˜»å¡IOå»åš
ä¸€äº›å¼‚æ­¥ä»»åŠ¡ï¼Œè€Œä¸”å®Œå…¨å¯ä»¥å•çº¿ç¨‹ï¼Œå®‰å…¨å¥½ç”¨ç®€å•ï¼Œåœ¨å¿…è¦çš„æ—¶å€™è¿›è¡Œresumeè§¦å‘æ‰§è¡Œï¼Œåç¨‹ä¹Ÿæœ‰è‡ªçŸ¥ä¹‹æ˜ è‡ªå·±ä¼šco_wait co_yield co_returnä¸ä¼šè¿›è¡Œé˜»å¡ ä¸æ˜¯åœ¨è¿è¡Œå°±æ˜¯åœ¨æŒ‚èµ·ç­‰å¾…è¢«resume è¿™æ‰æ˜¯å…³é”®ä¸ç²¾é«“ã€‚

```cpp

#include <coroutine>
#include <future>
#include <thread>
#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>


using namespace std;

struct CoRet
{
    struct promise_type
    {
        int _in;
        int _out;
        int _res;
        suspend_never initial_suspend() {return {};}
        suspend_always final_suspend() noexcept {return {};}
        void unhandled_exception() {}
        CoRet get_return_object()
        { return 
            {coroutine_handle<promise_type>::from_promise(*this)};
        }
        suspend_always yield_value(int r) {
            _out = r;
            return {};
        }
        void return_value(int r) {
            _res = r;
        }
    };

    coroutine_handle<promise_type> _h; // _h.resume(), _h()
};

struct Input
{
    int* _in;
    int* _out;
    bool await_ready() { return false; }
    void await_suspend(coroutine_handle<CoRet::promise_type> h) 
    { _in = &h.promise()._in; _out = &h.promise()._out; }
    int await_resume() { return *_in; }
};

// åç¨‹
CoRet Guess() {
    // co_await promise.initial_suspend();
    int res = (rand()%30)+1;
    Input input;
    int numGuess = 0;
    while(true)
    {
        int g = co_await input;
        
        ++numGuess;
        (*input._out) = (res>g ? 1: (res == g? 0 : -1));
        if((*input._out) == 0) co_return numGuess;
    }    
    // co_await promise.final_suspend();...
}



struct Hasher
{
    size_t operator() (const pair<int, int>& p) const
    {
        return (size_t)(p.first << 8) + (size_t)(p.second); 
    }
};
int main()
{
    srand(time(nullptr));

    unordered_map<pair<int, int>, vector<CoRet>, Hasher> buckets;
    for(auto i = 0; i<100; ++i) buckets[make_pair(1, 30)].push_back(Guess());

    while(!buckets.empty())
    {
        auto it = buckets.begin();
        auto& range = it->first;//1
        auto& handles = it->second;//vector<CoRet>å­˜æ”¾åç¨‹
                
        int g = (range.first+range.second)/2;//ä¸­é—´æ•°
        auto ur = make_pair(g+1, range.second);//å³è¾¹éƒ¨åˆ†
        auto lr = make_pair(range.first, g-1);//å·¦è¾¹éƒ¨åˆ†

        vector<future<int>> cmp;
        cmp.reserve(handles.size());

        // è¿™ä¸ªå¾ªç¯æ˜¯éé˜»å¡çš„éå¸¸å¿«
        for(auto& coret : handles)
        {
            // ä¸ºæ¯ä¸ªä»»åŠ¡å»å¼€çº¿ç¨‹ å»æ‰§è¡Œåç¨‹
            cmp.push_back(async(launch::async, [&coret, g]() { // åˆ¤æ–­ä¸­é—´æ•°
                coret._h.promise()._in = g;
                coret._h.resume(); // åç¨‹å†…éƒ¨é‡è§co_wait co_yieldä¼šè¿”å›æ¥               
                return coret._h.promise()._out;
            }));
            // è·å¾—è®¸å¤šfuture å³lamdaè¿”å›å€¼å‘æ¡ä»¶å˜é‡ä¸€æ ·
        }

        // éå†æ‰€æœ‰åç¨‹ï¼Œå‰é¢å·²ç»è®©åç¨‹å»å¼‚æ­¥è¿è¡Œäº†
        for(int i=0; i< handles.size(); ++i)
        {
            int r = cmp[i].get(); // ç­‰å¾…futureè¿”å›å€¼è¿™é‡Œæ˜¯é˜»å¡çš„ åªæœ‰ç›¸åº”åç¨‹è¢«resume lamdaè¿”å›æ‰å¯ä»¥get()è¿”å›
            
            if(r == 0) {//çŒœå¯¹äº†
                cout << "The secret number is " << handles[i]._h.promise()._in
                << ", total # guesses is " << handles[i]._h.promise()._res
                << endl;
            }            
            else if (r == 1) buckets[ur].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å³è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
            else buckets[lr].push_back(handles[i]);//å°†åç¨‹ç§»åˆ°å·¦è¾¹éƒ¨åˆ†å»æ‰§è¡Œ
        }
        buckets.erase(it);//åˆ é™¤åŸæ¥èŒƒå›´çš„ï¼ŒçŒœä¸­äº†çš„ä¸ç”¨å†çŒœåç¨‹ä¸­çš„æ•°å­—äº†ï¼Œå‰©ä½™åç¨‹ä¸æ˜¯å»å·¦è¾¹å°±æ˜¯å³è¾¹
    }

/*
    auto ret = Guess();
    pair<int, int> range = {1,30};    
    int in, out;
    do
    {
        in = (range.first+range.second)/2;
        ret._h.promise()._in = in; 
        cout << "main: make a guess: " << ret._h.promise()._in << endl;

        ret._h.resume(); // resume from co_await

        out = ret._h.promise()._out;
        cout << "main: result is " << 
        ((out == 1) ? "larger" :
        ((out == 0) ? "the same" : "smaller"))
            << endl;
        if(out == 1) range.first = in+1;
        else if(out == -1) range.second = in-1;
    }
    while(out != 0);
*/
}
```

### ä¸åŒçº¿ç¨‹resumeåŒä¸€ä¸ªåç¨‹

ä¸€ä¸ªçº¿ç¨‹ç¨‹å°†ä¸€ä¸ªåç¨‹è¿è¡Œåˆ°æŸä¸ªä½ç½® ç„¶ååç¨‹æŒ‚èµ·äº†ã€‚
å®Œå…¨å¯ä»¥ä½¿ç”¨å…¶ä»–çº¿ç¨‹ ç»§ç»­å®Œæˆåç¨‹ã€‚
è°è¿›è¡Œresumeè°å°±æ‰§è¡Œåç¨‹ è€Œä¸”resumeå†…éƒ¨è¿˜å¯èƒ½è§¦å‘å¦ä¸€ä¸ªåç¨‹handleçš„resumeã€‚
è¿™é‡Œå°±å‘ç°äº†ï¼Œå…¶å®resumeéœ€è¦ä¿è¯çº¿ç¨‹å®‰å…¨ï¼Œé€šè¿‡ä¸€ä¸ªæŒ‚èµ·çš„åç¨‹handleè¢«å¤šä¸ªçº¿ç¨‹åŒæ—¶handle,ä¼šå‡ºç°é—®é¢˜çš„ã€‚
C++åç¨‹æ˜¯æ— æ ˆåç¨‹ å…¶åç¨‹frameå­˜æ”¾åœ¨å †ä¸Š è€Œä¸”æ˜¯å¯¹ç§°çš„åç¨‹ ä¹Ÿå°±æ˜¯åç¨‹ä¹‹é—´åœ°ä½æ˜¯å¹³ç­‰çš„ ä¸€ä¸ªåç¨‹å¯ä»¥éšä¾¿
è·³åˆ°å…¶ä»–åç¨‹ å“ªæ€•åœ¨ä¸¤ä¸ªåç¨‹è§åå¤æ¨ªè·³éƒ½æ²¡é—®é¢˜ ä½†æ˜¯å¦‚æœæˆ‘ä»¬ç”¨ä¸€èµ·çš„å‡½æ•°è°ƒç”¨ è¿™æ ·loopå¤šäº†å°±ä¼šæ ˆæº¢å‡ºäº†
è€Œæ— æ ˆåç¨‹ä¸ä¼šï¼Œåªæ˜¯åœ¨ä¸¤ä¸ªçŠ¶æ€æœºä¹‹é—´åˆ‡æ¢è·³è½¬ã€‚

```cpp
#include <iostream>
#include <coroutine>
#include <string_view>
#include <thread>
#include <future>

class CoMessage
{
public:
    std::string_view str;
};

struct Awaitable;

struct CoRet
{
    struct promise_type
    {
        CoMessage _message;
        std::string_view _out;

        std::suspend_always initial_suspend()
        {
            std::cout << "3=>" << std::this_thread::get_id() << std::endl;
            return {};
        }

        std::suspend_never final_suspend() noexcept;

        void unhandled_exception()
        {
        }

        CoRet get_return_object()
        {
            std::cout << "4=>" << std::this_thread::get_id() << std::endl;
            return {std::coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_never yield_value(std::string_view r)
        {
            _out = r;
            return {};
        }

        // void return_void()
        // {
        // }

        void return_value(std::string_view str)
        {
            std::cout << "5=>" << std::this_thread::get_id() << std::endl;
            _out = str;
        }
    };

    std::coroutine_handle<promise_type> _h;
};

struct Awaitable
{
    CoMessage *_message;
    bool await_ready() noexcept
    {
        return false;
    }

    void await_suspend(std::coroutine_handle<CoRet::promise_type> h) noexcept
    {
        _message = &h.promise()._message;
    }

    CoMessage await_resume() noexcept
    {
        std::cout << "6=>" << std::this_thread::get_id() << std::endl;
        return *_message;
    }
};

std::suspend_never CoRet::promise_type::final_suspend() noexcept
{
    std::cout << "7=>" << std::this_thread::get_id() << std::endl;
    return {};
}

CoRet CoFunction()
{
    std::cout << "2=>" << std::this_thread::get_id() << std::endl;
    CoMessage message1 = co_await Awaitable();
    CoMessage message2 = co_await Awaitable();
    CoMessage message3 = co_await Awaitable();
    co_return "888888";
}

int main(int argc, char **argv)
{
    std::cout << "1=>" << std::this_thread::get_id() << std::endl;
    CoRet ret = CoFunction();
    ret._h();
    ret._h.promise()._message.str = "hello";
    ret._h.resume();
    // å¼€æ–°çº¿ç¨‹å»å¤„ç†åç¨‹
    std::future<int> fu = std::async(
        [&]
        {
            ret._h.resume();
            ret._h.resume();
            return 999;
        });
    fu.get(); // ç­‰å¾…å¼‚æ­¥ä»»åŠ¡
    return 0;
}

// 1=>140087387162432
// 4=>140087387162432
// 3=>140087387162432
// 2=>140087387162432
// 6=>140087387162432
// 6=>140087383815744
// 6=>140087383815744
// 5=>140087383815744
// 7=>140087383815744
```

### Cé£æ ¼æ­ç§˜åç¨‹

CppCon 2016 C++ Coroutines Under the Covers

Coroutines In C

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
int main()
{
    void* coro = f(1);
    for(int i = 0; i < 4; ++i)
    {
        CORO_RESUME(coro);
    }
    CORO_DESTROY(coro);
}
// è¾“å‡º 1,-1,2,-2

define i32 @main()
{
    call void @print(i32 1)
    call void @print(i32 -1)
    call void @print(i32 2)
    call void @print(i32 -2)
    ret i32 0
}
```

å¦‚ä½•å»ºç«‹åç¨‹çš„å¸§ Build Coroutine Frame

```cpp
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    for(int i = n;; ++i)
    {
        CORO_SUSPEND(hdl);
        print(i);
        CORO_SUSPEND(hdl);
        print(-i);
    }
    CORO_END(hdl, free);
}
// åªéœ€è¦è®°å½•å£°æ˜å‘¨æœŸè·¨è¶ŠCORO_SUSPENDçš„
struct f.frame {
    int i;
};
```

è§£å¯†åˆ›å»ºåç¨‹å¸§

```cpp
struct f.frame {
    int i;
}
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        CORO_SUSPEND(hdl);
        print(frame->i);
        CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

è§£å¯†åˆ›å»ºè·³è·ƒç‚¹ Create Jump Pointsï¼Œåƒæ¸¸æˆå­˜æ¡£ä¸€æ ·

```cpp
struct f.frame
{
    int suspend_index;
    int i;
};
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    for(frame->i = n;; ++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

èƒŒåå¯ä»¥åˆ†ä¸ºä¸‰éƒ¨åˆ†

```cpp
// Coroutine Start Function
void* f(int n)
{
    void* hdl = CORO_BEGIN(malloc);
    //...
    return hdl;
}
// Coroutine Resume Function
void f.resume(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
}
// Coroutine Destroy Function
void f.destroy(f.frame* frame)
{
    switch(frame->suspend_index)
    {
        //...
    }
    free(frame);
}
```

å‡è®¾ç¼–è¯‘å™¨ç”Ÿæˆçš„f.resume

```cpp
void f.resume(f.frame* frame)
{
    switch (frame->suspend_index)
    {
        case 0: goto r0;
        default: goto r1;
    }
    for(frame->i = n;;++frame->i)
    {
        frame->suspend_index = 0;
r0:     CORO_SUSPEND(hdl);
        print(frame->i);
        frame->suspend_index = 1;
r1:     CORO_SUSPEND(hdl);
        print(-frame->i);
    }
    CORO_END(hdl, free);
}
```

After CleanUp

```cpp
void* f(int* n)
{
// è¿›ä¸€æ­¥æŠ½è±¡
    void* hdl = CORO_BEGIN(malloc);
    f.frame* frame = (f.frame*)hdl;
    frame->ResumeFn = &f.resume;
    frame->DestroyFn = &f.destroy;
    frame->i = n;
    frame->suspend_index = 0;
    return coro_hdl;
}
void f.destroy(f.frame* frame)
{
    free(frame);
}
void f.cleanup(f.frame* frame){}
void f.resume(f.frame* frame)
{
    if(frame->index == 0)
    {
        print(frame->i);
        frame->suspend_index = 1;
    }
    else
    {
        print(-frame->i);
        ++frame->i;
        frame->suspend_index = 0;
    }
}
struct f.frame
{
    FnPtr ResumeFn;
    FnPtr DestroyFn;
    int suspend_index;
    int i;
};
```

### std::noop_coroutine

std::noop_coroutine() æ˜¯ C++20 ä¸­å¼•å…¥çš„ä¸€ä¸ªå‡½æ•°ï¼Œä½äº <coroutine> å¤´æ–‡ä»¶ä¸­ã€‚å®ƒæ˜¯ä¸€ä¸ªç©ºçš„åç¨‹ï¼ˆcoroutineï¼‰ï¼Œç”¨ä½œåç¨‹ï¼ˆcoroutineï¼‰çš„å ä½ç¬¦æˆ–è€…ç©ºæ“ä½œã€‚

### å°½å¯èƒ½ç”¨åç¨‹æ›¿ä»£std::futureä¸std::promise

å› ä¸ºfutureå’Œpromise éœ€è¦åˆ†é…å†…å­˜ åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡ç­‰ï¼Œå¼€é”€æ¯”è¾ƒå¤§ã€‚ä¾‹å¦‚ï¼Œå‡è®¾åœ¨æŸäº›ä»£ç ä¸­éœ€è¦ä¼ é€’ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œä½†æ˜¯å®é™…ä¸Šä¸éœ€è¦æ‰§è¡Œè¯¥åç¨‹ï¼Œè¿™æ—¶å°±å¯ä»¥ä½¿ç”¨ std::noop_coroutine() æ¥ä»£æ›¿ï¼Œä»¥è¾¾åˆ°å ä½çš„ç›®çš„ã€‚

![futureä¸promise](../.gitbook/assets/2024-03-30172542.png)

å¯ä»¥å…å»é¢å¤–çš„å†…å­˜ç”³è¯· åŸå­æ“ä½œ äº’æ–¥é” æ¡ä»¶å˜é‡çš„å¼€é”€

ä¸‹é¢ä»£ç æ•´ä½“ç»è¿‡æµç¨‹

1. åˆ›å»ºç‹å­åç¨‹ suspend_alwaysã€‚
2. åˆ›å»ºå…¬ä¸»åç¨‹ suspend_alwaysã€‚  
3. å°†å…¬ä¸»åç¨‹èµ‹å€¼åˆ°ç‹å­åç¨‹çš„promise _nextä¸Šå»
4. å…¬ä¸»åç¨‹å»co_awaitç‹å­
5. è¿›è€Œè§¦å‘ç‹å­çš„await_suspend åœ¨å…¶ä¸­è¿›è¡Œstd::asyncå¯¹ç‹å­è¿›è¡Œresume
ç‹å­ std::this_thread::sleep_for(500ms); ç„¶åco_returnå°†é‡‘å¸èµ‹å€¼åˆ°äº†promiseä¸Š
æœ€ååˆ©ç”¨ç‹å­ final_suspend è¿”å›ä¸€ä¸ªawaiter await_readyè¿”å›false è§¦å‘ await_suspend è¿”å›å€¼ å†³å®šè·³å¾€å“ªé‡Œç‹å­çš„æœ‰_nextåˆ™è·³å¾€å…¬ä¸»çš„int c = co_await future; å¾—åˆ°äº†ç‹å­co_returnçš„é‡‘å¸é‡ã€‚  
6. æœ€åå…¬ä¸»ä¹Ÿco_returnäº†ï¼Œå…¶è¿”å›awaiterçš„await_readyè¿”å›false,å…¬ä¸»åç¨‹è¢«doneäº†æ ‡è®°ä¸º1ï¼Œè€Œä¸”awaiter await_suspendè¿”å›ç©ºåç¨‹ï¼Œæœ€åæˆ‘ä»¬asyncåˆ›å»ºçš„åç¨‹å…¶å®ç»“æŸäº†,ä¸»çº¿ç¨‹ä¸€ç›´å¾ªç¯æ£€æŸ¥å…¬ä¸»done,æ­¤æ—¶å…¬ä¸»doneäº†ï¼Œä¸€åˆ‡éƒ½ç»“æŸäº†ã€‚

```cpp
#include <iostream>
#include <chrono>
#include <future>
#include <thread>
#include <coroutine>
using namespace std;

struct Task
{
    struct promise_type
    {
        int _result;
        coroutine_handle<> _next = nullptr;

        Task get_return_object()
        {
            return Task{coroutine_handle<promise_type>::from_promise(*this)};
        }

        std::suspend_always initial_suspend()
        {
            return {};
        }

        // åç¨‹ç»“æŸæ—¶ ç‹å­ç»“æŸæ—¶åˆ©ç”¨æœ€åçš„co_wait final_suspend() åˆ©ç”¨final_suspendè¿”å›å€¼è¿è¡Œå…¬ä¸»åç¨‹
        auto final_suspend() noexcept
        {
            struct next_awaiter
            {
                promise_type *me;
                bool await_ready() noexcept
                {
                    return false;
                }
                coroutine_handle<> await_suspend(coroutine_handle<promise_type> h) noexcept
                {
                    // è·³åˆ°å“ªé‡Œ
                    if (h.promise()._next)
                    {
                        return h.promise()._next; // æœ‰å…¬ä¸»å°±è·³åˆ°å…¬ä¸»æŒ‚èµ·å“ªé‡Œ
                    }
                    else
                    {
                        return std::noop_coroutine();
                    }
                }
                void await_resume() noexcept
                {
                }
            };
            return next_awaiter{this};
        }

        void return_value(int i) { _result = i; }
        void unhandled_exception() {}
    };

    using handle = coroutine_handle<promise_type>;
    handle _h;
    std::future<void> _t;

    // awaiter
    bool await_ready()
    {
        return false;
    }
    void await_suspend(handle h)
    {
        _h.promise()._next = h;
        _t = std::async(
            [&]()
            {
                _h.resume();
            });
    }
    int await_resume()
    {
        return _h.promise()._result;
    }
};

Task Prince()
{
    int coins = 1;
    std::this_thread::sleep_for(500ms);
    std::cout << std::this_thread::get_id() << "Prince - found treasure!" << std::endl;
    co_return coins;
}

Task Princess(Task &future)
{
    std::cout << std::this_thread::get_id() << "Princess - wait for Prince" << std::endl;
    int c = co_await future; // è§¦å‘Princeçš„await_suspend æŠŠå…¬ä¸»åç¨‹æŒ‚åˆ°ç‹å­çš„promiseçš„next ç„¶åå¼€ä¸€ä¸ªçº¿ç¨‹å»resumeç‹å­
    std::cout << std::this_thread::get_id() << "Princess - got" << c << " coins." << std::endl;
    co_return 0;
}

int main(int argc, char **argv)
{
    auto prince = Prince();           // åˆ›å»ºç‹å­åç¨‹
    auto princess = Princess(prince); // åˆ›å»ºå…¬ä¸»åç¨‹
    princess._h.resume();             // ä¼šæ‰§è¡Œåˆ°co_wait futureè¿”å›

    while (!princess._h.done())
    {
        cout << std::this_thread::get_id() << " main wait ...\n";
        std::this_thread::sleep_for(100ms);
    }
    std::cout << std::this_thread::get_id() << " main: done" << std::endl;
    return 0;
}

/*
140521947157440Princess - wait for Prince
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947157440 main wait ...
140521947141696Prince - found treasure!
140521947141696Princess - got1 coins.
140521947157440 main: done
*/
```

### ç”¨åç¨‹å†™ä¸ªç®€å•çš„å¹¶å‘server(å¾…æ”¹è¿›å¾…å‹˜è¯¯)

main.cpp

```cpp
#include <iostream>
#include <coroutine>
#include <sys/epoll.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>
#include <vector>

constexpr int PORT = 20023;
constexpr int MAX_EVENTS = 100000;

int epoll_fd;

class Task
{
public:
    struct promise_type
    {
        Task get_return_object()
        {
            return Task{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_never initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        void return_void() {}
        void unhandled_exception()
        {
            std::cout << "unhandled_exception" << std::endl;
            std::terminate();
        }
    };

    Task(std::coroutine_handle<promise_type> h) : coro_handle(h) {}
    ~Task()
    {
        std::cout << "~Task" << std::endl;
        // if (coro_handle)
        //     coro_handle.destroy();
    }

    std::coroutine_handle<promise_type> coro_handle;
};

class SocketAwaiter
{
public:
    SocketAwaiter(int fd, uint32_t events) : fd(fd), events(events) {}

    bool await_ready() const noexcept { return false; }
    void await_suspend(std::coroutine_handle<> h)
    {
        epoll_event event;
        event.data.ptr = static_cast<void *>(h.address());
        event.events = events | EPOLLONESHOT;
        epoll_ctl(epoll_fd, EPOLL_CTL_MOD, fd, &event);
    }
    void await_resume() noexcept {}

private:
    int fd;
    uint32_t events;
};

void set_non_blocking(int fd)
{
    int flags = fcntl(fd, F_GETFL, 0);
    fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

Task handle_client(int client_socket)
{
    std::cout << "handle_client(" << client_socket << ")" << std::endl;

    char buffer[1024];
    std::string send_buffer;
    bool closed = false;

    while (true)
    {
        if (closed)
        {
            break;
        }
        // ç­‰å¾…å¯è¯»äº‹ä»¶
        SocketAwaiter read_awaiter{client_socket, EPOLLIN};
        co_await read_awaiter;

        int bytes_read = recv(client_socket, buffer, sizeof(buffer), 0);
        if (bytes_read == 0)
        {
            epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_socket, nullptr);
            close(client_socket);
            closed = true;
            break;
        }

        if (bytes_read < 0)
        {
            if (errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)
            {
                epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_socket, nullptr);
                close(client_socket);
                closed = true;
                break;
            }
        }

        // å°†æ”¶åˆ°çš„æ•°æ®åŠ å…¥å‘é€ç¼“å†²åŒº
        if (bytes_read > 0)
        {
            std::cout << "bytes_read " << bytes_read << std::endl;
            send_buffer.append(buffer, bytes_read);
        }

        // å½“æœ‰æ•°æ®éœ€è¦å‘é€æ—¶ï¼Œè¿›å…¥å‘é€é€»è¾‘
        while (!send_buffer.empty())
        {
            // ç­‰å¾…å¯å†™äº‹ä»¶
            SocketAwaiter write_awaiter{client_socket, EPOLLOUT};
            co_await write_awaiter;

            int bytes_sent = send(client_socket, send_buffer.c_str(), send_buffer.size(), 0);

            if (bytes_sent == 0)
            {
                std::cerr << "Send error" << std::endl;
                epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_socket, nullptr);
                close(client_socket);
                closed = true;
                break;
            }

            if (bytes_sent < 0)
            {
                if (errno != EAGAIN && errno != EWOULDBLOCK && errno != EINTR)
                {
                    epoll_ctl(epoll_fd, EPOLL_CTL_DEL, client_socket, nullptr);
                    close(client_socket);
                    closed = true;
                    break;
                }
                else
                {
                    continue;
                }
            }

            // åˆ é™¤å·²ç»å‘é€çš„æ•°æ®
            if (bytes_sent > 0)
            {
                send_buffer.erase(0, bytes_sent);
            }
        }
    }
}

Task server()
{
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd == 0)
    {
        std::cerr << "Socket creation failed\n";
        co_return; // ä½¿ç”¨ co_return æ¥è¿”å› Task
    }

    set_non_blocking(server_fd);

    sockaddr_in address;
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = INADDR_ANY;
    address.sin_port = htons(PORT);

    if (bind(server_fd, (sockaddr *)&address, sizeof(address)) < 0)
    {
        std::cerr << "Bind failed\n";
        co_return; // ä½¿ç”¨ co_return æ¥è¿”å› Task
    }

    if (listen(server_fd, 3) < 0)
    {
        std::cerr << "Listen failed\n";
        co_return; // ä½¿ç”¨ co_return æ¥è¿”å› Task
    }

    epoll_fd = epoll_create1(0);
    if (epoll_fd == -1)
    {
        std::cerr << "Epoll creation failed\n";
        co_return; // ä½¿ç”¨ co_return æ¥è¿”å› Task
    }

    epoll_event event;
    event.data.fd = server_fd;
    event.events = EPOLLIN;
    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, server_fd, &event);

    std::vector<epoll_event> events(MAX_EVENTS);

    while (true)
    {
        int n = epoll_wait(epoll_fd, events.data(), MAX_EVENTS, -1);
        for (int i = 0; i < n; i++)
        {
            if (events[i].data.fd == server_fd)
            {
                int client_socket = accept(server_fd, nullptr, nullptr);
                if (client_socket >= 0)
                {
                    std::cout << "new client_socket " << client_socket << std::endl;
                    set_non_blocking(client_socket);
                    epoll_event client_event;
                    client_event.data.fd = client_socket;
                    client_event.events = EPOLLIN | EPOLLET;
                    epoll_ctl(epoll_fd, EPOLL_CTL_ADD, client_socket, &client_event);
                    auto handle = handle_client(client_socket).coro_handle;
                    handle.resume();
                }
                std::cout << "handle_client(client_socket).coro_handle.resume() over" << std::endl;
            }
            else
            {
                std::cout << "event client " << reinterpret_cast<uint64_t>(events[i].data.ptr) << std::endl;
                auto handle = std::coroutine_handle<>::from_address(events[i].data.ptr);
                if (handle.done())
                {
                    std::cout << "handle done" << std::endl;
                }
                else
                {
                    handle.resume();
                }
                if (handle.done())
                {
                    std::cout << "handle done" << std::endl;
                    handle.destroy();
                }
            }
        }
    }

    close(server_fd);
    close(epoll_fd);
}

int main()
{
    server().coro_handle.resume();
    return 0;
}
```

CMakeLists.txt

```cpp
# è®¾ç½®æœ€ä½ CMake ç‰ˆæœ¬è¦æ±‚
cmake_minimum_required(VERSION 2.8.12.2)

# è®¾ç½®é¡¹ç›®åç§°å’Œç‰ˆæœ¬
project(main.exe)

# æŒ‡å®š C++ ç¼–è¯‘å™¨è·¯å¾„
set(CMAKE_CXX_COMPILER "/opt/rh/devtoolset-11/root/usr/bin/g++")
set(CMAKE_C_COMPILER "/opt/rh/devtoolset-11/root/usr/bin/gcc")

# è®¾ç½® C++ æ ‡å‡†
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED True)

# æŸ¥æ‰¾å½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰æºæ–‡ä»¶
file(GLOB SOURCES "*.cpp")

# æŸ¥æ‰¾å½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰å¤´æ–‡ä»¶
file(GLOB HEADERS "*.h")

# æ·»åŠ å¯æ‰§è¡Œæ–‡ä»¶ï¼Œå‡è®¾è¦ç”Ÿæˆçš„å¯æ‰§è¡Œæ–‡ä»¶åä¸º MyExecutable
add_executable(main.exe ${SOURCES} ${HEADERS})

target_compile_options(main.exe PRIVATE -fcoroutines)

# å¦‚æœéœ€è¦é“¾æ¥åº“ï¼Œå¯ä»¥ä½¿ç”¨ target_link_libraries å‡½æ•°
target_link_libraries(main.exe PRIVATE pthread)
```

## C++20å…³äºconstexprçš„ä¼˜åŒ–

### å…è®¸constexprè™šå‡½æ•°

åœ¨C++20æ ‡å‡†å‰ï¼Œè™šå‡½æ•°æ˜¯ä¸å…è®¸å£°æ˜ä¸ºconstexprçš„ã€‚å¾ˆå¤šæ—¶å€™è™šå‡½æ•°æ˜¯æ— çŠ¶æ€çš„ï¼Œè¿™ç§æƒ…å†µä¸‹æ˜¯æœ‰æ¡ä»¶ä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¢«ä¼˜åŒ–çš„ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    virtual int f() const { return 1; }
};

int main(int argc, char **argv)
{
    X x;
    int i = x.f();
    return 0;
}
```

å¦‚æœä½œä¸ºå¸¸é‡è¡¨è¾¾å¼è¿›è¡Œä¼˜åŒ–ï¼Œåˆ™å¯ä»¥å‡å°‘å‡½æ•°è°ƒç”¨ã€‚å¯æƒœåœ¨C++17æ ‡å‡†ä¸­ä¸å…è®¸æˆ‘ä»¬è¿™ä¹ˆåšï¼Œç›´åˆ°C++20æ ‡å‡†æ˜ç¡®å…è®¸åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨è™šå‡½æ•°ï¼Œæ‰€ä»¥ä¸Šé¢çš„ä»£ç å¯ä»¥ä¿®æ”¹ä¸ºï¼š

```cpp
#include <iostream>
using namespace std;

struct X
{
    constexpr virtual int f() const
    {
        int res = 999;
        return res;
    }
};

int main(int argc, char **argv)
{
    X x;
    constexpr int i = x.f();
    // æ­¤å¤„ç­‰ä»·äº
    // constexpr int i = 999;
    std::cout << i << std::endl; // 999
    return 0;
}
```

constexprè™šå‡½æ•°åœ¨ç»§æ‰¿é‡å†™ä¸Šå¹¶æ²¡æœ‰å…¶ä»–ç‰¹æ®Šçš„è¦æ±‚ï¼Œconstexprçš„è™šå‡½æ•°å¯ä»¥è¦†ç›–é‡å†™æ™®é€šè™šå‡½æ•°ï¼Œæ™®é€šè™šå‡½æ•°ä¹Ÿå¯ä»¥è¦†ç›–é‡å†™constexprçš„è™šå‡½æ•°ã€‚

```cpp
#include <iostream>
using namespace std;

struct X1
{
    virtual int f() const = 0;
};

struct X2 : public X1
{
    constexpr virtual int f() const { return 2; }
};

struct X3 : public X2
{
    constexpr virtual int f() const { return 4; }
};

struct X4 : public X3
{
    virtual int f() const { return 5; }
};

constexpr int (X1::*pf)() const = &X1::f;

constexpr X2 x2;
static_assert(x2.f() == 2);
static_assert((x2.*pf)() == 2);

constexpr X1 const &r2 = x2;
static_assert(r2.f() == 2);
static_assert((r2.*pf)() == 2);

constexpr const X1 *p2 = &x2;
static_assert(p2->f() == 2);
static_assert((p2->*pf)() == 2);

constexpr X3 x3;
static_assert(x3.f() == 4);

constexpr X4 x4;
// static_assert(x4.f() == 5); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr
constexpr const X1 *p4 = &x4;
// static_assert(p4->f() == 4); // ç¼–è¯‘é”™è¯¯ X4::f ä¸æ˜¯constexpr

int main(int argc, char **argv)
{
    return 0;
}
```

æ€»ä¹‹å°±æ˜¯constexprè¶Šæ¥è¶Šè‡ªç”±äº†ï¼Œå¦‚æœé‡‡ç”¨æ–°ç‰ˆæœ¬çš„C++ï¼Œå…¶å®ä¸ç”¨ç‰¹æ„å»è®°å¿†è¿™äº›ä¸œè¥¿ï¼Œæ¯•ç«ŸIDEä¼šæ™ºèƒ½æç¤ºæˆ‘ä»¬çš„ã€‚åªéœ€è¦çŸ¥é“æœ‰äº›åœºæ™¯ä¸­ä½¿ç”¨è¿™äº›ç‰¹æ€§å¯ä»¥å˜å¾—æ›´é«˜æ•ˆå°±å¥½äº†ã€‚

### å…è®¸åœ¨constexprå‡½æ•°ä¸­å‡ºç°try-catch

åœ¨C++20æ ‡å‡†ä»¥å‰try-catchæ˜¯ä¸èƒ½å‡ºç°åœ¨constexprå‡½æ•°ä¸­çš„ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

constexpr int f(int x)
{
    try
    {
        return x + 1;
    }
    catch (...)
    {
        return 0;
    }
}

int main(int argc, char **argv)
{
    constexpr int n = f(1);
    return 0;
}
```

C++17ç¼–è¯‘ä¸Šé¢ä»£ç ä¼šå¾—åˆ°ä¸€ä¸ªå‹å¥½çš„è­¦å‘Šï¼ŒC++20æ ‡å‡†ç¼–è¯‘æ—¶ï¼Œå…è®¸try-catchå­˜åœ¨äº
constexprå‡½æ•°ï¼Œä½†æ˜¯throwè¯­å¥ä¾æ—§æ˜¯è¢«ç¦æ­¢çš„ï¼Œä¹Ÿå°±æ˜¯catchéƒ¨åˆ†æ°¸è¿œä¸ä¼šè¢«æ‰§è¡Œï¼Œæ²¡æœ‰ä»€ä¹ˆæ„ä¹‰ã€‚

### å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–

ä»C++20å¼€å§‹ï¼Œæ ‡å‡†å…è®¸åœ¨constexprä¸­è¿›è¡Œå¹³å‡¡çš„é»˜è®¤åˆå§‹åŒ–ã€‚

```cpp
#include <iostream>
using namespace std;

struct X
{
    bool val;
};

constexpr void f()
{
    X x;
}

int main(int argc, char **argv)
{
    f();
    return 0;
}
```

C++17ç¼–è¯‘åˆ™ä¼šæŠ¥é”™ï¼Œæç¤ºxæ²¡æœ‰åˆå§‹åŒ–ï¼Œéœ€è¦ç”¨æˆ·æä¾›ä¸€ä¸ªæ„é€ å‡½æ•°ï¼Œæˆ–è€…C++17è¿™æ ·å†™

```cpp
struct X
{
    bool value = false;
};
```

è™½ç„¶C++20æ ‡å‡†çš„ç¼–è¯‘å™¨æ˜¯èƒ½å¤Ÿç¼–è¯‘ï¼Œä½†æ˜¯æˆ‘ä»¬ä¾ç„¶åº”è¯¥å…»æˆå£°æ˜å¯¹è±¡æ—¶éšæ‰‹åˆå§‹åŒ–çš„ä¹ æƒ¯ï¼Œé¿å…è®©ä»£ç å‡ºç°æœªå®šä¹‰çš„è¡Œä¸ºã€‚ å¯ä»¥çœ‹ ä½ å¯èƒ½ä¸çŸ¥é“çš„C++éƒ¨åˆ† çš„ â€œä¸ºä»€ä¹ˆå£°æ˜çš„å˜é‡æ²¡æœ‰è¢«é»˜è®¤åˆå§‹åŒ–â€éƒ¨åˆ†ã€‚

### å…è®¸åœ¨constexprä¸­æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜

C++20ä¹‹å‰å¯¹constexprçš„å¦ä¸€ä¸ªé™åˆ¶å°±æ˜¯ç¦æ­¢æ›´æ”¹è”åˆç±»å‹çš„æœ‰æ•ˆæˆå‘˜ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

union Foo
{
    int i;
    float f;
};

constexpr int use()
{
    Foo foo{};
    foo.f = 1.2f;
    foo.i = 3; // C++20ä¹‹å‰å°†ä¼šç¼–è¯‘å¤±è´¥
    return foo.i;
}

int main(int argc, char **argv)
{
    int arr[use()] = {0};
    return 0;
}
```

åœ¨GCCå’ŒMSVC C++17ä¸­ä¸Šé¢ä»£ç æ˜¯èƒ½å¤Ÿç¼–è¯‘é€šè¿‡çš„ã€‚C++20é™¤æ­¤ä¹‹å¤–è¿˜å…è®¸è®¸å¤šç‰¹æ€§ï¼Œå¦‚å…è®¸dynamic_castå’Œtypeidå‡ºç°åœ¨
å¸¸é‡è¡¨è¾¾å¼ä¸­ï¼Œå…è®¸åœ¨constexprå‡½æ•°ä½¿ç”¨æœªç»è¯„ä¼°çš„å†…è”æ±‡ç¼–ã€‚

### ä½¿ç”¨constevalå£°æ˜ç«‹å³å‡½æ•°

constexprå£°æ˜å‡½æ•°å¹¶ä¸ä¸€æ¥å¸¸é‡è¡¨è¾¾å¼ä¸Šä¸‹æ–‡ç¯å¢ƒï¼Œåœ¨éå¸¸é‡è¡¨è¾¾å¼ç¯å¢ƒä¸­ï¼Œå‡½æ•°å¯ä»¥é€€åŒ–è¡¨ç°ä¸ºæ™®é€šå‡½æ•°ã€‚ä½†æ˜¯æœ‰æ—¶å€™
æˆ‘ä»¬å¸Œæœ›ç¡®ä¿å‡½æ•°åœ¨ç¼–è¯‘æœŸå°±æ‰§è¡Œè®¡ç®—ï¼Œæ— æ³•åœ¨ç¼–è¯‘æœŸç¡®å®šçš„ç›´æ¥è®©ç¼–è¯‘å™¨æŠ¥é”™ã€‚
C++20æ¨å‡ºäº†ä¸€ä¸ªæ–°çš„æ¦‚å¿µ ç«‹å³å‡½æ•°ï¼Œç«‹å³å‡½æ•°éœ€è¦ä½¿ç”¨constevalè¯´æ˜ç¬¦æ¥å£°æ˜ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

constexpr int r = sqr(100);
int x = 100;
int r2 = sqr(x); // ç¼–è¯‘é”™è¯¯ è°ƒç”¨ consteval å‡½æ•° "sqr" ä¸ä¼šç”Ÿæˆæœ‰æ•ˆçš„å¸¸æ•°è¡¨è¾¾å¼
// å› ä¸ºxä¸æ˜¯constä¹Ÿä¸æ˜¯constexpr
// sqrç”¨constevalå£°æ˜ä¸ä¼šé€€åŒ–ä¸ºæ™®é€šå‡½æ•°

int main(int argc, char **argv)
{
    return 0;
}
```

å¦‚æœä¸€ä¸ªç«‹å³å‡½æ•°åœ¨å¦å¤–ä¸€ä¸ªç«‹å³å‡½æ•°ä¸­è¢«è°ƒç”¨ï¼Œåˆ™å‡½æ•°å®šä¹‰æ—¶çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä¸å¿…æ˜¯ä¸€ä¸ªå¸¸é‡è¡¨è¾¾å¼ã€‚æ€ä¹ˆç†è§£å‘¢ï¼Œå°±æ˜¯ä¼ å‚é—®é¢˜ï¼Œä¸‹é¢çš„nåœ¨sqrsqrå‡½æ•°ä¸­çœ‹ï¼Œä¸æ˜¯å¸¸é‡è¡¨è¾¾å¼,ä½†æ˜¯æ˜¯æ²¡é—®é¢˜çš„ã€‚

```cpp
#include <iostream>
using namespace std;

consteval int sqr(int n)
{
    return n * n;
}

consteval int sqrsqr(int n)
{
    n = 5;//è¿™é‡Œæ²¡é—®é¢˜
    return sqr(sqr(n));
}

int main(int argc, char **argv)
{
    int arr[sqrsqr(10)]{0};
    std::cout << sizeof(arr) / sizeof(int) << std::endl; // 625
    return 0;
}
```

lambdaè¡¨è¾¾å¼ä¹Ÿå¯ä»¥ä½¿ç”¨constevalè¯´æ˜ç¬¦

```cpp
#include <iostream>
using namespace std;

auto sqr = [](int n) consteval
{ return n * n; };
int r = sqr(100);

int main(int argc, char **argv)
{
    std::cout << r << std::endl; // 10000
    auto ptr = sqr;//gccå®æµ‹è·å–ç«‹å³å‡½æ•°çš„å‡½æ•°åœ°å€æ˜¯æ²¡æœ‰é—®é¢˜çš„
    std::cout << ptr(100) << std::endl;
    return 0;
}
```

### ä½¿ç”¨constinitæ£€æŸ¥å¸¸é‡åˆå§‹åŒ–

C++ä¸­æœ‰ä¸€ç§å…¸å‹çš„é”™è¯¯å«åš â€œStatic Initialization Order Fiascoâ€,æŒ‡çš„æ˜¯å› ä¸ºé™æ€åˆå§‹åŒ–é¡ºåºé”™è¯¯å¯¼è‡´çš„é—®é¢˜ï¼Œ
å› ä¸ºè¿™ç§é”™è¯¯å¾€å¾€å‘ç”Ÿåœ¨mainå‡½æ•°ä¹‹å‰ï¼Œæ‰€ä»¥æ¯”è¾ƒéš¾ä»¥æ’æŸ¥ã€‚åœ¨Effective C++ä¸­ä¹Ÿæœ‰è®²åˆ°ã€‚

```cpp
//a.cpp
static int a = 100;
```

```cpp
//b.cpp
extern int a;
struct X
{
    X(){
        n = a;
    }
    int n{0};
};

static X x;
```

æ²¡é”™å°±æ˜¯è¿™æ ·ï¼Œæˆ‘ä»¬æ²¡åŠæ³•æ§åˆ¶å“ªä¸ªå¯¹è±¡å…ˆæ„é€ ï¼Œå¦‚æœxåœ¨yä¹‹å‰æ„é€ ï¼Œå°±ä¼šå¼•å‘ä¸€ä¸ªæœªå®šä¹‰çš„ç»“æœã€‚
ä¸ºäº†é¿å…è¿™ç§é—®é¢˜ï¼Œæˆ‘ä»¬é€šå¸¸å¸Œæœ›ä½¿ç”¨å¸¸é‡åˆå§‹åŒ–ç¨‹åºå»åˆå§‹åŒ–é™æ€å˜é‡ï¼Œä¸å¹¸çš„æ˜¯å¸¸é‡åˆå§‹åŒ–è§„åˆ™å¾ˆå¤æ‚ã€‚
C++20å¼•å…¥constinitè¯´æ˜ç¬¦ç”¨ï¼Œä¸»è¦ç”¨äºå…·æœ‰é™æ€å­˜å‚¨æŒç»­æ—¶é—´çš„å˜é‡å£°æ˜ï¼Œå®ƒè¦æ±‚å˜é‡å…·æœ‰å¸¸é‡åˆå§‹åŒ–ç¨‹åºã€‚

```cpp
#include <iostream>
using namespace std;

constinit int x = 11; // ç¼–è¯‘æˆåŠŸï¼Œå…¨å±€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­

int main(int argc, char **argv)
{
    constinit static int y = 42; // ç¼–è¯‘æˆåŠŸï¼Œé™æ€å˜é‡å…·æœ‰é™æ€å­˜å‚¨æŒç»­
    constinit int z = 7;         // ç¼–è¯‘å¤±è´¥ï¼Œå±€éƒ¨å˜é‡æ˜¯åŠ¨æ€åˆ†é…çš„
    return 0;
}
```

å…¶æ¬¡ï¼Œconstinitè¦æ±‚å˜é‡ åˆå§‹åŒ–çš„ç¨‹åºéƒ¨åˆ†åº”è¯¥æ˜¯å¸¸é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
using namespace std;

const char *f()
{
    return "hello";
}

constexpr const char *g() { return "cpp"; }
constinit const char *str1 = f(); // ç¼–è¯‘é”™è¯¯ f()ä¸æ˜¯ä¸€ä¸ªå¸¸é‡åˆå§‹åŒ–ç¨‹åº
constinit const char *str2 = g(); // ç¼–è¯‘æˆåŠŸ

int main(int argc, char **argv)
{
    return 0;
}
```

constinitè¿˜èƒ½ç”¨äºéåˆå§‹åŒ–å£°æ˜ï¼Œå‘ŠçŸ¥ç¼–è¯‘å™¨thread_localå˜é‡å·²ç»è¢«åˆå§‹åŒ–

```cpp
#include <iostream>
using namespace std;

thread_local int x = 100;

extern thread_local constinit int x;

int f()
{
    return x;
}

// constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§
constinit int number = 999;

int main(int argc, char **argv)
{
    std::cout << number << std::endl;
    return 0;
}
```

constinitå¼ºè°ƒå¸¸é‡åˆå§‹åŒ– ä½†æ˜¯åˆå§‹åŒ–çš„å¯¹è±¡å¹¶ä¸è¦æ±‚å…·æœ‰å¸¸é‡å±æ€§ã€‚

### åˆ¤æ–­å¸¸é‡æ±‚å€¼ç¯å¢ƒ

- `std:is_constant_evaluated`

ç”¨äºæ£€æŸ¥å½“å‰è¡¨è¾¾å¼æ˜¯å¦æ˜¯ä¸€ä¸ªå¸¸é‡æ±‚å€¼ç¯å¢ƒ è¿”å›boolç±»å‹

```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main(int argc, char **argv)
{
    std::cout << std::pow(2.0, 3) << std::endl; // 8
    return 0;
}
```

```cpp
#include <iostream>
#include <cmath>
#include <type_traits>
using namespace std;

constexpr double power(double b, int x)
{
    if (std::is_constant_evaluated() && x >= 0)
    {
        double r = 1.0, p = b;
        unsigned int u = (unsigned int)x;
        while (u != 0)
        {
            if (u & 1)
                r *= p;
            u /= 2;
            p *= p;
        }
        return r;
    }
    else
    {
        return std::pow(b, (double)x);
    }
}

int main(int argc, char **argv)
{
    // å¸¸é‡ç¯å¢ƒ ç¼–è¯‘æœŸé—´å°±ç®—å¥½äº†
    constexpr double kilo = power(10.0, 3);
    int n = 3;
    // éå¸¸é‡ç¯å¢ƒ è¿è¡Œæ—¶ç®—
    double mucho = power(10.0, n);
    std::cout << kilo << std::endl;  // 1000
    std::cout << mucho << std::endl; // 1000

    int n1 = -1;
    constexpr double q = power(10.0, n1); // ç¼–è¯‘é”™è¯¯  â€˜int n1â€™ is not const
    std::cout << q << std::endl;
    // å› ä¸ºä¼šèµ°std::pow

    return 0;
}
```

æœ‰ä¸€ä¸ªæ¦‚å¿µå«åš æ˜æ˜¾å¸¸é‡æ±‚å€¼

1. å¸¸é‡è¡¨è¾¾å¼ï¼Œå¦‚æ•°ç»„é•¿åº¦ã€caseè¡¨è¾¾å¼ã€éç±»å‹æ¨¡æ¿å®å‚ç­‰
2. if constexprè¯­å¥ä¸­çš„æ¡ä»¶
3. constexprå˜é‡çš„åˆå§‹åŒ–ç¨‹åº
4. ç«‹å³å‡½æ•°çš„è°ƒç”¨
5. çº¦æŸæ¦‚å¿µè¡¨è¾¾å¼
6. å¯åœ¨å¸¸é‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨æˆ–å…·æœ‰å¸¸é‡åˆå§‹åŒ–çš„å˜é‡åˆå§‹åŒ–ç¨‹åº

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

template <bool>
struct X
{
};

X<std::is_constant_evaluated()> x;
// éç±»å‹æ¨¡æ¿å®å‚ï¼Œå‡½æ•°è¿”å›trueï¼Œæœ€ç»ˆç±»å‹ä¸ºX<true>

int main(int argc, char **argv)
{
    return 0;
}
```

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

constexpr int f()
{
    const int n = std::is_constant_evaluated() ? 13 : 17; // næ˜¯13
    int m = std::is_constant_evaluated() ? 13 : 17;       // må¯èƒ½æ˜¯13æˆ–è€…17ï¼Œå–å†³äºå‡½æ•°ç¯å¢ƒ
    char arr[n] = {};                                     // char[13]
    return m + sizeof(arr);
}

int main(int argc, char **argv)
{
    int p = f();     // mä¸º13ï¼Œpä¸º26
    int q = p + f(); // mä¸º17ï¼Œqä¸º56 å› ä¸ºè¿™é‡Œpæ˜¯éconstçš„ èµ‹å€¼å³è¾¹ä¸æ˜¯å¸¸é‡æ±‚å€¼ç¯å¢ƒ
    return 0;
}
```

å¦‚æœå½“åˆ¤æ–­æ˜¯å¦ä¸ºæ˜æ˜¾å¸¸é‡æ±‚å€¼æ—¶å­˜åœ¨å¤šä¸ªæ¡ä»¶ï¼Œé‚£ä¹ˆç¼–è¯‘å™¨ä¼šè¯•æ¢`std::is_constant_evaluated()`ä¸¤ç§æƒ…å†µæ±‚å€¼ï¼Œæ¯”å¦‚ï¼š

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int y = 1000;
const int a = std::is_constant_evaluated() ? y : 1;
const int b = std::is_constant_evaluated() ? 2 : y;

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 1
    std::cout << b << std::endl; // 2
    return 0;
}
```

- å½“å¯¹aæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°yä¼šæ”¹å˜açš„å€¼ï¼Œæ‰€ä»¥æœ€åé€‰æ‹©`std::is_constant_evaluated()==false`
- å½“å¯¹bæ±‚å€¼æ—¶ï¼Œç¼–è¯‘å™¨è¯•æ¢`std::is_constant_evaluated()==true`çš„æƒ…å†µï¼Œå‘ç°ç»“æœæ’ä¸º2ï¼Œäºæ˜¯ç›´æ¥åœ¨ç¼–è¯‘æ—¶å®Œæˆåˆå§‹åŒ–

```cpp
#include <iostream>
#include <type_traits>
using namespace std;

int x = 2000;
int y = 1000;
const int a = std::is_constant_evaluated() ? y : 2; // (true,y)ä¸ç¬¦åˆ (false,2)ç¬¦åˆ
const int b = std::is_constant_evaluated() ? 5 : y; // (true,5)ç¬¦åˆ
const int c = std::is_constant_evaluated() ? 3 : 4; // (true,3)ç¬¦åˆ
const int d = std::is_constant_evaluated() ? x : y; // (true,x)ä¸ç¬¦åˆ (false,y)ç¬¦åˆ

int main(int argc, char **argv)
{
    std::cout << a << std::endl; // 2
    std::cout << b << std::endl; // 5
    std::cout << c << std::endl; // 3
    std::cout << d << std::endl; // 1000
    return 0;
}
```

### C++20constexpræ€»ç»“

æˆ‘åªæƒ³å–Šï¼Œä»€ä¹ˆç‹—å±C++ï¼Œå¤§å‚»é€¼ã€‚

## å±æ€§è¯´æ˜ç¬¦å’Œæ ‡å‡†å±æ€§

å„ç§ç¼–è¯‘å™¨GCCã€MSVCç­‰ç­‰ æä¾›äº†è‡ªå®¶çš„å±æ€§è¯­æ³•

GCC

```cpp
_attribute__((attribute-list))
// ä¾‹å¦‚
_attribute__((aligned(16))) class X
{
    int i;
};
```

MSVC

```cpp
__declspec(attribute-list)
```

ä¸è¿‡åˆ«ç®¡è¿™äº›ï¼Œä¹Ÿä¸è¦å…³å¿ƒï¼Œä¹Ÿä¸è¦äº†è§£ï¼Œç†è§£ä½¿ç”¨è¿™äº›ä¸œè¥¿åªä¼šå¢åŠ å¼€å‘çš„è´Ÿæ‹…ã€‚æˆ‘ä»¬åº”è¯¥åªå…³æ³¨C++æ ‡å‡†ï¼Œ
ä½¿ç”¨C++æ ‡å‡†ã€‚

### æ ‡å‡†å±æ€§è¯´æ˜ç¬¦è¯­æ³•

C++11æ ‡å‡†çš„å±æ€§è¡¨ç¤ºæ–¹æ³•æ˜¯

```cpp
[[attr]] [[attr1, attr2, attr3(args)]]
[[namespace:::attr(args)]]
```

æœ‰å±æ€§å‘½åç©ºé—´çš„æ¦‚å¿µå¦‚

```cpp
[[gnu::always_inline]] [[gnu::hot]] [[gnu::const]] [[nodiscard]]
inline int f();
// æˆ–è€…
[[gnu::always_inline, gnu::hot, gnu::const, nodiscard]]
inline int f();
```

C++17æ ‡å‡†å¯¹å‘½åç©ºé—´å±æ€§å£°æ˜åšäº†ä¼˜åŒ–å¼•å…¥äº†usingå…³é”®è¯æ‰“å¼€å±æ€§å‘½åç©ºé—´

```cpp
[[ using attribute-namespace : attribute-list]]
```

å¦‚æ”¹å†™å‡½æ•°f

```cpp
[[using gnu : always_inline, hot, const]]
[[nodiscard]]
inline int f();
```

### æ ‡å‡†å±æ€§

C++11åˆ°C++20ä¸€å…±å®šä¹‰äº†9ç§æ ‡å‡†å±æ€§ã€‚

### noreturn

C++11å¼•å…¥äº†noreturnå±æ€§ï¼Œå®ƒæ˜¯ä¸€ç§å‡½æ•°å±æ€§ï¼Œç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°ä¸ä¼šè¿”å›ã€‚è¿™åœ¨ç¼–å†™ç‰¹å®šç±»å‹çš„å‡½æ•°æ—¶éå¸¸æœ‰ç”¨ï¼Œä¾‹å¦‚ç»ˆæ­¢ç¨‹åºçš„å‡½æ•°æˆ–è€…æ°¸è¿œä¸ä¼šè¿”å›çš„å‡½æ•°ã€‚ä¸€ä¸ªå¸¸è§çš„ç”¨ä¾‹æ˜¯åœ¨å‡½æ•°ä¸­ä½¿ç”¨`abort()`å‡½æ•°ï¼Œè¯¥å‡½æ•°ä¼šç«‹å³ç»ˆæ­¢ç¨‹åºæ‰§è¡Œã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œ`abort()`å‡½æ•°è¢«è°ƒç”¨åç¨‹åºä¸ä¼šå†ç»§ç»­æ‰§è¡Œï¼Œå› æ­¤å¯ä»¥å°†å…¶å£°æ˜ä¸ºnoreturnï¼Œä»¥ä¾¿é€šçŸ¥ç¼–è¯‘å™¨è¿™ä¸€ç‚¹ã€‚

è¿™æœ‰åŠ©äºç¼–è¯‘å™¨è¿›è¡Œæ›´å¥½çš„ä¼˜åŒ–ï¼ŒåŒæ—¶ä¹Ÿå‘ä»£ç çš„è¯»è€…ä¼ è¾¾äº†æ¸…æ™°çš„æ„å›¾ã€‚æ³¨æ„è¿™é‡Œçš„ä¸ä¼šè¿”å›ä¸æ˜¯è¿”å›voidï¼Œè€Œæ˜¯ä»€ä¹ˆéƒ½ä¸è¿”å›ä¸ä¼šè¿”å›ã€‚

```cpp
#include <iostream>
using namespace std;

[[noreturn]] void foo()
{
    std::cout << "foo()" << std::endl;
    abort();
}

void bar()
{
    std::cout << "bar()" << std::endl;
}

int main(int argc, char **argv)
{
    foo();
    bar();
    return 0;
}
```

### carries_dependency

æŒ‡ç¤ºé‡Šæ”¾æ¶ˆè´¹ `std::memory_order` ä¸­çš„ä¾èµ–é“¾ä¼ è¿›å’Œä¼ å‡ºè¯¥å‡½æ•°ï¼Œè¿™å…è®¸ç¼–è¯‘å™¨è·³è¿‡ä¸å¿…è¦çš„å†…å­˜æ …æ æŒ‡ä»¤ã€‚

æ­¤å±æ€§å¯åœ¨ä¸¤ç§æƒ…å½¢ä¸­å‡ºç°ï¼š

- å®ƒå¯åº”ç”¨äºå‡½æ•°æˆ– lambda è¡¨è¾¾å¼çš„å½¢å‚å£°æ˜ï¼Œè¯¥æƒ…å†µä¸‹å®ƒæŒ‡ç¤ºä»è¯¥å½¢å‚çš„åˆå§‹åŒ–å‘è¯¥å¯¹è±¡çš„å·¦å€¼åˆ°å³å€¼è½¬æ¢ä¸­æºå¸¦ä¾èµ–ã€‚
- å®ƒå¯åº”ç”¨äºå‡½æ•°å£°æ˜æ•´ä½“ï¼Œè¯¥æƒ…å†µä¸‹å®ƒæŒ‡ç¤ºä»è¿”å›å€¼å‘å‡½æ•°è°ƒç”¨è¡¨è¾¾å¼çš„æ±‚å€¼ä¸­æºå¸¦ä¾èµ–ã€‚æ­¤å±æ€§å¿…é¡»å‡ºç°åœ¨ä»»æ„ç¿»è¯‘å•å…ƒä¸­æŸä¸ªå‡½æ•°æˆ–å…¶å½¢å‚ä¹‹ä¸€çš„é¦–ä¸ªå£°æ˜ä¸Šã€‚è‹¥å¦ä¸€ç¿»è¯‘å•å…ƒä¸­çš„è¯¥å‡½æ•°æˆ–å…¶å½¢å‚çš„é¦–ä¸ªå£°æ˜ä¸Šæœªä½¿ç”¨è¯¥å±æ€§ï¼Œåˆ™ç¨‹åºéè‰¯æ„ï¼›ä¸è¦æ±‚è¯Šæ–­ã€‚

åæ­£æˆ‘ç°åœ¨è¿™ä¸ªèœé¸¡æ˜¯ä¸ç†è§£ï¼Œåé¢å­¦è¿‡åŸå­æ“ä½œçš„å†çœ‹å§ã€‚

### deprecated

deprecatedæ˜¯åœ¨C++14æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œå¸¦æœ‰æ­¤å±æ€§çš„å®ä½“è¢«å£°æ˜ä¸ºå¼ƒç”¨ï¼Œè™½ç„¶åœ¨ä»£ç ä¸­ä¾ç„¶å¯ä»¥ä½¿ç”¨å®ƒä»¬ï¼Œä½†æ˜¯å¹¶ä¸é¼“åŠ±è¿™ä¹ˆåšã€‚å½“ä»£ç ä¸­å‡ºç°å¸¦æœ‰å¼ƒç”¨å±æ€§çš„å®ä½“æ—¶ï¼Œç¼–è¯‘å™¨é€šå¸¸ä¼šç»™å‡ºè­¦å‘Šè€Œä¸æ˜¯é”™è¯¯ã€‚

```cpp
#include <iostream>
using namespace std;

[[deprecated("foo was deprecated, use bar instead")]] void foo()
{
}
// warning: â€˜void foo()â€™ is deprecated: foo was deprecated, use bar instead [-Wdeprecated-declarations]

class [[deprecated]] X
{
};

int main(int argc, char **argv)
{
    X x;
    foo();
    return 0;
}
```

### fallthrough

fallthroughæ˜¯C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å¯ä»¥åœ¨switchè¯­å¥çš„ä¸Šä¸‹æ–‡ä¸­æç¤ºç¼–è¯‘å™¨ç›´è½è¡Œä¸ºæ˜¯æœ‰æ„çš„ï¼Œå¹¶ä¸éœ€è¦ç»™å‡ºè­¦å‘Šã€‚

```cpp
#include <iostream>
using namespace std;

void bar()
{
    std::cout << "bar()" << std::endl;
}

void foo(int a)
{
    switch (a)
    {
    case 0:
        break;
    case 1:
        bar();
        [[fallthrough]];
    case 2:
        bar();
        break;
    default:
        break;
    }
}

int main(int argc, char **argv)
{
    foo(1);
    // bar()
    // bar()
    return 0;
}
```

### nodiscard

nodiscardæ˜¯åœ¨C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å£°æ˜å‡½æ•°çš„è¿”å›å€¼ä¸åº”è¯¥è¢«èˆå¼ƒï¼Œå¦åˆ™é¼“åŠ±ç¼–è¯‘å™¨ç»™å‡ºè­¦å‘Šæç¤ºã€‚nodiscardå±æ€§ä¹Ÿå¯ä»¥å£°æ˜åœ¨ç±»æˆ–è€…æšä¸¾ç±»å‹ä¸Šï¼Œä½†æ˜¯å®ƒå¯¹ç±»æˆ–è€…æšä¸¾ç±»å‹æœ¬èº«å¹¶ä¸èµ·ä½œç”¨ï¼Œåªæœ‰å½“è¢«å£°æ˜ä¸ºnodiscardå±æ€§çš„ç±»æˆ–è€…æšä¸¾ç±»å‹è¢«å½“ä½œå‡½æ•°è¿”å›å€¼çš„æ—¶å€™æ‰å‘æŒ¥ä½œç”¨ï¼š

```cpp
#include <iostream>
using namespace std;

class [[nodiscard]] X
{
};

[[nodiscard]] int foo()
{
    return 1;
}

X bar()
{
    return X();
}

int main(int argc, char **argv)
{
    X x;
    foo();
    // warning: ignoring return value of â€˜int foo()â€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    bar();
    // warning: ignoring returned value of type â€˜Xâ€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    return 0;
}
```

nodiscardå±æ€§åªé€‚ç”¨äºè¿”å›å€¼ç±»å‹çš„å‡½æ•°ï¼Œå¯¹äºè¿”å›å¼•ç”¨çš„å‡½æ•°ä½¿ç”¨nodiscardå±æ€§æ˜¯æ²¡æœ‰ä½œç”¨çš„

```cpp
#include <iostream>
using namespace std;

class [[nodiscard]] X
{
};

X &bar(X &x)
{
    return x;
}

int main(int argc, char **argv)
{
    X x;
    bar(x); // barè¿”å›å¼•ç”¨,nodiscardä¸èµ·ä½œç”¨ï¼Œç¼–è¯‘æ—¶ä¸ä¼šå¼•å‘è­¦å‘Š
    return 0;
}
```

nodiscardå±æ€§æœ‰å‡ ä¸ªå¸¸ç”¨åœºåˆ

1. é˜²æ­¢èµ„æºæ³„éœ²ï¼Œå¯¹äºåƒmallocæˆ–è€…newè¿™æ ·çš„å‡½æ•°æˆ–è€…è¿ç®—ç¬¦ï¼Œå®ƒä»¬è¿”å›çš„å†…å­˜æŒ‡é’ˆæ˜¯éœ€è¦åŠæ—¶é‡Šæ”¾çš„ï¼Œå¯ä»¥ä½¿ç”¨nodiscardå±æ€§æç¤ºè°ƒç”¨è€…ä¸è¦å¿½ç•¥è¿”å›å€¼ã€‚
2. å¯¹äºå·¥å‚å‡½æ•°è€Œè¨€ï¼ŒçœŸæ­£æœ‰æ„ä¹‰çš„æ˜¯å›è¿”çš„å¯¹è±¡è€Œä¸æ˜¯å·¥å‚å‡½æ•°ï¼Œå°†nodiscardå±æ€§åº”ç”¨åœ¨å·¥å‚å‡½æ•°ä¸­ä¹Ÿå¯ä»¥æç¤ºè°ƒç”¨è€…åˆ«å¿˜äº†ä½¿ç”¨å¯¹è±¡ï¼Œå¦åˆ™ç¨‹åºä»€ä¹ˆä¹Ÿä¸ä¼šåšã€‚
3. å¯¹äºè¿”å›å€¼ä¼šå½±å“ç¨‹åºè¿è¡Œæµç¨‹çš„å‡½æ•°è€Œè¨€ï¼Œnodiscardå±æ€§ä¹Ÿæ˜¯ç›¸å½“åˆé€‚çš„ï¼Œå®ƒå‘Šè¯‰è°ƒç”¨æ–¹å…¶è¿”å›å€¼åº”è¯¥ç”¨äºæ§åˆ¶åç»­çš„æµç¨‹ã€‚å¦‚è¿”å›é”™è¯¯ç ï¼Œä¿è¯ç¨‹åºæœ‰è¿›è¡Œåˆ¤æ–­

C++20å¼€å§‹ï¼Œnodiscardå±æ€§æ”¯æŒå°†ä¸€ä¸ªå­—ç¬¦ä¸²å­—é¢é‡ä½œä¸ºå±æ€§å‚æ•°ï¼Œå­—ç¬¦ä¸²ä¼šåŒ…åœ¨è­¦å‘Šä¸­

```cpp
#include <iostream>
using namespace std;

class [[nodiscard("my nodiscard alert")]] X
{
};

X bar(X &x)
{
    return x;
}

int main(int argc, char **argv)
{
    X x;
    bar(x);
    // warning: ignoring returned value of type â€˜Xâ€™, declared with attribute â€˜nodiscardâ€™: â€˜my nodiscard alertâ€™ [-Wunused-result]
    return 0;
}
```

C++20å¼€å§‹ï¼Œnodiscardå±æ€§è¿˜èƒ½ç”¨äºæ„é€ å‡½æ•°ï¼Œå®ƒä¼šåœ¨ç±»å‹æ„å»ºä¸´æ—¶å¯¹è±¡çš„æ—¶å€™è®©ç¼–è¯‘å™¨å‘å‡ºè­¦å‘Š

```cpp
#include <iostream>
using namespace std;

class X
{
public:
    [[nodiscard]] X() {}
    X(int a) {}
};

int main(int argc, char **argv)
{
    X x;
    X{}; // warning: ignoring return value of â€˜X::X()â€™, declared with attribute â€˜nodiscardâ€™ [-Wunused-result]
    X{42};
    return 0;
}
// X {}
// æ„é€ äº†ä¸´æ—¶å¯¹è±¡ï¼Œäºæ˜¯ç¼–è¯‘å™¨ç»™å‡ºå¿½ç•¥X::X() è¿”å›å€¼çš„è­¦å‘Šï¼›X{42};
// ä¸ä¼šäº§ç”Ÿç¼–è¯‘è­¦å‘Šï¼Œå› ä¸ºX(int a) {}
// æ²¡æœ‰nodicardå±æ€§ã€‚
```

### maybe_unused

maybe_unusedæ˜¯åœ¨C++17æ ‡å‡†ä¸­å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§å£°æ˜å®ä½“å¯èƒ½ä¸ä¼šè¢«åº”ç”¨ä»¥æ¶ˆé™¤ç¼–è¯‘å™¨è­¦å‘Šã€‚

```cpp
#include <iostream>
using namespace std;

int foo(int a [[maybe_unused]], int b [[maybe_unused]])
{
    return 5;
}

int main(int argc, char **argv)
{
    foo(1, 2);
    int a [[maybe_unused]] = 9;
    return 0;
}
```

maybe_unusedå±æ€§é™¤ä½œä¸ºå‡½æ•°å½¢å‚å±æ€§å¤–ï¼Œè¿˜å¯ä»¥ç”¨åœ¨å¾ˆå¤šåœ°æ–¹ï¼Œæ¯”å¦‚ç±»ã€ç»“æ„ä½“ã€è”åˆç±»å‹ã€æšä¸¾ç±»å‹ã€å‡½æ•°ã€å˜é‡ç­‰ã€‚

### likelyå’Œunlikely

likelyå’Œunlikelyæ˜¯C++20æ ‡å‡†å¼•å…¥çš„å±æ€§ï¼Œä¸¤ä¸ªå±æ€§éƒ½æ˜¯å£°æ˜åœ¨æ ‡ç­¾æˆ–è€…è¯­å¥ä¸Šçš„ã€‚å…¶ä¸­likelyå±æ€§å…è®¸ç¼–è¯‘å™¨å¯¹è¯¥å±æ€§æ‰€åœ¨çš„æ‰§è¡Œè·¯å¾„ç›¸å¯¹äºå…¶ä»–æ‰§
è¡Œè·¯å¾„è¿›è¡Œä¼˜åŒ–ï¼›è€Œunlikelyå±æ€§æ°æ°ç›¸åã€‚é€šå¸¸ï¼Œlikelyå’Œunlikelyè¢«å£°æ˜åœ¨switchè¯­å¥ï¼š

é€šå¸¸æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨ä¼šå‡å®šæ¡ä»¶åˆ†æ”¯çš„å¯èƒ½æ€§æ˜¯å‡ç­‰çš„ï¼Œä½†å®é™…æƒ…å†µä¸­ï¼ŒæŸäº›åˆ†æ”¯å¯èƒ½ä¼šæ›´æœ‰å¯èƒ½å‘ç”Ÿï¼Œè€ŒæŸäº›åˆ†æ”¯åˆ™è¾ƒå°‘å‘ç”Ÿã€‚é€šè¿‡ä½¿ç”¨`[[likely]]`å’Œ`[[unlikely]]`å±æ€§ï¼Œå¼€å‘äººå‘˜å¯ä»¥å‘ç¼–è¯‘å™¨æä¾›å…³äºæ¡ä»¶åˆ†æ”¯å¯èƒ½æ€§çš„æç¤ºï¼Œä»¥ä¾¿ç¼–è¯‘å™¨å¯ä»¥ç›¸åº”åœ°ä¼˜åŒ–ç”Ÿæˆçš„ä»£ç ã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int a = 1, b = 2;
    if (a < b) [[likely]]
    {
    }
    else if (a == b) [[unlikely]]
    {
    }
    else
    {
    }
    return 0;
}
```

```cpp
#include <iostream>
using namespace std;

int f(int i)
{
    switch (i)
    {
    case 1:
        [[fallthrough]];
    [[likely]] case 2:
        return 1;
    default:
        break;
    }
    return 2;
}

int main(int argc, char **argv)
{
    f(1);
    return 0;
}
```

### no_unique_address

no_unique_addressæ˜¯C++20æ ‡å‡†å¼•å…¥çš„å±æ€§ï¼Œè¯¥å±æ€§æŒ‡ç¤ºç¼–è¯‘å™¨è¯¥æ•°æ®æˆå‘˜ä¸éœ€è¦å”¯ä¸€çš„åœ°å€ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒä¸éœ€è¦ä¸å…¶ä»–éé™æ€æ•°æ®æˆå‘˜ä½¿ç”¨ä¸åŒçš„åœ°å€ã€‚æ³¨æ„ï¼Œè¯¥å±æ€§å£°æ˜çš„å¯¹è±¡å¿…é¡»æ˜¯éé™æ€æ•°æ®æˆå‘˜ä¸”ä¸ä¸ºä½åŸŸï¼š

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct X
{
    int i;
    Empty e;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 8
    X x;
    printf("%p\n", &x.i); // 0x7ffe56fc7510
    printf("%p\n", &x.e); // 0x7ffe56fc7514
    return 0;
}
```

æœ‰ä¸€ç§æ–¹æ³•æ˜¯è®©ç©ºçš„eæ²¡æœ‰è‡ªå·±çš„åœ°å€,ä½¿ç”¨no_unique_address

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct X
{
    int i;
    [[no_unique_address]] Empty e;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 4
    X x;
    printf("%p\n", &x.i); // 0x7ffc99948c04
    printf("%p\n", &x.e); // 0x7ffc99948c04
    return 0;
}
```

å¦‚æœå­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„ç±»å‹ä¸”å®ƒä»¬éƒ½å…·æœ‰no_unique_addresså±æ€§ï¼Œç¼–è¯‘å™¨ä¸ä¼šé‡å¤åœ°å°†å…¶å †åœ¨åŒä¸€ä¸ªåœ°å€

```cpp
#include <iostream>
using namespace std;

struct Empty
{
};

struct Empty1
{
};

struct X
{
    int i;
    [[no_unique_address]] Empty e, e1;
};

struct X1
{
    int i;
    [[no_unique_address]] Empty e;
    [[no_unique_address]] Empty1 e1;
};

int main(int argc, char **argv)
{
    std::cout << sizeof(Empty) << std::endl; // 1
    std::cout << sizeof(X) << std::endl;     // 8
    X x;
    printf("%p\n", &x.i);  // 0x7fff305d0640
    printf("%p\n", &x.e);  // 0x7fff305d0640
    printf("%p\n", &x.e1); // 0x7fff305d0644

    X1 x1;
    printf("%p\n", &x1.i);  // 0x7ffe49f9036c
    printf("%p\n", &x1.e);  // 0x7ffe49f9036c
    printf("%p\n", &x1.e1); // 0x7ffe49f9036c

    return 0;
}
```

no_unique_addressè¿™ä¸ªå±æ€§çš„ä½¿ç”¨åœºæ™¯ã€‚è¯»è€…ä¸€å®šå†™è¿‡æ— çŠ¶æ€çš„ç±»ï¼Œè¿™ç§ç±»ä¸éœ€è¦æœ‰æ•°æ®æˆå‘˜ï¼Œå”¯ä¸€éœ€è¦åšçš„å°±æ˜¯å®ç°ä¸€äº›å¿…è¦çš„å‡½æ•°ï¼Œ
å¸¸è§çš„æ˜¯STLä¸­ä¸€äº›ç®—æ³•å‡½æ•°æ‰€éœ€çš„å‡½æ•°å¯¹è±¡ï¼ˆä»¿å‡½æ•°ï¼‰ã€‚è€Œè¿™ç§ç±»ä½œä¸ºæ•°æ®æˆå‘˜åŠ å…¥å…¶ä»–ç±»æ—¶ï¼Œä¼šå æ®ç‹¬ä¸€æ— äºŒçš„å†…å­˜åœ°å€ï¼Œå®é™…ä¸Šè¿™æ˜¯æ²¡æœ‰å¿…è¦çš„ã€‚
æ‰€ä»¥ï¼Œåœ¨C++20çš„ç¯å¢ƒä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨no_unique_addresså±æ€§ï¼Œè®©å…¶ä¸éœ€è¦å ç”¨é¢å¤–çš„å†…å­˜åœ°å€ç©ºé—´ã€‚

## æ–°å¢é¢„å¤„ç†å™¨å’Œå®

### é¢„å¤„ç†å™¨__has_include

C++17ä¸ºé¢„å¤„ç†å™¨å¢åŠ äº†ä¸€ä¸ªæ–°ç‰¹æ€§ï¼Œ`__has_include`,ç”¨äºåˆ¤æ–­æŸä¸ªå¤´æ–‡ä»¶æ˜¯å¦èƒ½è¢«åŒ…å«è¿›æ¥

```cpp
#include <iostream>

#if __has_include(<optional>)
#include <optional>
#define have_optional 1
#elif __has_include(<experimental/optional>)
#include <experimental/optional>
#define have_optional 1
#define experimental_optional 1
#else
#define have_optional 0
#endif

using namespace std;

int main(int argc, char **argv)
{
    std::cout << have_optional << std::endl;
    return 0;
}
```

### ç‰¹æ€§æµ‹è¯•å®

C++20æ ‡å‡†æ·»åŠ äº†ä¸€ç»„ç”¨äºæµ‹è¯•åŠŸèƒ½ç‰¹æ€§çš„å®ï¼Œè¿™ç»„å®å¯ä»¥å¸®åŠ©æˆ‘ä»¬æµ‹è¯•å½“å‰çš„ç¼–è¯‘ç¯å¢ƒå¯¹å„ç§åŠŸèƒ½ç‰¹æ€§çš„æ”¯æŒç¨‹åº¦ã€‚

### å±æ€§ç‰¹æ€§æµ‹è¯•å®

```cpp
std::cout << __has_cpp_attribute(deprecated);
// å°†ä¼šè¾“å‡ºè¯¥å±æ€§æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ 201309
```

```cpp
å±æ€§        å€¼
carries_dependency 200809L
deprecated 201309L
fallthrough 201603L
likely 201803L
maybe_unused 201603L
no_unique_address 201803L
nodiscard 201603L
noreturn 200809L
unlikely 201803L
```

### è¯­è¨€åŠŸèƒ½ç‰¹æ€§æµ‹è¯•å®

ä»¥ä¸‹åˆ—è¡¨çš„å®ä»£è¡¨ç¼–è¯‘ç¯å¢ƒæ‰€æ”¯æŒçš„è¯­è¨€åŠŸèƒ½ç‰¹æ€§ï¼Œæ¯ä¸ªå®å°†è¢«å±•å¼€ä¸ºè¯¥ç‰¹æ€§
æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å®å±•å¼€çš„å€¼ä¼šéšç€ç‰¹æ€§çš„å˜æ›´è€Œæ›´æ–°ã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    std::cout << __cpp_aggregate_bases << std::endl; // 201603
    return 0;
}
```

<https://en.cppreference.com/w/cpp/feature_test>

```cpp
å®         å€¼
__cpp_aggregate_bases 201603L
__cpp_aggregate_nsdmi 201304L
__cpp_aggregate_paren_init 201902L
__cpp_alias_templates 200704L
__cpp_aligned_new 201606L
__cpp_attributes 200809L
__cpp_binary_literals 201304L
__cpp_capture_star_this 201603L
__cpp_char8_t 201811L
__cpp_concepts 201907L
__cpp_conditional_explicit 201806L
__cpp_consteval 201811L
__cpp_constexpr 201907L
__cpp_constexpr_dynamic_alloc 201907L
__cpp_constexpr_in_decltype 201711L
__cpp_constinit 201907L
__cpp_coroutines 201902L
__cpp_decltype 200707L
__cpp_decltype_auto 201304L
// ...............
```

### æ ‡å‡†åº“åŠŸèƒ½ç‰¹æ€§æµ‹è¯•å®

ä»¥ä¸‹åˆ—è¡¨çš„å®ä»£è¡¨ç¼–è¯‘ç¯å¢ƒæ‰€æ”¯æŒçš„æ ‡å‡†åº“åŠŸèƒ½ç‰¹æ€§ï¼Œé€šå¸¸åŒ…å«åœ¨`<version>`å¤´æ–‡ä»¶æˆ–è€…è¡¨ä¸­çš„ä»»æ„å¯¹åº”å¤´æ–‡ä»¶ä¸­ã€‚
æ¯ä¸ªå®å°†è¢«å±•å¼€ä¸ºè¯¥ç‰¹æ€§æ·»åŠ åˆ°æ ‡å‡†æ—¶çš„å¹´ä»½å’Œæœˆä»½ã€‚è¯·æ³¨æ„ï¼Œè¿™äº›å®å±•å¼€çš„å€¼ä¼šéšç€ç‰¹æ€§çš„å˜æ›´è€Œæ›´æ–°ã€‚

<https://en.cppreference.com/w/cpp/utility/feature_test>

```cpp
å®      å€¼       å¤´æ–‡ä»¶
__cpp_lib_addressof_constexpr 201603L <memory>

__cpp_lib_allocator_traits_is_always_equal
201411L
<memory> <scoped_allocator> <string> <deque> <forward_list> <list> <vector> <map><set> <unordered_map> <unordered_set>

__cpp_lib_any 201606L <any>
__cpp_lib_apply 201603L <tuple>
// ...............
```

### æ–°å¢å®VA_OPT

ä»C99æ ‡å‡†å¼€å§‹ï¼ŒCè¯­è¨€å¼•å…¥äº†å¯å˜å‚æ•°å®`__VA_ARGS`,C++11æ ‡å‡†ä¹Ÿå°†å…¶çº³å…¥äº†æ ‡å‡†ã€‚`__VA_ARGS__`å¸¸è§çš„ç”¨æ³•å¦‚æ‰“å°æ—¥å¿—ä¸Šã€‚

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, __VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello %d", 2024); //["__FILE__":8]hello 2024
    printf("hello" "world\n");//helloworld
    return 0;
}
```

ä¸Šé¢æœ‰ä¸ªé—®é¢˜å°±æ˜¯å¦‚æœLOGåªç”¨ç¬¬ä¸€ä¸ªå‚æ•°ä¼šæŠ¥é”™,é—®é¢˜å°±æ˜¯å¤šäº†ä¸ª `,`

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, __VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello");
    // æ‰©å±•åˆ°printf("[\"__FILE__\":%d]" "hello" "\n", 8, )
    return 0;
}
```

å¯ä»¥ä½¿ç”¨ `##` è¿æ¥`__VA_ARGS__`

åœ¨C/C++ä¸­ï¼Œ`##` æ˜¯é¢„å¤„ç†å™¨ä¸­çš„è¿æ¥è¿ç®—ç¬¦ã€‚å®ƒçš„ä½œç”¨æ˜¯åœ¨å®å±•å¼€è¿‡ç¨‹ä¸­ï¼Œ
å°†å…¶å‰åçš„æ ‡è¯†ç¬¦è¿æ¥æˆä¸€ä¸ªå•ç‹¬çš„æ ‡è¯†ç¬¦æˆ–è€…åˆ é™¤å‰é¢çš„é€—å·ã€‚

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[\"__FILE__\":%d]" msg "\n", __LINE__, ##__VA_ARGS__)

int main(int argc, char **argv)
{
    LOG("hello"); // ["__FILE__":8]hello
    // æ‰©å±•åˆ°printf("[\"__FILE__\":%d]" "hello" "\n", 8)
    return 0;
}
```

C++20å¼•å…¥äº†ä¸€ä¸ªæ–°çš„å®`__VA_OPT__`ä»¤å¯å˜å‚æ•°å®æ›´å®¹æ˜“åœ¨å¯å˜å‚æ•°ä¸ºç©ºçš„æƒ…å†µä¸‹ä½¿ç”¨

```cpp
#include <iostream>
using namespace std;

#define LOG(msg, ...) printf("[" __FILE__      \
                             ":%d] " msg "\n", \
                             __LINE__ __VA_OPT__(, ) __VA_ARGS__)

int main(int argc, char **argv)
{
    // æ‰©å±•åˆ° printf("[" "/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp" ":%d] " "hello" "\n", 11  )
    LOG("hello");
    // [/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp:10] hello
    return 0;
}
```

## å…è®¸æŒ‰å€¼è¿›è¡Œé»˜è®¤æ¯”è¾ƒ

åœ¨C++20ä¹‹å‰çš„æ ‡å‡†ä¸­ï¼Œç±»çš„é»˜è®¤æ¯”è¾ƒè§„åˆ™è¦æ±‚ç±»Cå¯ä»¥æœ‰ä¸€ä¸ªå‚æ•°ä¸º`const C&`çš„éé™æ€æˆå‘˜å‡½æ•°ï¼Œæˆ–è€…æœ‰ä¸¤ä¸ªå‚æ•°ä¸º`const C&`çš„å‹å…ƒå‡½æ•°ã€‚

C++20 æ ‡å‡†å¯¹è¿™ä¸€æ¡è§„åˆ™åšäº†é€‚åº¦çš„æ”¾å®½ï¼Œå®ƒè§„å®šç±»çš„é»˜è®¤æ¯”è¾ƒè¿ç®—ç¬¦å‡½æ•°å¯ä»¥æ˜¯ä¸€ä¸ªå‚æ•°ä¸º`const C&`çš„éé™æ€æˆå‘˜å‡½æ•°ï¼Œæˆ–è€…ä¸¤ä¸ªå‚æ•°ä¸º`const C&`æˆ–`C`çš„å‹å…ƒå‡½æ•°(ä¸èƒ½ä¸€ä¸ªconstä¸€ä¸ªéconstæ··ç”¨)ã€‚

```cpp
#include <iostream>
using namespace std;

struct C
{
    int i;
    friend bool operator==(C, C) = default;
    //  error: defaulted â€˜bool operator==(C, C)â€™ only available with â€˜-std=c++20â€™ or â€˜-std=gnu++20â€™
};

int main(int argc, char **argv)
{
    return 0;
}
```

C++20çš„ä¸‰ç§é€‰æ‹©

```cpp
friend bool operator==(const C &, const C &) = default;
friend bool operator==(C, C) = default;
bool operator==(const C &) const = default;
```

## æ”¯æŒnewè¡¨è¾¾å¼æ¨å¯¼æ•°ç»„é•¿åº¦

ä¸€ç›´ä»¥æ¥ï¼ŒC++åœ¨å£°æ˜æ•°ç»„çš„æ—¶å€™éƒ½æ”¯æŒé€šè¿‡åˆå§‹åŒ–æ—¶çš„å…ƒç´ ä¸ªæ•°æ¨å¯¼æ•°ç»„é•¿åº¦ï¼Œå¦‚ï¼š

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int x[] = {1, 2, 3};
    char s[] = {"hello world"};
    char s1[]{"hello world"};
    std::cout << x[0] << " " << x[1] << " " << x[2] << std::endl; // 1 2 3
    std::cout << s << std::endl;                                  // hello world
    std::cout << s1 << std::endl;                                 // hello world
    return 0;
}
```

ä½†æ˜¯C++20ä¹‹å‰ä¸æ”¯æŒnewæ•°ç»„æ—¶è‡ªåŠ¨æ¨å¯¼ï¼ŒC++20å¾—åˆ°äº†æ”¯æŒã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int *x = new int[]{1, 2, 3};
    char *s = new char[]{"hello world"};

    std::cout << x[0] << " " << x[1] << " " << x[2] << std::endl; // 1 2 3
    std::cout << s << std::endl;                                  // hello world

    delete[] x;
    delete[] s;
    return 0;
}
```

## å…è®¸æ•°ç»„è½¬æ¢ä¸ºæœªçŸ¥èŒƒå›´çš„æ•°ç»„

C++20å…è®¸æ•°ç»„è½¬æ¢ä¸ºæœªçŸ¥èŒƒå›´çš„æ•°ç»„ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

void f(int (&)[]) {}
int arr[1]{0};

int main(int argc, char **argv)
{
    f(arr);
    int(&r)[] = arr;
    return 0;
}
```

å¯¹äºé‡è½½å‡½æ•°çš„æƒ…å†µï¼Œç¼–è¯‘å™¨ä¾æ—§ä¼šé€‰æ‹©æ›´ä¸ºç²¾å‡†åŒ¹é…çš„å‡½æ•°ï¼š

```cpp
#include <iostream>
using namespace std;

void f(int (&)[])
{
    std::cout << "void f(int (&)[])" << std::endl;
}

void f(int (&)[1])
{
    std::cout << "void f(int (&)[1])" << std::endl;
}

int arr[1]{0};

int main(int argc, char **argv)
{
    f(arr); // void f(int (&)[1])
    return 0;
}
```

## åœ¨deleteè¿ç®—ç¬¦å‡½æ•°ä¸­ææ„å¯¹è±¡

é€šå¸¸æƒ…å†µdeleteä¸€ä¸ªå¯¹è±¡ï¼Œç¼–è¯‘å™¨ä¼šå…ˆè°ƒç”¨è¯¥å¯¹è±¡çš„ææ„å‡½æ•°ï¼Œä¹‹åæ‰ä¼šè°ƒç”¨deleteè¿ç®—ç¬¦åˆ é™¤å†…å­˜ã€‚

```cpp
#include <iostream>
#include <new>
using namespace std;

struct X
{
    X()
    {
        std::cout << "X()" << std::endl;
    }
    ~X()
    {
        std::cout << "~X()" << std::endl;
    }

    void *operator new(size_t s)
    {
        std::cout << "void *operator new(size_t s)" << std::endl;
        return ::operator new(s);
    }

    void operator delete(void *ptr)
    {
        std::cout << "void operator delete(void *ptr)" << std::endl;
        ::operator delete(ptr);
    }
};

int main(int argc, char **argv)
{
    X *x = new X;
    delete x;
    // void *operator new(size_t s)
    // X()
    // ~X()
    // void operator delete(void *ptr)
    return 0;
}
```

ä¸Šé¢ä»£ç æœ‰ä¸ªé—®é¢˜å°±æ˜¯ï¼Œææ„å’Œé‡Šæ”¾å†…å­˜çš„æ“ä½œæ˜¯å®Œå…¨ç”±ç¼–è¯‘å™¨æ§åˆ¶çš„ï¼Œä½†æ˜¯ä»C++20å¼€å§‹
å¯ä»¥å°†å…¶åˆ†è§£å¼€æ¥ã€‚

```cpp
#include <iostream>
#include <new>
using namespace std;

struct X
{
    X()
    {
        std::cout << "X()" << std::endl;
    }
    ~X()
    {
        std::cout << "~X()" << std::endl;
    }

    void *operator new(size_t s)
    {
        std::cout << "void *operator new(size_t s)" << std::endl;
        return ::operator new(s);
    }

    void operator delete(X *ptr, std::destroying_delete_t)
    {
        ptr->~X(); // æ‰‹åŠ¨è°ƒç”¨ææ„å‡½æ•°
        std::cout << "void operator delete(X *ptr, std::destroying_delete_t)" << std::endl;
        ::operator delete(ptr);
    }
};

int main(int argc, char **argv)
{
    X *x = new X;
    delete x;
    // void *operator new(size_t s)
    // X()
    // ~X()
    // void operator delete(X *ptr, std::destroying_delete_t)
    return 0;
}
```

## è°ƒç”¨ä¼ªææ„å‡½æ•°ç»“æŸå¯¹è±¡å£°æ˜å‘¨æœŸ

C++20æ ‡å‡†å®Œå–„äº†è°ƒç”¨ä¼ªææ„å‡½æ•°ç»“æŸå¯¹è±¡å£°æ˜å‘¨æœŸçš„è§„åˆ™ï¼Œåœ¨è¿‡å»ï¼Œè°ƒç”¨ä¼ªææ„å‡½æ•°ä¼š
æ ¹æ®å¯¹è±¡çš„ä¸åŒæ‰§è¡Œä¸åŒçš„è¡Œä¸ºã€‚C++20ä¹‹å‰å½“Tä¸ºéå¹³å‡¡ç±»å‹æ—¶,`p->~T()`ä¼šç»“æŸå¯¹è±¡å£°æ˜å‘¨æœŸï¼›
å½“Tä¸ºå¹³å‡¡ç±»å‹æ—¶ï¼Œå¦‚intç±»å‹`p->~T()`ä¼šè¢«å½“åšæ— æ•ˆè¯­å¥ã€‚C++ä¿®ä¸äº†è¿™ä¸ªè¡Œä¸ºä¸ä¸€è‡´çš„è§„åˆ™ï¼Œå®ƒè§„å®šä¼ªææ„å‡½æ•°çš„è°ƒç”¨æ€»æ˜¯ä¼šç»“æŸå¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼Œå³ä½¿å¯¹è±¡æ˜¯ä¸€ä¸ªå¹³å‡¡ç±»å‹ã€‚

```cpp
#include <iostream>
using namespace std;

struct B
{
    B() = default;
    ~B()
    {
        std::cout << "~B()" << std::endl;
    }
    int a{0};
};

template <typename T>
void destroy(T *p)
{
    p->~T();
}

int main(int argc, char **argv)
{
    B *b = new B;
    destroy(b); //~B()
    ::free(b);
    // åœ¨C++20ä¹‹å‰ï¼Œè°ƒç”¨ä¼ªææ„å‡½æ•°ç»“æŸintå¯¹è±¡çš„å£°æ˜å‘¨æœŸå¯èƒ½è¢«è§†ä¸ºæ— æ•ˆ
    int x = 5;
    destroy(&x);
    std::cout << x << std::endl; // å®æµ‹GCC c++11å’Œc++20éƒ½æ˜¯è¾“å‡º5
    return 0;
}
```

## ä¿®å¤constå’Œé»˜è®¤å¤åˆ¶æ„é€ å‡½æ•°ä¸åŒ¹é…é€ æˆæ— æ³•ç¼–è¯‘çš„é—®é¢˜

ä¸‹é¢éœ€è¦å…³æ³¨çš„å°±æ˜¯ï¼ŒMyTypeæä¾›å¤åˆ¶æ„é€ å‡½æ•°å½¢å‚æ˜¯éconstçš„è€ŒWrapperæä¾›çš„æ˜¯constçš„ï¼Œè¿™æ˜¯ä¸ç¬¦åˆè§„å®šçš„ï¼Œ
constçš„ä¸èƒ½å…¼å®¹éconstçš„ï¼Œä½†æ˜¯C++20å¾—åˆ°äº†å…¼å®¹ï¼Œä½†æ˜¯GCCåœ¨C++17å°±å·²ç»åšäº†ä¼˜åŒ–ã€‚

```cpp
#include <iostream>
using namespace std;

struct MyType
{
    MyType() = default;
    MyType(MyType &){};
};

template <typename T>
struct Wrapper
{
    Wrapper() = default;
    Wrapper(const Wrapper &) = default;
    T t;
};

int main(int argc, char **argv)
{
    [[maybe_unused]] Wrapper<MyType> var;
    return 0;
}
```

ä¸è¿‡å®æµ‹æˆ‘çš„ç¯å¢ƒGCCæ˜¯ä»…æ”¯æŒä¸‹é¢çš„,æ€»ä¹‹æˆ‘ä»¬è¿˜æ˜¯å†™æœ€è§„èŒƒçš„ä»£ç å§ï¼Œåˆ«ç©ä»€ä¹ˆç¨€ç½•çš„èŠ±æ‹›ã€‚

```cpp
#include <iostream>
using namespace std;

struct MyType
{
    MyType() = default;
    MyType(const MyType &){};
};

template <typename T>
struct Wrapper
{
    Wrapper() = default;
    Wrapper(const Wrapper &) = default;
    T t;
};

int main(int argc, char **argv)
{
    [[maybe_unused]] Wrapper<MyType> var1;
    [[maybe_unused]] Wrapper<MyType> var2(var1);
    return 0;
}
```

## ä¸æ¨èä½¿ç”¨volatileçš„æƒ…å†µ

volatileå…³é”®å­—æ˜¯ç”¨æ¥å‘Šè¯‰ç¼–è¯‘å™¨ï¼Œè¢«å®ƒä¿®é¥°çš„å˜é‡å¯ä»¥è¢«æ„å¤–çš„ä¿®æ”¹ï¼Œå› æ­¤ç¼–è¯‘å™¨åœ¨ä¼˜åŒ–æ—¶ä¸åº”è¯¥å¯¹è¿™äº›å˜é‡çš„å­˜å–è¿›è¡Œä»»ä½•ä¼˜åŒ–ã€‚volatileå¹¶ä¸æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚ä¸»è¦ä½œç”¨åŒ…æ‹¬ï¼š

- ç¦æ­¢ç¼–è¯‘å™¨å¯¹å˜é‡çš„ä¼˜åŒ–ï¼šç¼–è¯‘å™¨åœ¨ä¼˜åŒ–ä»£ç æ—¶ï¼Œå¯èƒ½ä¼šå¯¹ä¸€äº›å˜é‡çš„è¯»å–å’Œå­˜å‚¨è¿›è¡Œä¼˜åŒ–ï¼Œä¾‹å¦‚ï¼Œå°†å˜é‡ç¼“å­˜åˆ°å¯„å­˜å™¨ä¸­ã€‚ç„¶è€Œï¼Œå¦‚æœè¿™ä¸ªå˜é‡å¯èƒ½è¢«å¤–éƒ¨å› ç´ ä¿®æ”¹ï¼Œå¦‚ä¸­æ–­æœåŠ¡ç¨‹åºï¼Œç¡¬ä»¶æ“ä½œç­‰ï¼Œåˆ™ä¼šå¯¼è‡´ç¨‹åºçš„è¡Œä¸ºå‡ºç°é—®é¢˜ã€‚ä½¿ç”¨ volatile å…³é”®å­—å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨ä¸è¦å¯¹è¿™äº›å˜é‡è¿›è¡Œä¼˜åŒ–ï¼Œæ¯æ¬¡éƒ½è¦ä»å†…å­˜ä¸­è¯»å–æˆ–å†™å…¥å˜é‡çš„å€¼ã€‚
- ä¸ç¡¬ä»¶ç›¸å…³çš„å˜é‡ï¼šåœ¨åµŒå…¥å¼ç³»ç»Ÿæˆ–ä¸ç¡¬ä»¶ç›¸å…³çš„ç¨‹åºä¸­ï¼Œç»å¸¸éœ€è¦ä½¿ç”¨ volatile å…³é”®å­—æ¥å£°æ˜ä¸ç¡¬ä»¶å¯„å­˜å™¨é€šä¿¡çš„å˜é‡ã€‚è¿™äº›å¯„å­˜å™¨çš„å€¼å¯èƒ½ä¼šåœ¨ç¨‹åºçš„è¿è¡ŒæœŸé—´è¢«å¤–éƒ¨è®¾å¤‡ä¿®æ”¹ï¼Œå› æ­¤éœ€è¦ä½¿ç”¨ volatile æ¥ç¡®ä¿å¯¹è¿™äº›å˜é‡çš„è¯»å–å’Œå†™å…¥æ˜¯åŠæ—¶æœ‰æ•ˆçš„ã€‚
- çº¿ç¨‹é—´é€šä¿¡ï¼šåœ¨å¤šçº¿ç¨‹ç¼–ç¨‹ä¸­ï¼Œå¦‚æœä¸€ä¸ªå˜é‡è¢«å¤šä¸ªçº¿ç¨‹å…±äº«å¹¶ä¸”å¯èƒ½è¢«ä¸€ä¸ªçº¿ç¨‹ä¿®æ”¹ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹è¯»å–ï¼Œé‚£ä¹ˆè¿™ä¸ªå˜é‡é€šå¸¸éœ€è¦å£°æ˜ä¸º volatileã€‚è¿™å¯ä»¥ç¡®ä¿çº¿ç¨‹ä¹‹é—´çš„å¯è§æ€§ï¼Œå³ä¸€ä¸ªçº¿ç¨‹å¯¹å˜é‡çš„ä¿®æ”¹ä¼šç«‹å³è¢«å…¶ä»–çº¿ç¨‹çœ‹åˆ°ã€‚
æ€»ä¹‹ï¼Œvolatileå…³é”®å­—ä¸»è¦ç”¨äºå‘Šè¯‰ç¼–è¯‘å™¨è¿™ä¸ªå˜é‡å…·æœ‰æ˜“å¤±æ€§ï¼ˆvolatileï¼‰ï¼Œå¯èƒ½è¢«å¤–éƒ¨å› ç´ ä¿®æ”¹ï¼Œå› æ­¤ç¼–è¯‘å™¨ä¸åº”è¯¥å¯¹å…¶è¿›è¡Œä¼˜åŒ–ã€‚

- ä¸æ¨èç®—æœ¯ç±»å‹çš„åç¼€`++`å’Œ`--`è¡¨è¾¾å¼ä»¥åŠå‰ç¼€`++`å’Œ`--`ä½¿ç”¨è¡¨è¾¾å¼volatileé™å®šç¬¦ã€‚

```cpp
volatile int d = 5;
d++;
--d;
```

- ä¸æ¨èéç±»ç±»å‹å·¦æ“ä½œæ•°çš„èµ‹å€¼ä½¿ç”¨volatileé™å®šç¬¦

```cpp
volatile int d = 5;
d += 2;
d *= 3;
```

- ä¸æ¨èå‡½æ•°å½¢å‚å’Œè¿”å›ç±»å‹ä½¿ç”¨volatileé™å®šç¬¦

```cpp
volatile int f() { return 1;}
int g(volatile int v) {return v;}
```

- ä¸æ¨èç»“æ„åŒ–ç»‘å®šä½¿ç”¨volatileé™å®šç¬¦

```cpp
struct X
{
 int a;
 short b;
};
X x{ 11, 7 };
volatile auto [a,b] = x;
```

ä»¥ä¸Š4ç§æƒ…å†µåœ¨C++20æ ‡å‡†çš„ç¼–è¯‘ç¯å¢ƒä¸­ç¼–è¯‘éƒ½ä¼šç»™å‡ºÂ·`volatile - qualified type is deprecated`çš„è­¦å‘Šä¿¡æ¯ã€‚

å…¶å®è¿™é‡Œvolatileçš„å†…å®¹ï¼Œä¸æ˜¯è¯´è¿™æ ·ç”¨æ˜¯é”™è¯¯ï¼Œåªä¸è¿‡å®¹æ˜“ç»™äººé€ æˆè¯¯è§£ï¼Œæœ‰å¾ˆå¤šäººè¯¯ä»¥ä¸ºvolatileæ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚

## ä¸æ¨èåœ¨ä¸‹æ ‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨é€—å·è¿ç®—ç¬¦

é€—å·è¿ç®—ç¬¦å¯ä»¥è®©å¤šä¸ªè¡¨è¾¾å¼æŒ‰ç…§ä»å·¦å¾€å³çš„é¡ºåºè¿›è¡Œè®¡ç®—ï¼Œæ•´ä½“çš„ç»“æœä¸ºç³»åˆ—ç§æœ€åä¸€ä¸ªè¡¨è¾¾å¼çš„å€¼ã€‚

```cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int a[]{1, 2, 3};
    int x = 1, y = 2;
    std::cout << a[x, y]; // 3
    return 0;
}

// /mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp:8:21: warning: top-level comma expression in array subscript is deprecated [-Wcomma-subscript]
//     8 |     std::cout << a[x, y];
//       |                     ^
// /mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/main.cpp:8:20: warning: left operand of comma operator has no effect [-Wunused-value]
//     8 |     std::cout << a[x, y];
```

C++20å¼€å§‹ä¸Šé¢çš„ä»£ç ä¼šç»™å‡ºè­¦å‘Šï¼Œå¦‚æœä»æ—§æƒ³è¿™ä¹ˆç”¨å¯ä»¥ä½¿ç”¨

```cpp
std::cout << a[(x, y)]; // 3
```

## æ¨¡å—

æ¨¡å—(module)æ˜¯C++20æ ‡å‡†å¼•å…¥çš„ä¸€ä¸ªæ–°ç‰¹æ€§ï¼Œå®ƒçš„ä¸»è¦ç”¨é€”æ˜¯å°†å¤§å‹å·¥ç¨‹ä¸­çš„ä»£ç æ‹†åˆ†æˆç‹¬ç«‹çš„é€»è¾‘å•å…ƒï¼Œä»¥æ–¹ä¾¿å¤§å‹å·¥ç¨‹çš„ä»£ç ç®¡ç†ã€‚æ¨¡å—èƒ½å¤Ÿå¤§å¤§å‡å°‘ä½¿ç”¨å¤´æ–‡ä»¶å¸¦æ¥çš„é—®é¢˜ï¼Œä¾‹å¦‚åœ¨ä½¿ç”¨å¤´æ–‡ä»¶æ—¶ç»å¸¸ä¼šé‡åˆ°å®å’Œå‡½æ•°çš„é‡å®šä¹‰ï¼Œè€Œæ¨¡å—åˆ™ä¼šå¥½å¾ˆå¤šï¼Œå› ä¸ºå®å’Œæœªå¯¼å‡ºåç§°å¯¹äºå¯¼å…¥æ¨¡å—æ˜¯ä¸å¯è§çš„ã€‚ä½¿ç”¨æ¨¡å—ä¹Ÿèƒ½å¤§å¹…æå‡ç¼–è¯‘æ•ˆç‡ï¼Œå› ä¸ºç¼–è¯‘åçš„æ¨¡å—ä¿¡æ¯ä¼šå­˜å‚¨åœ¨ä¸€ä¸ªäºŒè¿›åˆ¶æ–‡ä»¶ä¸­ï¼Œç¼–è¯‘å™¨å¯¹äºå®ƒçš„å¤„ç†é€Ÿåº¦è¦è¿œå¿«äºå•çº¯ä½¿ç”¨æ–‡æœ¬æ›¿æ¢çš„å¤´æ–‡ä»¶æ–¹æ³•ã€‚å¯æƒœåˆ°ç›®å‰ä¸ºæ­¢å¹¶æ²¡æœ‰ä¸»æµç¼–è¯‘å™¨å®Œå…¨æ”¯æŒè¯¥ç‰¹æ€§ï¼Œæ‰€ä»¥è¿™é‡Œåªåšç®€å•ä»‹ç»ï¼š

```cpp
// main1.cpp
export module helloworld;
import std.core;

export void hello()
{
    std::cout << "hello world" << std::endl;
}
```

```cpp
// main.cpp
import helloworld;

int main(int argc, char **argv)
{
    hello();
    return 0;
}
```

## lambdaè¡¨è¾¾å¼åˆå§‹åŒ–æ•è·çš„åŒ…å±•å¼€

lambdaè¡¨è¾¾å¼ä½¿ç”¨å¯å˜å‚æ•°æ¨¡æ¿æœ‰è¿™ä¹ˆä¸€ä¸ªä¾‹å­

```cpp
// ä½¿ç”¨ decltype(auto) å¯ä»¥ç¡®ä¿è¿”å›ç±»å‹ä¸ std::invoke(f, args...) çš„è¿”å›ç±»å‹å®Œå…¨ä¸€è‡´ï¼ŒåŒ…æ‹¬å¼•ç”¨å’Œcv é™å®šç¬¦ã€‚è€Œä½¿ç”¨ auto åˆ™åªæ˜¯æ ¹æ®è¡¨è¾¾å¼çš„è¿”å›ç±»å‹è¿›è¡Œæ¨å¯¼ï¼Œä¸ä¸€å®šä¼šå®Œå…¨ä¿ç•™std::invoke(f, args...) çš„ç±»å‹ç‰¹æ€§ã€‚

template <class F, class..Args>
auto delay_invoke(F f, Args... args)
{
    return [f, args...]() -> decltype(auto)
    {
        return std::invoke(f, args...);
    }
}
```

è¿™é‡Œæœ‰ä¸ªé—®é¢˜å°±æ˜¯ï¼ŒæŒ‰å€¼æ•è·çš„æ€§èƒ½é—®é¢˜ï¼Œå¦‚æœdelay_invokeä¼ é€’çš„å®å‚éƒ½æ˜¯å¤æ‚çš„æ•°æ®ç»“æ„ä¸”æ•°æ®é‡éå¸¸å¤§ï¼Œè¿™ç§æŒ‰å€¼æ•è·æ˜¾ç„¶ä¸æ˜¯ä¸€ä¸ªç†æƒ³çŠ¶æ€ã€‚å¦‚æœç”¨å¼•ç”¨æ•è·ï¼Œåœ¨delay_invokeçš„ä½¿ç”¨åœºæ™¯ä¸‹å¾ˆå®¹æ˜“é€ æˆæœªå®šä¹‰çš„ç»“æœã€‚

å¯ä»¥ç»“åˆåˆå§‹åŒ–æ•è·å’Œç§»åŠ¨è¯­ä¹‰ã€‚

```cpp
#include <iostream>
#include <tuple>
using namespace std;

template <class F, class... Args>
auto delay_invoke(F f, Args... args)
{
    return [f = std::move(f), tup = std::make_tuple(std::move(args)...)]() -> decltype(auto)
    {
        // std::apply å¯ä»¥å°†å…ƒç»„çš„å…ƒç´ ä½œä¸ºå‚æ•°ä¼ é€’ç»™å‡½æ•°æˆ–è€…å‡½æ•°å¯¹è±¡ã€‚
        return std::apply(f, tup);
    };
}

// template <class F, class... Args>
// auto delay_invoke(F f, Args... args)
// {

//     class __lambda_8_12
//     {
//     public:
//         inline decltype(auto) operator()() const
//         {
//             return std::apply(f, tup);
//         }

//     private:
//         auto f;
//         auto tup;

//     public:
//         __lambda_8_12(auto _f, auto _tup)
//             : f{_f}, tup{_tup}
//         {
//         }

//     } __lambda_8_12{std::move(f), std::make_tuple(std::move(args)...)};

//     return __lambda_8_12;
// }

int add(int a, int b, int c)
{
    return a + b + c;
}

int main(int argc, char **argv)
{
    auto f = delay_invoke(add, 2, 3, 4);
    auto res = f();
    std::cout << res << std::endl; // 9
    return 0;
}
```

C++20æ”¯æŒlambdaè¡¨è¾¾å¼åˆå§‹åŒ–æ•è·çš„åŒ…å±•å¼€ã€‚

```cpp
#include <iostream>
#include <functional>
using namespace std;

template <class F, class... Args>
auto delay_invoke(F f, Args... args)
{
    return [f = std::move(f), ... args = std::move(args)]() -> decltype(auto)
    {
        return std::invoke(f, args...);
    };
}

int main(int argc, char **argv)
{
    auto f = delay_invoke([](int a, int b, int c) -> int
                          { return a + b + c; },
                          1, 2, 3);
    auto res = f();
    std::cout << res << std::endl; // 6
    return 0;
}
```

## å‡å°‘typenameä½¿ç”¨çš„å¿…è¦æ€§

å½“ä½¿ç”¨æœªå†³ç±»å‹çš„å†…åµŒç±»å‹æ—¶ï¼Œä¾‹å¦‚`X<T>::Y`ï¼Œéœ€è¦ä½¿ç”¨typenameæ˜ç¡®å‘ŠçŸ¥ç¼–è¯‘å™¨`X<T>::Y`
æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå¦åˆ™ç¼–è¯‘å™¨ä¼šå°†å…¶å½“åšä¸€ä¸ªè¡¨è¾¾å¼çš„åç§°ï¼Œæ¯”å¦‚ä¸€ä¸ªé™æ€æ•°æ®æˆå‘˜æˆ–è€…é™æ€æˆå‘˜å‡½æ•°ã€‚

```cpp
template<class T> void f(T::R);
template<class T> void f(typename T::R);
```

åœ¨C++20ä¹‹å‰ï¼Œæœ‰ä¸¤ç§æƒ…å†µä¾‹å¤–ï¼Œåˆ†åˆ«æ˜¯æŒ‡å®šåŸºç±»å’Œæˆå‘˜åˆå§‹åŒ–ï¼Œå¦‚

```cpp
#include <iostream>
using namespace std;

struct Impl
{
};

struct Wrap
{
    using B = Impl;
};

template <class T>
struct D : T::B
{
    D() : T::B() {}
};

int main(int argc, char **argv)
{
    D<Wrap> var;
    return 0;
}
```

è¿˜æœ‰å…¶ä»–æƒ…å†µä»è¯­ä¹‰ä¸­æ˜ç¡®åœ°åˆ¤æ–­å‡º`X<T>::Y`è¡¨ç¤ºçš„æ˜¯ç±»å‹ï¼Œæ¯”å¦‚ä½¿ç”¨usingåˆ›å»ºç±»å‹åˆ«å

```cpp
using R = typename T::B;
// è¿™é‡Œçš„typenameå®Œå…¨æ²¡å¿…è¦
```

åœ¨C++20ä¸­ï¼Œå¢åŠ äº†ä¸€äº›æƒ…å†µå¯ä»¥è®©æˆ‘ä»¬çœç•¥typenameå…³é”®è¯ã€‚

- åœ¨ä¸Šä¸‹æ–‡ä»…å¯èƒ½æ˜¯ç±»å‹æ ‡è¯†çš„æƒ…å†µï¼Œå¯ä»¥å¿½ç•¥typename

```cpp
// static_castã€const_castã€reinterpret_castæˆ–dynamic_castç­‰ç±»å‹è½¬æ¢
static_cast<T::B>(p);
// å®šä¹‰ç±»å‹åˆ«å
using R = T::B;
// åç½®è¿”å›ç±»å‹
auto g() -> T::B;
// æ¨¡æ¿ç±»å‹å½¢å‚çš„é»˜è®¤å‚æ•°
template<class R = T::B>
struct X;
```

- å…¶ä»–æƒ…å†µç­‰

```cpp
// å…¨å±€æˆ–è€…å‘½åç©ºé—´ä¸­ç®€å•çš„å£°æ˜æˆ–è€…å‡½æ•°çš„å®šä¹‰
template<class T>
T::R f();
// ç»“æ„ä½“çš„æˆå‘˜
template<class T>
struct D : T::B
{
 D() : T::B(){}
 T::B b; // ç¼–è¯‘æˆåŠŸ
};
// ä½œä¸º æˆå‘˜å‡½æ•°æˆ–è€…lambdaè¡¨è¾¾å¼ å½¢å‚å£°æ˜
template<class T>
struct D : T::B
{
 D() : T::B(){}
 T::B f(T::B){ return T::B(); } // C++20å¯ç¼–è¯‘
};
```

æ€»ä¹‹è¿™ç§ä¸è¦è®°ï¼Œæ¯•ç«Ÿæˆ‘ä»¬è°ä¸ç”¨IDEå‘¢ï¼Œè¿™ç§ä¸œè¥¿äº†è§£ç‚¹å°±å¥½ï¼Œæ¯ä¸ªæ–°ç‰ˆæœ¬å‡ ä¹éƒ½ä¼šè§£å†³ä¸€äº›å†å²åŸå› ç»™å¼€å‘å†™ä»£ç å¸¦æ¥çš„ä¸€äº›é™åˆ¶ï¼Œä½†æ˜¯äººä»¬å¾€å¾€è¿˜æƒ³ç°åœ¨å†™çš„ä»£ç å¯ä»¥åœ¨ä½ç‰ˆæœ¬C++å»ç¼–è¯‘ï¼ŒçœŸæ˜¯å¤§å‚»é€¼ï¼Œæ‰€ä»¥ç§¯ææ‹¥æŠ±æ–°ç‰¹æ€§å§ï¼Œç¡®å®çˆ½
å„ç§è¯­æ³•ç³–ã€‚

## æ¨¡æ¿å‚æ•°ä¼˜åŒ–

### C++ ADL æ˜¯ä»€ä¹ˆ

C++çš„ADLï¼ˆArgument-Dependent Lookupï¼‰ï¼Œä¹Ÿç§°ä¸ºKoenigæŸ¥æ‰¾ï¼ˆKoenig Lookupï¼‰ï¼Œæ˜¯ä¸€ç§åç§°æŸ¥æ‰¾è§„åˆ™ï¼Œç”¨äºç¡®å®šå‡½æ•°è°ƒç”¨æ—¶æ‰€æ¶‰åŠçš„å‘½åç©ºé—´èŒƒå›´ã€‚ADLå…è®¸åœ¨å‡½æ•°è°ƒç”¨ä¸­ä½¿ç”¨çš„å‘½åç©ºé—´æ‰©å±•åˆ°å‡½æ•°å‚æ•°çš„å‘½åç©ºé—´ã€‚è¿™ç§æŸ¥æ‰¾è§„åˆ™ä½¿å¾—åœ¨C++ä¸­æ›´å®¹æ˜“åœ°ç¼–å†™é€šç”¨ä»£ç ï¼Œå¹¶ä¸”æœ‰åŠ©äºå®ç°â€œæ¥å£ä¸å®ç°åˆ†ç¦»â€çš„è®¾è®¡æ€æƒ³ã€‚

å½“åœ¨ä¸€ä¸ªå‡½æ•°è°ƒç”¨ä¸­ä½¿ç”¨æŸä¸ªå‡½æ•°åä½œä¸ºå®å‚ï¼Œä½†è¯¥å‡½æ•°åå¹¶éå®šä¹‰åœ¨å‡½æ•°æ‰€åœ¨çš„å‘½åç©ºé—´å†…æ—¶ï¼Œç¼–è¯‘å™¨ä¼šå°è¯•åœ¨å®å‚ç±»å‹æ‰€å±çš„å‘½åç©ºé—´ä¸­æŸ¥æ‰¾è¿™ä¸ªå‡½æ•°åã€‚è¿™ç§æŸ¥æ‰¾è§„åˆ™é€‚ç”¨äºéæˆå‘˜å‡½æ•°ã€å‹å…ƒå‡½æ•°å’Œæ“ä½œç¬¦é‡è½½ã€‚

```cpp
#include <iostream>
using namespace std;

namespace NS
{
    struct X
    {
    };
    void foo(X)
    {
        std::cout << "foo from NS" << std::endl;
    }
}

int main()
{
    NS::X x;
    foo(x); // åœ¨æ­¤å¤„è°ƒç”¨fooï¼Œå‡½æ•°fooå¹¶æœªç›´æ¥å®šä¹‰åœ¨mainå‡½æ•°æ‰€åœ¨çš„å‘½åç©ºé—´å†…ï¼Œä½†æ˜¯é€šè¿‡ADLï¼Œç¼–è¯‘å™¨ä¼šåœ¨NSå‘½åç©ºé—´å†…æŸ¥æ‰¾fooå‡½æ•°
    return 0;
}
```

### å‡½æ•°æ¨¡æ¿æ·»åŠ åˆ°ADLæŸ¥æ‰¾è§„åˆ™

åœ¨C++20ä¹‹å‰ï¼ŒADLçš„æŸ¥æ‰¾è§„åˆ™æ˜¯ä¸èƒ½æŸ¥æ‰¾åˆ°å¸¦æ˜¾å¼æŒ‡å®šæ¨¡æ¿å®å‚çš„å‡½æ•°æ¨¡æ¿çš„

```cpp
#include <iostream>
using namespace std;

namespace N
{
    struct A
    {
    };
    template <class T>
    int f(T t) { return 1; }
};

int main(int argc, char **argv)
{
    // C++17 å¤§å¤šæ•°ç¼–è¯‘å™¨æ‰¾ä¸åˆ°å‡½æ•°f æˆ–è€…æœ‰çš„è­¦å‘Šæ˜¯å¦è¦è°ƒç”¨N::f
    int x = f<N::A>(N::A());
    return 0;
}
```

ä½†æ˜¯æœ‰ä¸ªé—®é¢˜ï¼Œæ˜æ˜å¯ä»¥è¿™æ ·å†™,why not? å†™ä»£ç æ›´åŠ æ¸…æ™°

```cpp
NS::foo<NS::X>(x);
```

C++20ä¸­ADLä¹Ÿä¸æ˜¯ä¸‡èƒ½çš„ä¹Ÿä¼šå‡ºç°ä¸‹é¢è¡Œä¸é€šçš„æƒ…å†µ

```cpp
#include <iostream>
using namespace std;

int h = 0;
void g() {}
namespace N
{
    struct A
    {
    };
    template <class T>
    int f(T) { return 1; }
    template <class T>
    int g(T) { return 2; }
    template <class T>
    int h(T) { return 3; }
}

int main(int argc, char **argv)
{
    int x = f<N::A>(N::A());    // ç¼–è¯‘æˆåŠŸ æŸ¥æ‰¾fæ²¡æœ‰æ‰¾åˆ°ä»»ä½•å®šä¹‰ï¼Œfè¢«è®¤ä¸ºæ˜¯æ¨¡æ¿
    int y = f<N::A>(N::A());    // ç¼–è¯‘æˆåŠŸ æŸ¥æ‰¾gæ‰¾åˆ°ä¸€ä¸ªå‡½æ•° gè¢«è®¤ä¸ºæ˜¯æ¨¡æ¿
    int z = h<N::A>(N::A());    // ç¼–è¯‘å¤±è´¥
    int q = N::h<N::A>(N::A()); // ç¼–è¯‘æˆåŠŸ
    return 0;
}
```

### å…è®¸éç±»å‹æ¨¡æ¿å½¢å‚ä¸­çš„å­—é¢é‡ç±»ç±»å‹

C++20ä¹‹å‰ï¼Œéç±»å‹æ¨¡æ¿å½¢å‚å¯ä»¥æ˜¯æ•´æ•°ç±»å‹ã€æšä¸¾ç±»å‹ã€æŒ‡é’ˆç±»å‹ã€å¼•ç”¨ç±»å‹å’Œ`std::nullptr_t`,è€Œç±»ç±»å‹æ˜¯ä¸å¯ä»¥çš„ã€‚

```cpp
#include <iostream>
using namespace std;

struct A
{
};

template <A a>
struct B
{
};

int main(int argc, char **argv)
{
    A a;
    B<a> b; // C++20ä¹‹å‰ç¼–è¯‘å¤±è´¥
    return 0;
}
```

C++20å¼€å§‹ï¼Œå­—é¢é‡ç±»ç±»å‹(literal class)å¯ä»¥ä½œä¸ºå½¢å‚åœ¨éç±»å‹æ¨¡æ¿å½¢å‚åˆ—è¡¨ä¸­ä½¿ç”¨äº†ã€‚

1. æ‰€æœ‰åŸºç±»å’Œéé™æ€æ•°æ®æˆå‘˜éƒ½æ˜¯å…¬å¼€ä¸”ä¸å¯å˜çš„
2. æ‰€æœ‰åŸºç±»å’Œéé™æ€æ•°æ®æˆå‘˜çš„ç±»å‹éƒ½æ˜¯æ ‡é‡ç±»å‹ã€å·¦å€¼å¼•ç”¨æˆ–è€…å‰è€…çš„æ•°ç»„ï¼ˆå¯èƒ½æ˜¯å¤šç»´ï¼‰ã€‚

å› ä¸ºæ¨¡æ¿å®å‚ä¸æ”¯æŒå­—ç¬¦ä¸²å­—é¢é‡ï¼Œç°åœ¨æˆ‘ä»¬å¯ä»¥è‡ªå®šä¹‰ç±»ç±»å‹äº†

```cpp
#include <iostream>
using namespace std;

template <typename T, std::size_t N>
struct basic_fixed_string
{
    constexpr basic_fixed_string(const T (&foo)[N + 1])
    {
        std::copy_n(foo, N + 1, data_);
    }
    T data_[N + 1];
};

// C++17 å‡½æ•°æ¨¡æ¿çš„æ¨å¯¼å¼•å¯¼(function template deduction guide)
// è¿™ä¸ªç‰¹æ€§çš„ä¸»è¦ç›®çš„æ˜¯ç®€åŒ–æ¨¡æ¿çš„ä½¿ç”¨ï¼Œå°¤å…¶æ˜¯å½“æ¨¡æ¿å‚æ•°å¯ä»¥ä»å…¶ä»–å‚æ•°æ¨å¯¼å‡ºæ¥æ—¶ã€‚
// é€šè¿‡ä½¿ç”¨ç±»æ¨¡æ¿å‚æ•°æ¨å¯¼ï¼Œå¯ä»¥åœ¨å‡½æ•°è¿”å›ç±»å‹ä¸­ä½¿ç”¨å¤æ‚çš„è¡¨è¾¾å¼ï¼Œä»¥ä¾¿æ›´æ–¹ä¾¿åœ°æ¨å¯¼æ¨¡æ¿å‚æ•°ã€‚
template <typename T, std::size_t N>
basic_fixed_string(const T (&str)[N]) -> basic_fixed_string<T, N - 1>;

template <basic_fixed_string Str>
struct X
{
    X()
    {
        std::cout << Str.data_ << std::endl;
    }
};

int main(int argc, char **argv)
{
    X<"Hello World"> x; // Hello World
    return 0;
}
```

## ç±»æ¨¡æ¿çš„æ¨¡æ¿å®å‚æ¨å¯¼

### åˆ«åæ¨¡æ¿çš„ç±»æ¨¡æ¿å®å‚æ¨å¯¼

C++20æ”¯æŒäº†åˆ«åæ¨¡æ¿çš„ç±»æ¨¡æ¿å®å‚æ¨å¯¼ã€‚å®æµ‹GCCä¸è¡Œï¼Œæ— æ³•é€šè¿‡ç¼–è¯‘

```cpp
#include <iostream>
using namespace std;

template <class T, class U>
struct X
{
    X(T, U) {}
};

template <class V>
using A = X<V *, V *>;

int main(int argc, char **argv)
{
    int i;
    double d;

    A a1(&i, &i); // å¯ä»¥æ¨å¯¼ä¸ºA<int>
    // A a2(i, i); // iæ— æ³•æ¨å¯¼ä¸ºV*
    // A a3(&i, &d); // (int*, double*)æ— æ³•æ¨å¯¼ä¸º(V*, V*)
    return 0;
}
```

### èšåˆç±»å‹çš„ç±»æ¨¡æ¿å®å‚æ¨å¯¼

é™¤äº†åˆ«åæ¨¡æ¿ï¼ŒC++20è¿˜è§„å®šèšåˆç±»å‹ä¹Ÿå¯ä»¥è¿›è¡Œç±»æ¨¡æ¿çš„å®å‚æ¨å¯¼

```cpp
#include <iostream>
using namespace std;

template <class T>
struct S
{
    T x;
    T y;
};

int main(int argc, char **argv)
{
    S s1{1, 2}; // S<int> s1
    // S s2{1, 2u}; //æ— æ³•æ¨å¯¼ç±»æ¨¡æ¿å‚æ•°
    return 0;
}
```

åµŒå¥—èšåˆç±»å‹,ä¸‹é¢ä»£ç å¯¹äºXçš„Tä¸æ˜¯ç”±`{1,2}`æ¨å¯¼å‡ºæ¥çš„ï¼Œè€Œæ˜¯ç”±`4`æ¨å¯¼å‡ºæ¥çš„

```cpp
#include <iostream>
using namespace std;

template <class T>
struct S
{
    T x;
    T y;
};

template <class T, class U>
struct X
{
    S<T> s;
    U u;
    T t;
};

int main(int argc, char **argv)
{
    X x{{1, 2}, 3u, 4};
    return 0;
}
```

å¦‚æœæ˜¾å¼åˆ¶æŒ‡å®šäº†ï¼Œ`S<T>`çš„æ¨¡æ¿å®å‚ï¼Œåˆ™åˆå§‹åŒ–åˆ—è¡¨çš„å­æ‹¬å·å¯ä»¥å¿½ç•¥

```cpp
#include <iostream>
using namespace std;

template <class T>
struct S
{
    T x;
    T y;
};

template <class T, class U>
struct X
{
    S<int> s;
    U u;
    T t;
};

int main(int argc, char **argv)
{
    X x{1, 2, 3u, 4};
    return 0;
}
```

C++20è¿˜è§„å®šï¼Œèšåˆç±»å‹ä¸­çš„æ•°ç»„ä¹Ÿå¯ä»¥æ˜¯æ¨å¯¼å¯¹è±¡ã€‚

```cpp
#include <iostream>
using namespace std;

template <class T, std::size_t N>
struct A
{
    T array[N];
};

template <typename T>
struct B
{
    T array[2];
};

int main(int argc, char **argv)
{
    A a{{1, 2, 3, 4}};
    B b = {0, 1};
    return 0;
}
```

## æ¦‚å¿µå’Œçº¦æŸ

æœ¬è´¾å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹å¢æ™®çš„ä¸€å¥è¯ï¼šâ€œå°è¯•ä½¿ç”¨æ¦‚å¿µï¼å®ƒä»¬å°†æå¤§åœ°æ”¹å–„è¯»è€…çš„é€šç”¨ç¼–ç¨‹ï¼Œå¹¶è®©å½“å‰ä½¿ç”¨çš„å˜é€šæ–¹æ³•ï¼ˆä¾‹å¦‚traitsç±»ï¼‰å’Œ ä½çº§æŠ€æœ¯ï¼ˆä¾‹å¦‚åŸºäºenable_ifçš„é‡è½½ï¼‰æ„Ÿè§‰å°±åƒæ˜¯å®¹æ˜“å‡ºé”™å’Œçƒ¦ççš„æ±‡ç¼–ç¼–ç¨‹â€ã€‚

### ä½¿ç”¨std::enable_ifçº¦æŸæ¨¡æ¿

```cpp
#include <iostream>
#include <string>
using namespace std;

template <class T, class U = std::enable_if_t<std::is_integral_v<T>>>
struct X
{
};

template <typename T>
std::enable_if_t<std::is_integral_v<T>, void> foo(T value)
{
    std::cout << "This is an integral type" << std::endl;
}

template <typename T>
std::enable_if_t<!std::is_integral_v<T>, void> foo(T value)
{
    std::cout << "This is not an integral type" << std::endl;
}

int main(int argc, char **argv)
{
    X<int> x1; // X<int> x1 ç¼–è¯‘æˆåŠŸ
    // X<std::string> x2; // ç¼–è¯‘é”™è¯¯
    X<std::string, void> x3; // ç¼–è¯‘æˆåŠŸ

    foo(1);                    // This is an integral type
    foo(std::string("hello")); // This is not an integral type
    return 0;
}
```

å¯¹äºx2æ— æ³•æ¨åˆ°å‡ºXçš„Uçš„é»˜è®¤å®å‚ï¼Œæ‰€ä»¥å¿…é¡»æä¾›ä¸¤ä¸ªå®å‚ã€‚è€Œx1åˆ™æ¨åˆ°ä¸ºäº†`X<int,void>`

æˆ‘ä»¬ä¹Ÿå¯ä»¥ç®€å•å®ç°enable_if

```cpp
#include <iostream>
using namespace std;

template <bool B, class T = void>
struct my_enable_if
{
};

template <class T>
struct my_enable_if<true, T>
{
    using type = T;
};

int main(int argc, char **argv)
{
    // my_enable_if<false, int>::type; // ç±» "my_enable_if<false, int>" æ²¡æœ‰æˆå‘˜ "type"
    my_enable_if<true, int>::type n = 11;
    std::cout << n << std::endl; // 11
    return 0;
}
```

å¯ä»¥çœ‹åˆ°enable_ifçš„å®ç°ååˆ†ç®€å•ï¼Œè€Œè®©å®ƒå‘æŒ¥å¦‚æ­¤å¤§ä½œç”¨çš„å¹•ååŠŸè‡£å°±æ˜¯SFINAEè§„åˆ™ã€‚
ä¸è¿‡ä½¿ç”¨`std::enable_if`ä½œä¸ºæ¨¡æ¿å®å‚çº¦æŸä¹Ÿæœ‰ä¸€äº›ç¡¬ä¼¤ï¼Œæ¯”å¦‚ä½¿ç”¨èŒƒå›´çª„ï¼Œéœ€è¦åŠ å…¥é¢å¤–çš„æ¨¡æ¿å½¢å‚ç­‰ã€‚
äºæ˜¯ä¸ºäº†æ›´å¥½åœ°å¯¹æ¨¡æ¿è¿›è¡Œçº¦æŸï¼ŒC++20æ ‡å‡†å¼•å…¥äº†`æ¦‚å¿µï¼ˆconceptï¼‰`ã€‚

### æ¦‚å¿µçš„èƒŒæ™¯ä»‹ç»

æ¦‚å¿µæ˜¯å¯¹C++æ ¸å¿ƒè¯­è¨€ç‰¹æ€§ä¸­æ¨¡æ¿åŠŸèƒ½çš„æ‰©å±•ã€‚å®ƒåœ¨ç¼–è¯‘æ—¶è¿›è¡Œè¯„ä¼°ï¼Œå¯¹ç±»æ¨¡æ¿ã€å‡½æ•°æ¨¡æ¿ä»¥åŠç±»æ¨¡æ¿çš„æˆå‘˜å‡½æ•°è¿›è¡Œçº¦æŸï¼šå®ƒé™åˆ¶äº†èƒ½è¢«æ¥å—ä¸ºæ¨¡æ¿å½¢å‚çš„å®å‚é›†ã€‚

```cpp
#include <iostream>
using namespace std;

template <class C>
concept IntegerType = std::is_integral_v<C>;

template <IntegerType T>
struct X
{
    T t;
};

int main(int argc, char **argv)
{
    X<int> x1{1};
    X x2{2};
    // X<std::string> x3; // ç¼–è¯‘å¤±è´¥
    std::cout << x1.t << " " << x2.t << std::endl; // 1 2
    return 0;
}
```

å¯¹äºXçš„æ¨¡æ¿å‚æ•°Tå¿…é¡»æ»¡è¶³ `std::is_integral_v` ä¸ºtrue;

ä¸Šé¢ä»£ç è¿˜å¯ä»¥ä½¿ç”¨requireså…³é”®å­—è¿›è¡Œä»£æ›¿ï¼Œç›´æ¥çº¦æŸæ¨¡æ¿å½¢å‚Tï¼Œå¯ä»¥è¾¾åˆ°ç›¸åŒçš„æ•ˆæœã€‚

```cpp
#include <iostream>
using namespace std;

template <class T>
requires std::is_integral_v<T>
struct X
{
    T t;
};

int main(int argc, char **argv)
{
    X x1{1};
    // X<std::string> x2;
    return 0;
}
```

æ¯”èµ·ä½¿ç”¨`std::enable_if`ä½¿ç”¨conceptå’Œrequiresï¼Œç¼–è¯‘å™¨ç¼–è¯‘é”™è¯¯æ—¶ä¼šç»™å‡ºç›¸å¯¹æ›´æ¸…æ™°çš„ä¿¡æ¯ã€‚

### ä½¿ç”¨conceptå’Œçº¦æŸè¡¨è¾¾å¼å®šä¹‰æ¦‚å¿µ

å¯ä»¥ä½¿ç”¨conceptå…³é”®å­—æ¥å®šä¹‰æ¦‚å¿µï¼Œå¦‚

```cpp
template <class C>
concept IntegerType = std::is_integral_v<C>;
```

å…¶ä¸­çš„`IntegerType`æ˜¯æ¦‚å¿µåï¼Œ`std::is_integral_v<C>`ç§°ä¸ºçº¦æŸè¡¨è¾¾å¼ã€‚

çº¦æŸè¡¨è¾¾å¼åº”è¯¥æ˜¯ä¸€ä¸ªboolç±»å‹çš„çº¯å³å€¼å¸¸é‡è¡¨è¾¾å¼ï¼Œå½“å®å‚æ›¿æ¢å½¢å‚åï¼Œè¡¨è¾¾å¼è®¡ç®—ç»“æœä¸ºtrueåˆ™æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚å¦åˆ™ç›¸åã€‚

è¿™é‡Œæ‰€è°“çš„è®¡ç®—éƒ½æ˜¯åœ¨ç¼–è¯‘æœŸé—´æ‰§è¡Œçš„ï¼Œæ¦‚å¿µçš„æœ€ç»ˆç»“æœæ˜¯ä¸€ä¸ªboolç±»å‹çš„çº¯å³å€¼ã€‚

```cpp
template <class T>
concept TestConcept = true;

static_assert(TestConcept<int>);
```

æ¦‚å¿µèƒ½å¤Ÿç›´æ¥ä¸ºstatic_assertçš„å®å‚ã€‚`TestConcept<int>`æ˜¯ä¸€ä¸ªboolç±»å‹çš„å¸¸é‡è¡¨è¾¾å¼ã€‚

çº¦æŸè¡¨è¾¾å¼è¿˜æ”¯æŒä¸€èˆ¬çš„é€»è¾‘æ“ä½œï¼ŒåŒ…æ‹¬åˆå–å’Œæå–ã€‚

```cpp
#include <iostream>
using namespace std;

// åˆå–
template <class C>
concept SignedIntegerType = std::is_integral_v<C> && std::is_signed_v<C>;

// æå–
template <class C>
concept IntegerFloatingType = std::is_integral_v<C> || std::is_floating_point_v<C>;

template <SignedIntegerType T>
class X
{
public:
    T t;
};

template <IntegerFloatingType T>
class Y
{
public:
    T f;
};

int main(int argc, char **argv)
{
    X<int> x1{1};
    Y<float> f1;
    f1.f = 1.2;
    // T<std::string> f2; // ç¼–è¯‘é”™è¯¯
    return 0;
}
```

é™¤äº†é€»è¾‘æ“ä½œçš„åˆå–å’Œæå–ä¹‹å¤–ï¼Œçº¦æŸè¡¨è¾¾å¼è¿˜æœ‰ä¸€ç§ç‰¹æ®Šæƒ…å†µå«åš`åŸå­çº¦æŸ`ã€‚

### requireså­å¥å’Œçº¦æŸæ£€æŸ¥é¡ºåº

é™¤äº†conceptä¹‹å¤–ï¼Œè¿˜å¯ä»¥ä½¿ç”¨requireså­å¥ç›´æ¥çº¦æŸæ¨¡æ¿å®å‚

```cpp
#include <iostream>
using namespace std;

template <typename T>
requires std::is_integral_v<T> && std::is_signed_v<T>
class X
{
public:
    T t;
};

template <typename T>
requires std::is_integral<T>::value || std::is_floating_point_v<T>
class Y
{
public:
    T f;
};

int main(int argc, char **argv)
{
    return 0;
}
```

requiresç´§è·Ÿçš„å¿…é¡»æ˜¯ä¸€ä¸ªç±»å‹ä¸ºboolçš„å¸¸é‡è¡¨è¾¾å¼ï¼Œé™¤æ­¤å¤–è¿˜å¯¹ç´§è·Ÿçš„å¸¸é‡è¡¨è¾¾å¼æœ‰ä¸€äº›é¢å¤–çš„è¦æ±‚ã€‚

- æ˜¯ä¸€ä¸ªåˆç­‰è¡¨è¾¾å¼æˆ–è€…å¸¦æ‹¬å·çš„ä»»æ„è¡¨è¾¾å¼

```cpp
#include <iostream>
using namespace std;

constexpr bool bar()
{
    return true;
}

template<class T>
requires bar()
struct X{
};

int main(int argc, char **argv)
{
    return 0;
}
```

å…¶ä¸­`requires bar()`ä¸­`bar()`ä¸æ˜¯ä¸€ä¸ªåˆç­‰è¡¨è¾¾å¼ï¼Œéœ€è¦é‡‡ç”¨`requires (bar())`

```cpp
constexpr bool bar()
{
    return true;
}

template<class T>
requires (bar()) && true || false
struct X{
};
```

requireså­å¥é™¤äº†èƒ½å‡ºç°åœ¨æ¨¡æ¿å½¢å‚åˆ—è¡¨å°¾éƒ¨ï¼Œè¿˜å¯ä»¥å‡ºç°åœ¨å‡½æ•°æ¨¡æ¿å£°æ˜æœ«å°¾ã€‚

```cpp
#include <iostream>
using namespace std;

constexpr bool bar()
{
    return true;
}

template<class T>
void X(T t) requires (bar()) && true || false
{
};

int main(int argc, char **argv)
{
    return 0;
}
```

å½“ä¸€ä¸ªæ¨¡æ¿åŒæ—¶å…·å¤‡å¤šç§çº¦æŸæ—¶ï¼Œä¼˜å…ˆçº§æ˜¯æ€æ ·çš„,æŒ‰ç…§ä¸‹é¢1 2 3 4ä¼˜å…ˆçº§ä¾æ¬¡è¿›è¡Œï¼Œè¶Šé å‰è¶Šä¼˜å…ˆã€‚

```cpp
#include <iostream>
using namespace std;

template <class C>
concept ConstType = std::is_const_v<C>;

template <class C>
concept IntegralType = std::is_integral_v<C>;

template <ConstType T>                      // 1
    requires std::is_pointer_v<T>           // 2
void foo(IntegralType auto)                 // 3
    requires std::is_same_v<T, char *const> // 4
{
}

int main(int argc, char **argv)
{
    // foo<int>(1.5); // ä¸æ»¡è¶³æ‰€æœ‰
    // foo<const int>(1.5); // åªæ»¡è¶³1
    // foo<int *const>(1.5); // æ»¡è¶³ 1 2
    // foo<int *const>(1); // æ»¡è¶³1 2 3
    foo<char *const>(1); // æ»¡è¶³1 2 3 4
    return 0;
}
```

### åŸå­çº¦æŸ

åŸå­çº¦æŸæ˜¯ è¡¨è¾¾å¼ å’Œ è¡¨è¾¾å¼ä¸­æ¨¡æ¿å½¢å‚ åˆ°æ¨¡æ¿å®å‚ æ˜ å°„çš„ç»„åˆï¼ˆç®€ç§°ä¸ºå½¢å‚æ˜ å°„ï¼‰ã€‚
æ¯”è¾ƒä¸¤ä¸ªåŸå­çº¦æŸæ˜¯å¦ç›¸åŒçš„æ–¹æ³•å¾ˆç‰¹æ®Šï¼Œé™¤äº†æ¯”è¾ƒä»£ç ä¸Šæ˜¯å¦æœ‰ç›¸åŒè¡¨ç°ï¼Œè¿˜éœ€è¦æ¯”è¾ƒ
å½¢å‚æ˜ å°„æ˜¯å¦ç›¸åŒï¼Œä¹Ÿå°±æ˜¯è¯´åŠŸèƒ½ä¸Šç›¸åŒçš„åŸå­çº¦æŸå¯èƒ½æ˜¯ä¸åŒçš„åŸå­çº¦æŸã€‚

```cpp
#include <iostream>
using namespace std;

template <int N>
constexpr bool Atomic = true;

template <int N>
concept C = Atomic<N>;

template <int N>
concept Add1 = C<N + 1>;

template <int N>
concept AddOne = C<N + 1>;

template <int M>
void f()
    requires Add1<2 * M>
{};

template <int M>
void f()
    requires AddOne<2 * M> && true
{};

int main(int argc, char **argv)
{
    f<0>();
    return 0;
}
```

ä¸Šé¢çš„Add1å’ŒAddOneæ•ˆæœå…¶å®æ˜¯ä¸€æ ·çš„ï¼Œè¿™ä¸¤ä¸ªå‡½æ•°ä¸­çš„æ¦‚å¿µCéƒ½æ˜¯å½¢å‚æ˜ å°„ä»Nå˜åˆ°2M+1ã€‚åœ¨ä¸¤ä¸ªå‡½æ•°éƒ½ç¬¦åˆçº¦æŸçš„æƒ…å†µä¸‹
ç¼–è¯‘å™¨ä¼šé€‰æ‹©çº¦æŸæ›´ä¸ºå¤æ‚çš„`requires AddOne<2*M> && true`ä½œä¸ºç›®æ ‡å‡½æ•°ã€‚
å› ä¸º`AddOne<2*M>&&true`åŒ…å«äº†`AddOne<2*M>`ã€‚

ä¸‹é¢çš„ä»£ç ä¼šäº§ç”ŸäºŒä¹‰æ€§ï¼Œè™½ç„¶éƒ½æ˜¯æ¦‚å¿µAdd1,ä½†å®ƒä»¬å½¢å‚æ˜ å°„ä¸åŒï¼Œåˆ†åˆ«ä¸º`2*N+1`å’Œ`N*2+1`,æ‰€ä»¥`Add1<N*2>&&true`å¹¶ä¸èƒ½
åŒ…å«`Add1<2*N>`ã€‚

```cpp
#include <iostream>
using namespace std;

template <int N>
constexpr bool Atomic = true;

template <int N>
concept C = Atomic<N>;

template <int N>
concept Add1 = C<N + 1>;

template <int N>
void f2()
    requires Add1<2 * N>
{};

template <int N>
void f2()
    requires Add1<N * 2> && true
{};

int main(int argc, char **argv)
{
    f2<0>(); // ç¼–è¯‘å¤±è´¥ æœ‰å¤šä¸ª é‡è½½å‡½æ•° "f2" å®ä¾‹ä¸å‚æ•°åˆ—è¡¨åŒ¹é…:
    return 0;
}
```

å½“çº¦æŸè¡¨è¾¾å¼ä¸­å­˜åœ¨åŸå­çº¦æŸæ—¶ï¼Œå¦‚æœçº¦æŸè¡¨è¾¾å¼ç»“æœç›¸åŒï¼Œåˆ™çº¦æŸè¡¨è¾¾å¼åº”è¯¥æ˜¯ç›¸åŒçš„ï¼Œå¦åˆ™ä¼šç¼–è¯‘å¤±è´¥ã€‚ä¸‹é¢çš„ä¸¤ä¸ªçº¦æŸè¡¨è¾¾å¼ç»“æœç›¸åŒï¼Œä½†æ˜¯çº¦æŸè¡¨è¾¾å¼ä¸ç›¸åŒï¼Œäº§ç”ŸäºŒä¹‰æ€§ã€‚ä¸‹é¢ä»£ç ä¸­`!sad<T>`å°±æ˜¯åŸå­çº¦æŸã€‚

```cpp
#include <iostream>
using namespace std;

template <class T>
concept sad = false;

template <class T>
int f1(T)
    requires(!sad<T>)
{
    return 1;
};

template <class T>
int f1(T)
    requires(!sad<T>) && true
{
    return 2;
};

int main(int argc, char **argv)
{
    f1(0); // error: call of overloaded â€˜f1(int)â€™ is ambiguous
    return 0;
}
```

å¯ä»¥è¿›è¡Œæ”¹é€ ä¸€ä¸‹,æ²¡æœ‰ä»€ä¹ˆæ˜¯åŠ ä¸€å±‚è§£å†³ä¸æ‰çš„ï¼Œä¸‹é¢ä»£ç å¯ä»¥ç¼–è¯‘æˆåŠŸäº†

```cpp
#include <iostream>
using namespace std;

template <class T>
concept sad = false;

template <class T>
concept not_sad = !sad<T>;

template <class T>
int f1(T)
    requires(not_sad<T>)
{
    return 1;
};

template <class T>
int f1(T)
    requires(not_sad<T>) && true
{
    return 2;
};

int main(int argc, char **argv)
{
    f1(0);
    return 0;
}
```

ä¾‹å¦‚ï¼Œä¸‹é¢çš„é›·åŒæƒ…å†µçš„,å°±ä¼šäº§ç”ŸäºŒä¹‰æ€§ï¼Œ`not_sad<T>==true`æ˜¯åŸå­çº¦æŸ

```cpp
#include <iostream>
using namespace std;

template <class T>
concept sad = false;

template <class T>
concept not_sad = !sad<T>;

template <class T>
int f1(T)
    requires(not_sad<T> == true)
{
    return 1;
};

template <class T>
int f1(T)
    requires(not_sad<T> == true) && true
{
    return 2;
};

int main(int argc, char **argv)
{
    f1(0);
    return 0;
}
```

å¯ä»¥å†å¥—ä¸€å±‚

```cpp
#include <iostream>
using namespace std;

template <class T>
concept sad = false;

template <class T>
concept not_sad_is_true = !sad<T> == true;

template <class T>
int f1(T)
    requires not_sad_is_true<T>
{
    return 1;
};

template <class T>
int f1(T)
    requires not_sad_is_true<T> && true
{
    return 2;
};

int main(int argc, char **argv)
{
    f1(0);
    return 0;
}
```

### requiresè¡¨è¾¾å¼

requireså…³é”®å­—é™¤äº†å¯ä»¥å¼•å…¥requireså­å¥ï¼Œè¿˜å¯ä»¥ç”¨æ¥å®šä¹‰ä¸€ä¸ªrequiresè¡¨è¾¾å¼ï¼Œè¯¥è¡¨è¾¾å¼åŒæ ·æ˜¯ä¸€ä¸ªçº¯å³å€¼è¡¨è¾¾å¼ã€‚

è¡¨è¾¾å¼ä¸ºtrueæ—¶è¡¨ç¤ºæ»¡è¶³çº¦æŸæ¡ä»¶ï¼Œåä¹‹falseè¡¨ç¤ºä¸æ»¡è¶³çº¦æŸæ¡ä»¶ã€‚

éœ€è¦ç‰¹åˆ«è¯´æ˜çš„æ˜¯requiresè¡¨è¾¾å¼çš„åˆ¤å®šæ ‡å‡†ï¼Œå› ä¸ºè¿™ä¸ªæ ‡å‡†æ¯”è¾ƒç‰¹æ®Šï¼Œå…·ä½“æ¥è¯´æ˜¯å¯¹requiresè¡¨è¾¾å¼è¿›è¡Œæ¨¡æ¿å®å‚çš„æ›¿æ¢ï¼Œå¦‚æœæ›¿æ¢ä¹‹årequiresè¡¨è¾¾å¼ä¸­å‡ºç°æ— æ•ˆç±»å‹æˆ–è€…è¡¨è¾¾å¼è¿åçº¦æŸæ¡ä»¶ï¼Œåˆ™requiresè¡¨è¾¾å¼æ±‚å€¼ä¸ºfalseï¼Œ
åä¹‹åˆ™requiresè¡¨è¾¾å¼æ±‚å€¼ä¸ºtrueã€‚ä¾‹å¦‚ï¼š

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <array>
using namespace std;

template <class T>
concept Check = requires {
    T().clear();
};

template <Check T>
struct G
{
};

int main(int argc, char **argv)
{
    G<std::vector<char>> x;
    G<std::string> y;
    std::vector<int> v;
    // G<std::array<char, 10>> z; // std::array<char, 10> clearæ— æ•ˆç±»å‹
    return 0;
}
```

ä¸Šé¢requiresè¡¨è¾¾å¼å®šä¹‰äº†æ¦‚å¿µCheck,Checkè¦æ±‚`T().clear()`æ˜¯ä¸€ä¸ªåˆæ³•çš„è¡¨è¾¾å¼ã€‚å› æ­¤vectorã€stringå¯ä»¥ç¼–è¯‘é€šè¿‡ã€‚è€Œarrayå› ä¸ºå› ä¸ºæ²¡æœ‰æˆå‘˜å‡½æ•°clearå¯¼è‡´ç¼–è¯‘å¤±è´¥ã€‚

requiresè¡¨è¾¾å¼è¿˜æ”¯æŒå½¢å‚åˆ—è¡¨ï¼Œä¾‹å¦‚ä¸Šé¢çš„ä¾‹å­é™¤äº†æ£€æŸ¥clearæˆå‘˜å‡½æ•°è¿˜éœ€è¦æ£€æŸ¥æ˜¯å¦æ”¯æŒ+è¿ç®—ç¬¦ã€‚

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <array>
using namespace std;

template <class T>
concept Check = requires {
    T().clear();
    T() + T();
};

template <Check T>
struct G
{
};

int main(int argc, char **argv)
{
    // G<std::vector<char>> x; // ç¼–è¯‘é”™è¯¯ std::vector<char>ä¸æ”¯æŒ+
    G<std::string> y;
    return 0;
}
```

ä½†æ˜¯ä¸€èˆ¬ä¸ä¼šåƒä¸Šé¢é‚£æ ·åšè€Œæ˜¯ç”¨requiresè¡¨è¾¾å¼çš„å½¢å‚åˆ—è¡¨,æ£€æŸ¥å†…å®¹éƒ½æ˜¯åœ¨ç¼–è¯‘æ—¶æ£€æŸ¥çš„ï¼Œå¹¶ä¸ä¼šçœŸçš„è¿è¡Œæ—¶æ‰§è¡Œclearå’Œç›¸åŠ ã€‚

```cpp
template <class T>
concept Check = requires(T a, T b) {
    a.clear();
    a + b;
};
```

requireså½¢å‚åˆ—è¡¨ä¸æ”¯æŒ è¿è¡Œæ—¶è®¡ç®—å®å‚æ•°é‡çš„ä¸å®šå‚æ•°åˆ—è¡¨

```cpp
// requires è¡¨è¾¾å¼ä¸­ä¸å…è®¸ä½¿ç”¨çœç•¥å·å‚æ•°
template <typename T>
concept C = requires(T t, ...) {};
```

åœ¨ä¸Šé¢çš„requiresè¡¨è¾¾å¼ä¸­,`a.clear()`å’Œ`a + b`å¯ä»¥è¯´æ˜¯å¯¹æ¨¡æ¿å®å‚çš„ä¸¤ä¸ªè¦æ±‚ï¼Œè¿™äº›è¦æ±‚åœ¨C++æ ‡å‡†ä¸­ç§°ä¸ºè¦æ±‚åºåˆ—(requirement-seq)ã€‚è¦æ±‚åºåˆ—åˆ†ä¸º4ç§ï¼ŒåŒ…æ‹¬ç®€å•è¦æ±‚ã€ç±»å‹è¦æ±‚ã€ç¬¦åˆè¦æ±‚ã€åµŒå¥—è¦æ±‚ã€‚

#### ç®€å•è¦æ±‚

ç®€å•è¦æ±‚æ˜¯`ä¸ä»¥requireså…³é”®å­—å¼€å§‹`ï¼Œå®ƒåªæ–­è¨€è¡¨è¾¾å¼çš„æœ‰æ•ˆæ€§ï¼Œå¹¶ä¸åšè¡¨è¾¾å¼çš„æ±‚å€¼æ“ä½œã€‚å¦‚æœè¡¨è¾¾å¼æ›¿æ¢æ¨¡æ¿å®å‚å¤±è´¥ï¼Œåˆ™è¯¥è¦æ±‚çš„è®¡ç®—ç»“æœä¸ºfalseï¼š

```cpp
template <typename T>
concept C = requires(T a, T b) {
    a + b;
};
```

ä¸Šé¢ä»£ç ä¸­`a + b`æ˜¯ä¸€ä¸ªç®€å•è¦æ±‚ï¼Œç¼–è¯‘å™¨ä¼šæ–­è¨€`a + b`çš„åˆæ³•æ€§ï¼Œå¹¶ä¸ä¼šè®¡ç®—å…¶æœ€ç»ˆç»“æœã€‚`ä¸ä»¥requireså…³é”®å­—å¼€å§‹æ˜¯ç®€å•è¡¨è¾¾å¼çš„é‡è¦ç‰¹å¾`ã€‚

#### ç±»å‹è¦æ±‚

ç±»å‹è¦æ±‚æ˜¯ä»¥typenameå…³é”®å­—å¼€å§‹çš„ï¼Œç´§è·Ÿtypenameçš„æ˜¯ä¸€ä¸ªç±»å‹åã€‚
é€šå¸¸å¯ä»¥æ£€æŸ¥ åµŒå¥—ç±»å‹ã€ç±»æ¨¡æ¿ ä»¥åŠ åˆ«åæ¨¡æ¿ç‰¹åŒ– çš„æœ‰æ•ˆæ€§ã€‚å¦‚æœæ¨¡æ¿å®å‚æ›¿æ¢å¤±è´¥ï¼Œåˆ™è¦æ±‚è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœä¸ºfalseã€‚

```cpp
#include <iostream>
#include <string>
using namespace std;

// è¦æ±‚ç±»å‹Tæœ‰ä¸€ä¸ªtypeåµŒå¥—ç±»å‹ä¸”å¯ä»¥è¢«åˆå§‹åŒ–ä¸º0
template <typename T, typename T::type = 0>
struct S; // å£°æ˜

template <typename T>
using Ref = T &;

template <typename T>
concept C = requires {
    typename T::inner; // è¦æ±‚Tæœ‰ä¸ªåµŒå¥—ç±»å‹inner
    typename S<T>;     // è¦æ±‚æ¨¡æ¿ç‰¹åŒ–
    typename Ref<T>;   // è¦æ±‚åˆ«åæ¨¡æ¿ç‰¹åŒ–
};

struct ExampleForC
{
    using inner = std::string;
    using type = char; // Sè¦æ±‚typeèƒ½è¢«0èµ‹å€¼ å¦‚æœæ¬¡æ•°charæ›¿æ¢ä¸ºstd::stringå°±ä¼šæŠ¥é”™äº†
};

template <C c>
struct UsingC
{
};

int main(int argc, char **argv)
{
    UsingC<ExampleForC> c;
    return 0;
}
```

#### å¤åˆè¦æ±‚

æ–­è¨€ä¸€ä¸ªç¬¦åˆè¦æ±‚éœ€è¦æŒ‰ç…§ä¸€ä¸‹é¡ºåº

1. æ›¿æ¢æ¨¡æ¿å®å‚{E}ä¸­çš„è¡¨è¾¾å¼E,æ£€æµ‹è¡¨è¾¾å¼çš„æœ‰æ•ˆæ€§ã€‚
2. å¦‚æœä½¿ç”¨äº†noexceptï¼Œåˆ™éœ€è¦æ£€æŸ¥å¹¶ç¡®ä¿{E}ä¸­çš„è¡¨è¾¾å¼Eä¸ä¼šæœ‰æŠ›å‡ºå¼‚å¸¸çš„å¯èƒ½ã€‚
3. å¦‚æœä½¿ç”¨äº†`->`åçš„è¿”å›ç±»å‹çº¦æŸï¼Œåˆ™éœ€è¦å°†æ¨¡æ¿å®å‚æ›¿æ¢åˆ°è¿”å›ç±»å‹çº¦æŸä¸­ï¼Œå¹¶ä¸”ç¡®ä¿è¡¨è¾¾å¼Eçš„ç»“æœç±»å‹å³`decltype((E))`,æ»¡è¶³è¿”å›ç±»å‹çº¦æŸã€‚

```cpp
#include <iostream>
#include <vector>
using namespace std;

template <class T>
concept Check = requires(T a, T b) {
    {
        a.clear()
    } noexcept;
    {
        a + b
    } noexcept -> std::same_as<int>;
};

// å£°æ˜å³å¯æ»¡è¶³requiresè¡¨è¾¾å¼æ£€æŸ¥ä¸ç”¨ä¸€å®šè¦å®šä¹‰å®Œæ•´
int operator+(const std::vector<char> &v1, const std::vector<char> &v2) noexcept;

template <Check c>
struct UsingCheck
{
};

int main(int argc, char **argv)
{
    UsingCheck<std::vector<char>> c;
    return 0;
}
```

å…¶ä¸­çš„`std::same_as`æ˜¯ä¸€ä¸ªæ¦‚å¿µï¼Œå…¶å®ç°ä½¿ç”¨`std::is_same_v`å®ç°çš„

```cpp
namespace __detail
{
  template<typename _Tp, typename _Up>
    concept __same_as = std::is_same_v<_Tp, _Up>;
} // namespace __detail
/// [concept.same], concept same_as
template<typename _Tp, typename _Up>
  concept same_as
    = __detail::__same_as<_Tp, _Up> && __detail::__same_as<_Up, _Tp>;
```

ä»£ç ä¸­çš„`std::same_as`è¿”å›ç±»å‹è¦æ±‚ï¼Œå®é™…ç¼–è¯‘ä»£ç ç±»ä¼¼äº

```cpp
std::same_as<decltype((a + b)), int>
```

#### åµŒå¥—è¦æ±‚

ä¸‹é¢çš„ä»£ç ä¸­æ¦‚å¿µé‡Œå¥—äº†æ¦‚å¿µï¼Œrequiresè¡¨è¾¾å¼ä¸­åµŒå…¥äº†æ¦‚å¿µã€‚

```cpp
#include <iostream>
using namespace std;

template <class T>
concept Check = requires(T a, T b) {
    requires std::same_as<decltype((a + b)), int>;
};

template <Check c>
class UsingCheck
{
};

int main(int argc, char **argv)
{
    UsingCheck<int> c;
    return 0;
}
```

ä¸Šé¢çš„Checkè¦æ±‚ï¼Œè¡¨è¾¾å¼`a + b`çš„ç»“æœç±»å‹æ˜¯intï¼Œå¯ä»¥ç­‰åŒäºã€‚

```cpp
#include <iostream>
using namespace std;

// å¤åˆè¦æ±‚
template <class T>
concept Check = requires(T a, T b) {
     { a + b } -> std::same_as<int>;
};

template <Check c>
class UsingCheck
{
};

int main(int argc, char **argv)
{
    UsingCheck<int> c;
    return 0;
}
```

å±€éƒ¨å½¢å‚æ˜¯ä¸èƒ½å‚ä¸è¿ç®—çš„æ“ä½œæ•°ï¼Œä¾‹å¦‚

```cpp
#include <iostream>
using namespace std;

template <typename T>
concept Check = requires(T a) {
    requires sizeof(a) == 4;
    // requires a == 0; // å±€éƒ¨å½¢å‚ä¸æ˜¯å¯è¿ç®—çš„æ“ä½œæ•°
};

template <Check C>
struct X
{
    C c;
};

int main(int argc, char **argv)
{
    X<int> x{0};
    std::cout << x.c << std::endl; // 0
    return 0;
}
```

### çº¦æŸå¯å˜å‚æ•°æ¨¡æ¿

ä¹Ÿå°±æ˜¯è®¨è®ºå¦‚ä½•åœ¨æ¨¡æ¿å‚æ•°åŒ…ä¸Šä½¿ç”¨çº¦æŸå‘¢ã€‚ä½¿ç”¨æ¦‚å¿µçº¦æŸå¯å˜å‚æ•°æ¨¡æ¿å®é™…ä¸Šå°±æ˜¯å°†å„ä¸ªå®å‚æ›¿æ¢åˆ°æ¦‚å¿µçš„çº¦æŸè¡¨è¾¾å¼ååˆå–å„ä¸ªç»“æœã€‚

```cpp
#include <iostream>
#include <string>
using namespace std;

template <class T>
concept C1 = true;

template <C1... T>
struct X
{
};

int main(int argc, char **argv)
{
    X<int, double, std::string> x;
    // çº¦æŸæ£€æŸ¥ç­‰ä»·äº (X<int> && X<double> && X<std::string>)
    return 0;
}
```

ä¸Šé¢ä»£ç æƒ…å†µæ¯”è¾ƒç®€å•ï¼Œæœ‰æ—¶ä»£ç ä¼šæ›´åŠ å¤æ‚ï¼Œä½†å±•å¼€è§„åˆ™æ˜¯ä¸å˜çš„ï¼Œä¾‹å¦‚

```cpp
#include <iostream>
using namespace std;

template <class T, class U>
concept C = true;

// ç»è¿‡æ›¿æ¢å®é™…çš„çº¦æŸä¸ºC<T, int>
template <C<int> T>
struct X
{
};

// çº¦æŸå®é™…ä¸ºC<T,int> && ...
template <C<int>... T>
struct Y
{
};

int main(int argc, char **argv)
{
    return 0;
}

```

### çº¦æŸç±»æ¨¡æ¿ç‰¹åŒ–

çº¦æŸå¯ä»¥å½±å“ç±»æ¨¡æ¿ç‰¹åŒ–çš„ç»“æœï¼Œåœ¨æ¨¡æ¿å®ä¾‹åŒ–çš„æ—¶å€™ç¼–è¯‘å™¨ä¼šè‡ªåŠ¨é€‰æ‹©æ›´æ»¡è¶³çº¦æŸæ¡ä»¶çš„ç‰¹åŒ–ç‰ˆæœ¬è¿›è¡Œå®ä¾‹åŒ–ï¼Œæ¯”å¦‚ï¼š

```cpp
#include <iostream>
using namespace std;

template <typename T>
concept C = true;

template <typename T>
struct X
{
    X()
    {
        std::cout << "template <typename T> struct X" << std::endl;
    }
};

template <typename T>
struct X<T *>
{
    X()
    {
        std::cout << "template <typename T> struct X<T *>" << std::endl;
    }
};

template <C T>
struct X<T>
{
    X()
    {
        std::cout << R"(template <C T> struct X<T>)" << std::endl;
    }
};

int main(int argc, char **argv)
{
    X<int *> x1;
    // template <typename T> struct X<T *>
    X<int> x2;
    // template <C T> struct X<T>
    std::cout << __cplusplus << std::endl; // 202002
    return 0;
}
```

å¯¹äº`X<int *>`æ˜æ˜¾æ¨¡æ¿ç±»ç‰¹åŒ–`struct X<T*>`æ›´ç¬¦åˆï¼Œä½†æ˜¯`X<int>`é€‰æ‹©äº†æœ‰æ¦‚å¿µçº¦æŸçš„ã€‚è¿™é‡Œåªæ˜¯è¯´æ˜äº†çº¦æŸå¯¹ç±»æ¨¡æ¿ç‰¹åŒ–çš„å½±å“ã€‚

å®é™…ä¸Šçº¦æŸåœ¨ç±»æ¨¡æ¿ç‰¹åŒ–ä¸Šå¯ä»¥å‘æŒ¥å¾ˆå¤§çš„ä½œç”¨ã€‚

```cpp
#include <iostream>
using namespace std;

template <typename T>
concept C = requires(T t) {
    t.f();
};

template <typename T>
struct X
{
    X()
    {
        std::cout << R"(
template <typename T>
struct X)" << std::endl;
    }
};

template <C T>
struct X<T>
{
    X()
    {
        std::cout << R"(
template <C T>
struct X)" << std::endl;
    }
};

struct Args
{
    void f();
};

int main(int argc, char **argv)
{
    X<int> s1;
    X<Args> s2;
    // template <typename T>
    // struct X
    // template <C T>
    // struct X
    return 0;
}
```

å¦‚æœä¹‹çº¦æŸæ„é€ å‡½æ•°çš„è¯ï¼Œè¿˜æœ‰sæ›´ç®€æ´çš„éªšæ“ä½œã€‚çœŸå®å°åˆ€åˆ’å±è‚¡å¼€äº†çœ¼äº†ã€‚

```cpp
#include <iostream>
using namespace std;

template <typename T>
struct S
{
    S()
    {
        std::cout << "S::S()" << std::endl;
    }
    S()
    requires requires(T t) { t.f(); } {
        std::cout << "S::S() requires" << std::endl;
    }
};

struct X
{
    void f();
};

int main(int argc, char **argv)
{
    S<int> s1; // S::S()
    S<X> s2;   // S::S() requires
    return 0;
}
```

### çº¦æŸauto

æ¦‚å¿µçº¦æŸå¯ä»¥å¯¹autoå’Œ`decltype(auto)`çš„ä½œç”¨æ‰©å±•åˆ°æ™®éæƒ…å†µï¼Œä¾‹å¦‚

```cpp
#include <iostream>
using namespace std;

template <class C>
concept IntegerType = std::is_integral_v<C>;

// ç¼–è¯‘å¤±è´¥
// IntegerType auto foo1()
// {
//     return 1.1;
// }

IntegerType auto foo2()
{
    return 0;
}

int main(int argc, char **argv)
{
    // IntegerType auto i1 = 5.2; // ç¼–è¯‘å¤±è´¥
    IntegerType auto i2 = 11;

    // IntegerType decltype(auto) i3 = 4.8; // ç¼–è¯‘å¤±è´¥
    IntegerType decltype(auto) i4 = 7;

    // ç¼–è¯‘å¤±è´¥
    // auto bar1 = []() -> IntegerType auto
    // { return 1.0; };

    auto bar2 = []() -> IntegerType auto
    {
        return 1;
    };

    return 0;
}
```

è¦çº¦æŸçš„autoæˆ–`decltype(auto)`æ€»æ˜¯ç´§éšçº¦æŸä¹‹åï¼Œå› æ­¤cvé™å®šç¬¦å’Œæ¦‚å¿µæ ‡è¯†ç¬¦ä¸èƒ½éšæ„æ··ç”¨ã€‚

```cpp
#include <iostream>
using namespace std;

template <class C>
concept IntegerType = std::is_integral_v<C>;

int main(int argc, char **argv)
{
    const IntegerType auto i5 = 23;
    IntegerType auto const i6 = 9;
    // IntegerType const auto i7 = 9; // ç¼–è¯‘é”™è¯¯autoæ²¡æœ‰ç´§è·Ÿçº¦æŸ
    return 0;
}
```

## explicit(bool)

C++20æ‰©å±•äº†explicitè¯´æ˜ç¬¦ï¼Œå®ƒå¯ä»¥æ¥å—ä¸€ä¸ªæ±‚å€¼ç±»å‹ä¸ºboolçš„å¸¸é‡è¡¨è¾¾å¼ï¼Œç”¨äºæŒ‡å®šexplicitçš„åŠŸèƒ½æ˜¯å¦ç”Ÿæ•ˆã€‚

```cpp
#include <iostream>
#include <vector>
using namespace std;

std::pair<std::string, std::string> safe()
{
    return {"meow", "purr"}; // ç¼–è¯‘æˆåŠŸ
}

std::pair<std::vector<int>, std::vector<int>> unsafe()
{
    return {11, 22}; // ç¼–è¯‘å¤±è´¥
}

int main(int argc, char **argv)
{
    return 0;
}
```

ä¸Šé¢çš„ç¼–è¯‘å¤±è´¥æ˜¯å› ä¸º`std::vector<int>`çš„æ„é€ å‡½æ•°ä½¿ç”¨äº†explicitè¯´æ˜ç¬¦,æ‰€ä»¥éœ€è¦æ˜¾å¼æ„é€ ã€‚

ä½†æ˜¯æ€ä¹ˆæŒ‡å®špairåº”è¯¥æ˜¾å¼æ„é€ å‘¢

```cpp
#include <iostream>
#include <vector>
using namespace std;

template <class T1, class T2>
struct MyPair
{
    template <class U1, class U2>
    explicit MyPair(const U1 &u1, const U2 &u2) : first_(u1), second_(u2) {}
    T1 first_;
    T2 second_;
};

MyPair<std::string, std::string> safe()
{
    return {"meow", "purr"}; // ç¼–è¯‘å¤±è´¥
}

MyPair<std::vector<int>, std::vector<int>> unsafe()
{
    return {11, 22}; // ç¼–è¯‘å¤±è´¥
}

int main(int argc, char **argv)
{
    return 0;
}
```

ä½†æ˜¯è¿™æ ·åˆå¯¼è‡´safeç¼–è¯‘å¤±è´¥äº†ï¼Œä¸ºäº†è§£å†³é—®é¢˜ï¼Œæ ‡å‡†åº“é‡‡ç”¨SFINAEå’Œæ¦‚å¿µçš„æ–¹æ³•å®ç°äº†pairçš„æ„é€ å‡½æ•°ï¼Œä»£ç ç±»ä¼¼äº
ä¸è¿‡çœ‹è¿‡ä»£ç ï¼Œæˆ‘æ„Ÿå¹åƒæˆ‘è¿™æ ·çš„èœé¸¡ï¼Œè¿™ç§ä»£ç çœ‹è¯»æ‡‚å†™ä¸å‡ºä¹Ÿç½¢ï¼Œäº†è§£ä¸‹å³å¯ã€‚

```cpp
#include <iostream>
using namespace std;

// SFINAEç‰ˆæœ¬
template <typename T1, typename T2>
struct MyPair
{
    template <typename U1 = T1, typename U2 = T2,
              std::enable_if_t<
                std::is_constructible_v<T1, U1> && 
                std::is_constructible_v<T2, U2> && 
                std::is_convertible_v<U1, T1> && 
                std::is_convertible_v<U2, T2>,
                int> = 0> 
    constexpr MyPair(U1 &&, U2 &&);

    template <typename U1 = T1, typename U2 = T2,
              std::enable_if_t<
                std::is_constructible_v<T1, U1> &&
                std::is_constructible_v<T2, U2> &&
                !(std::is_convertible_v<U1, T1> &&
                std::is_convertible_v<U2, T2>),
                int> = 0>
    explicit constexpr MyPair(U1 &&, U2 &&);
};

int main(int argc, char **argv)
{
    return 0;
}
```

æ¦‚å¿µç‰ˆæœ¬ï¼Œæ¯”SFINAEå®¹æ˜“å¾ˆå¤š

```cpp
#include <iostream>
using namespace std;

// æ¦‚å¿µç‰ˆæœ¬
template <typename T1, typename T2>
struct MyPair
{
    template <typename U1 = T1, typename U2 = T2>
        requires std::is_constructible_v<T1, U1> &&
                 std::is_constructible_v<T2, U2> &&
                 std::is_convertible_v<U1, T1> &&
                 std::is_convertible_v<U2, T2>
    constexpr MyPair(U1 &&, U2 &&);

    // U1å¯æ„é€ T1 ä¸” U2å¯æ„é€ T2
    // åˆ™é‡‡ç”¨å¸¦æœ‰explicitçš„
    template <typename U1 = T1, typename U2 = T2>
        requires std::is_constructible_v<T1, U1> &&
                 std::is_constructible_v<T2, U2>
    explicit constexpr MyPair(U1 &&, U2 &&);
};

int main(int argc, char **argv)
{
    return 0;
}
```

æ°å¥½`explicit(bool)`ç‰¹æ€§èƒ½æ›´å¥½çš„è§£å†³ä¸Šé¢çš„é—®é¢˜

SFINAEç‰ˆæœ¬

```cpp
#include <iostream>
using namespace std;

// SFINAEç‰ˆæœ¬
template <typename T1, typename T2>
struct MyPair
{
    template <typename U1 = T1, typename U2 = T2,
              std::enable_if_t<
                  std::is_constructible_v<T1, U1> &&
                      std::is_constructible_v<T2, U2>,
                  int> = 0>
    explicit(!(std::is_convertible_v<U1, T1> &&
               std::is_convertible_v<U2, T2>)) constexpr MyPair(U1 &&, U2 &&);
};

int main(int argc, char **argv)
{
    return 0;
}
```

æ¦‚å¿µç‰ˆæœ¬

```cpp
#include <iostream>
using namespace std;

// æ¦‚å¿µç‰ˆæœ¬
template <typename T1, typename T2>
struct MyPair
{
    template <typename U1 = T1, typename U2 = T2>
    explicit(std::is_constructible_v<T1, U1> &&
             std::is_constructible_v<T2, U2>) constexpr MyPair(U1 &&, U2 &&);
};

int main(int argc, char **argv)
{
    return 0;
}
```

## å¯¹äºC++æ–°ç‰¹æ€§çš„æ„Ÿå¹

C++ç‰ˆæœ¬ä¸æ–­å‡çº§æ”¹è¿›ï¼Œä½¿å¾—ç‰¹æ€§è¶Šæ¥è¶Šå¤šï¼Œè¯­æ³•è¶Šæ¥è¶ŠæŠ½è±¡ï¼Œç‰¹åˆ«æ˜¯å…³äºæ¨¡æ¿ç¼–ç¨‹çš„å†…å®¹ï¼Œå¾ˆå®¹æ˜“ä»¤äººå¤´å¤§ã€‚åªçœ‹çœ‹ä»£ç å­¦ä¹ å°±è´¹è„‘å­ï¼Œæ›´ä¸ç”¨è¯´ç”¨æ–°ç‰¹æ€§å†™ä»£ç äº†ï¼ŒC++æ–°ç‰ˆæœ¬ç‰¹æ€§ä¼¼ä¹ä¸æ˜¯ç•™ç»™æ™®é€šå¼€å‘äººå‘˜ç”¨çš„ï¼Œ
æ›´åƒæ—¶ä¼˜åŒ–æ ‡å‡†åº“ï¼Œå†™ç±»å·¥å…·åº“çš„å¤§ä½¬ä»¬ç”¨çš„ï¼Œä¾¿äºä»–ä»¬çš„å¼€å‘ï¼Œç„¶åä»–ä»¬çš„æˆåŠŸæƒ åŠåƒæˆ‘è¿™æ ·çš„èœé¸¡ã€‚
