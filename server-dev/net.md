# 网络编程重点

网络编程其实就是套接字与 IO 多路复用那回事，但是细节很多

## socket 相关函数

socket 创造某种类型的套接字  
bind 将一个 socket 绑定到一个 IP 与端口的二元组上  
listen 将一个 socket 变为监听状态  
connect 试图建立一个 TCP 连接，一般用于客户端  
accept 尝试接收一个连接，一般用于服务端  
send 通过一个 socket 发送数据  
recv 通过一个 socket 收取数据  
select 判断一组 socket 上的读写和异常事件  
gethostbyname 通过域名获取机器地址  
close 关闭一个套接字，回收该 socket 对应的资源  
shutdown 关闭 socket 收发通道  
setsockopt 设置一个套接字选项  
getsockopt 获取一个套接字选项

## man 手册

Section 1: 用户命令，包含系统中可执行命令的手册页，例如常见的命令如 ls、grep、cp 等。  
Section 2: 系统调用，包含内核提供的系统调用的手册页，这些调用可以在 C 语言程序中直接调用。  
Section 3: C 库函数，包含 C 语言标准库函数的手册页，例如字符串操作、文件操作、内存操作等。  
Section 4: 设备和特殊文件，包含设备驱动程序和特殊文件的手册页，例如硬件设备、设备驱动、设备文件等。  
Section 5: 文件格式和约定，包含特定文件格式、配置文件和约定的手册页，例如 passwd 文件、fstab 文件等。  
Section 6: 游戏和屏保，包含游戏和屏保程序的手册页。  
Section 7: 其他杂项，包含一些其他杂项的手册页，例如标准和协议、宏和特殊文件等。  
Section 8: 系统管理命令，包含系统管理命令的手册页，例如管理用户、系统配置、网络配置等。

## TCP 网络通信的基本流程

也就是那么回事，写写项目就好了

## select 函数

去看 UNIX 环境高级编程部分吧

## socket 操作错误码

"EWOULDBLOCK" 是一个定义在 <errno.h> 头文件中的宏，表示在非阻塞操作中出现了一个阻塞的情况。

在网络编程中，当使用非阻塞套接字进行读取或写入操作时，可能会出现 EWOULDBLOCK 错误码。它指示当前操作无法立即完成，因为没有可用的数据（对于读取操作）或没有足够的空间（对于写入操作）。这并不是一个真正的错误，而是一种指示需要等待更多数据可用或更多空间可用的条件。

EWOULDBLOCK 的值通常是一个正整数，表示该错误的特定错误码。具体的值可以因操作系统而异。在 POSIX 标准中，EWOULDBLOCK 通常与 EAGAIN 宏相同，它们都表示相同的非阻塞操作条件。

在处理 EWOULDBLOCK 错误时，通常需要在稍后的时间重新尝试相同的操作，直到操作能够成功完成。这可以通过在循环中重复调用相应的读取或写入函数来实现，直到返回不再是 EWOULDBLOCK 为止。

请注意，EWOULDBLOCK 错误与其他一些错误码，如 EINTR（表示操作由于信号中断）和 ECONNRESET（表示连接被重置）等，可能会同时出现，因此在处理错误时需要注意多种可能的情况。

## bind 函数

INADDR_ANY 表示`0.0.0.0`

## socket 的阻塞模式与非阻塞模式

socket 在阻塞和非阻塞模式下，connect、accept、send、recv 的行为表现有差异

1、如何将 socket 设置为非阻塞

```cpp
//fcntl
//socket函数时type加SOCK_NONBLOCK
//accept,accept4直接将accept函数返回的socket设置为非阻塞的
```

2、send 和 recv 函数在阻塞和非阻塞模式下的表现

send 本质是将应用层发送缓冲区的数据拷贝到内核中，数据什么时候会从网卡缓冲区真正发送到网络是不知道的，如果 socket 设置了 TCP_NODELAY，存放到内核缓冲区的数据就会立即发出去，如果一次放入内核缓冲区的数据包太小，系统会在多个小的数据包凑成一个大的数据包后才会将数据发出去

recv 函数本质上不是从网络取数据，而实从内核缓冲区中数据拷贝到应用程序缓冲区中，拷贝完成后内核缓冲区中的该数据部分会移除

如果内核缓冲区满了，还在 send 调用时

阻塞模式：继续调用 send、recv 函数，程序会阻塞在 send、recv 调用处  
非阻塞模式：继续调用 send、recv 函数，程序不会阻塞在 send、recv 调用处，而是返回，会得到错误码，EWOULDBLOCK、EAGAIN（二者错误码相同）

3、非阻塞模式下 send 和 recv 函数的返回值

| 返回值 n     | 返回值的含义                                                                                                                       |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------- |
| 大于 0       | 成功发送(send)或收(recv)n 字节                                                                                                     |
| 0            | 对端关闭                                                                                                                           |
| 小于 0（-1） | 出错（不是后三者）、被信号中断（EINTR）、对端 TCP 窗口太小导致数据发送不出去或当前网卡缓冲区已经无数据可接收（EWOUDBLOCK、EAGAIN） |

## 待办

1、发送 0 字节数据效果  
2、connect 在阻塞和非阻塞下行为  
3、连接时顺便接收第一组数据  
4、获取 socket 对应缓冲区中的可读数据量  
5、EINTR 错误码  
6、SIGPIPE 信号  
7、poll  
8、epoll  
9、主机字节序和网络字节序  
10、域名解析 API
