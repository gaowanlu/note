---
cover: >-
  https://images.unsplash.com/photo-1643969061349-9d004b6e6ba7?crop=entropy&cs=tinysrgb&fm=jpg&ixid=MnwxOTcwMjR8MHwxfHJhbmRvbXx8fHx8fHx8fDE2NTQ0NDQxOTY&ixlib=rb-1.2.1&q=80
coverY: 0
---

# 🥳 散列表

## 散列表

散列查找的精髓在于散列表的散列函数，线性表和树表的查找都是通过比较关键字的方法，查找的效率取决于关键字的比较次数，而散列表就是一种以不进行关键字比较为驱动目标的数据结构

### 散列函数

又称为哈希函数，将关键字映射到存储地址的函数，记作为hash(key)=Addr\
（1）散列函数要尽可能简单，能够快速计算出任意一个关键字的散列地址\
（2）散列函数映射的地址应该均匀分布整个地址空间，避免聚集，以减少冲突

### 直接定址法

散列函数 `hash(key)=a*key+b`\
特点 使用于知道关键字、关键字集合不是很大但连续性很好，如果不连续则有大量空位，造成空间浪费

### 除留余数法

最常用的一种方法，不需要事先知道关键字的分布，假设散列表长度为m，去一个不大于表长的最大素数p

散列函数 `hash(key)=key%p`

为什么要选用素数？为了避免冲突

### 随机数法

随机可以让关键字的分布更均匀，再用除留余数法得到存储地址

散列函数 `hash(key)=rand(key)%p`

在C/C++中，rand(n)表示求0\~n-1的随机树，p的取值和除留余数法相同

### 数字分析法

根据数字个别位上的分布进行具体问题具体分析

下面这些数字前1、2位相同，则不管，第3、5、6位分布较均匀，用这些位组成hash函数的key则会尽可能减少冲突

![数字分析法](<../../../.gitbook/assets/屏幕截图 2022-06-05 230923.jpg>)

则可以将3、5、6位的数字作为散列地址，或将3、5、6位数字求和后作为散列地址等，真正要选择什么，还要看具体的使用场景

### 平方取中法

对关键字平方后，按散列表大小，取中间的若干位作为散列地址，通常适用于事先不知道关键字的分布且关键字的位数不是很大的情况

例：散列地址为3位

```cpp
10123^2=102475129
//则在102475129中间取3位，作为关键字的10123的hash地址
```

### 折叠法

将关键字从左到右分割成位数相等的几部分，将这及部分叠加求和，取后几位作为散列地址\
适用于关键字位数很多，事先不知道分布的情况

`移位折叠法` 分割后将每一个部分的最低位对齐，然后相加求和\
`边界折叠法` 将相邻部分沿边界来回折叠，然后对齐相加

例：关键字为`45207379603`,散列地址为3位

![折叠法](<../../../.gitbook/assets/屏幕截图 2022-06-05 232008.jpg>)

### 基数转换法

散列函数大多是基于整数的\
`十进制数`转换为其他进制表示，例如345的九进制表示423\
`浮点数`可将关键字乘以M并四舍五入得到整数，再进行散列函数,或将关键字表示为二进制数后在使用散列函数\
`字符`可将字符转换R进制的整数，然后再使用散列函数

![基数转换法应用举例](<../../../.gitbook/assets/屏幕截图 2022-06-05 232851.jpg>)

### 全域散列法

如果对关键字了解不多，可使用全域散列法\
将备选的散列函数放入集合H,使用时随机取一个作为散列函数\
如果任意两个不同的关键字key1!=key2,hash(key1)=hash(key2)的散列函数个数最多为|H|/m,|H|为集合中散列函数的个数,m为表长，则称H为全域的

`待更新...`
