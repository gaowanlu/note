# ğŸš å›¾çš„åº”ç”¨

## å›¾çš„åº”ç”¨

ä¸»è¦ä»¥å›¾çš„ç»å…¸åº”ç”¨ï¼ŒåŒ…æ‹¬æœ€çŸ­è·¯å¾„ã€æœ€å°ç”Ÿæˆæ ‘ã€æ‹“æ‰‘æ’åºã€å…³é”®è·¯å¾„

### å•æºæœ€çŸ­è·¯å¾„Dijkstra

Dijkstraç®—æ³•æ˜¯è§£å†³å•æºæœ€çŸ­è·¯å¾„é—®é¢˜çš„è´ªå¿ƒç®—æ³•ï¼Œå®ƒå…ˆæ±‚å‡ºé•¿åº¦æœ€çŸ­çš„ä¸€æ¡è·¯å¾„ï¼Œå†å‚ç…§è¯¥è·¯å¾„æ±‚å‡ºé•¿åº¦æ¬¡çŸ­çš„ä¸€æ¡è·¯å¾„ï¼Œç›´åˆ°æ±‚å‡ºä»æºç‚¹åˆ°å…¶ä»–å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„

ç®—æ³•æ­¥éª¤

1ã€`æ•°æ®ç»“æ„`è®¾ç½®åœ°å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µG.Edge\[j],å³å¦‚æœä»æºç‚¹uåˆ°iæœ‰è¾¹å°±ä»¤G.Edge\[u]\[i]ç­‰äº\<u,i>çš„æƒå€¼ï¼Œåˆ™G.Edge\[u]\[i]=âˆï¼Œé‡‡ç”¨ä¸€ä½æ•°ç»„dist\[i]æ¥è®°å½•ä»æºç‚¹åˆ°ié¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œé‡‡ç”¨ä¸€ç»´æ•°ç»„p\[i]æ¥è®°å½•æœ€çŸ­è·¯å¾„ä¸Šié¡¶ç‚¹çš„å‰é©±\
2ã€`åˆå§‹åŒ–`ä»¤é›†åˆS={u},å¯¹äºé›†åˆV-Sä¸­çš„æ‰€æœ‰é¡¶ç‚¹xï¼Œåˆå§‹åŒ–dist\[i]=G.Edge\[u]\[i],å¦‚æœæºç‚¹uåˆ°é¡¶ç‚¹iå³è¾¹ç›¸è¿ï¼Œåˆå§‹åŒ–p\[i]=u,å¦åˆ™p\[i]=-1\
3ã€`æ‰¾æœ€å°`åœ¨é›†åˆV-Sä¸­ä¾ç…§è´ªå¿ƒç­–ç•¥æ¥å¯»æ‰¾ä½¿å¾—dist\[j]å…·æœ‰æœ€å°å€¼çš„é¡¶ç‚¹tï¼Œå³dist\[t]=min(dist\[j]jå±äºV-Sé›†åˆ)ï¼Œåˆ™é¡¶ç‚¹tå°±æ˜¯é›†åˆV-Sä¸­è·ç¦»æºç‚¹uæœ€è¿‘çš„é¡¶ç‚¹\
3ã€`åŠ å…¥Sæˆ˜é˜Ÿ`å°†é¡¶ç‚¹tåŠ å…¥é›†åˆSä¸­ï¼ŒåŒæ—¶æ›´æ–°V-S\
4ã€`åˆ¤ç»“æŸ`å¦‚æœé›†åˆV-Sä¸ºç©ºï¼Œç®—æ³•ç»“æŸ\
5ã€`å€Ÿä¸œé£`åœ¨ç¬¬3æ­¥ä¸­å·²ç»æ‰¾åˆ°äº†æºç‚¹åˆ°tçš„æœ€çŸ­è·¯å¾„ï¼Œé‚£ä¹ˆ`å¯¹é›†åˆV-Sä¸­`æ‰€æœ‰ä¸é¡¶ç‚¹tç›¸é‚»çš„é¡¶ç‚¹jï¼Œéƒ½å¯ä»¥å€ŸåŠ©tèµ°æ·å¾„ï¼Œå¦‚æœdist\[j]>dist\[t]+G.Edge\[t]\[j],åˆ™dist\[j]=dist\[t]+G.Edge\[t]\[j],è®°å½•é¡¶ç‚¹jçš„å‰é©±ä¸ºtï¼Œæœ‰p\[j]=t,è½¬åˆ°ç¬¬3æ­¥

æ ·ä¾‹æ­¥éª¤

![æœ‰å‘å›¾](<../../../.gitbook/assets/å±å¹•æˆªå›¾ 2022-05-23 074507.jpg>)

```cpp
                   1  2  3  4  5
âˆ 2 5 âˆ âˆ   dist[] 0  2  5  âˆ  âˆ 
âˆ âˆ 2 6 âˆ            
âˆ âˆ âˆ 7 1          1  2  3  4  5 
âˆ âˆ 2 âˆ 4      p[] -1 1  1 -1 -1
âˆ âˆ âˆ âˆ âˆ   V-S={2,3,4,5}

dist[2]æœ€å°ï¼Œå…¥æˆ˜é˜ŸV-S={2,3,4,5} å€Ÿä¸œé£  

                   1  2  3  4  5
âˆ 2 5 âˆ âˆ   dist[] 0  2  4  8  âˆ 
âˆ âˆ 2 6 âˆ            
âˆ âˆ âˆ 7 1          1  2  3  4  5 
âˆ âˆ 2 âˆ 4      p[] -1 1  2  2 -1
âˆ âˆ âˆ âˆ âˆ   V-S={3,4,5}

dist[3]æœ€å°ï¼Œå…¥æˆ˜é˜ŸV-S={4,5} å€Ÿä¸œé£  

                   1  2  3  4  5
âˆ 2 5 âˆ âˆ   dist[] 0  2  4  8  4 
âˆ âˆ 2 6 âˆ            
âˆ âˆ âˆ 7 1          1  2  3  4  5 
âˆ âˆ 2 âˆ 4      p[] -1 1  2  2  3
âˆ âˆ âˆ âˆ âˆ   V-S={4,5}

dist[4]æœ€å°ï¼Œå…¥æˆ˜é˜ŸV-S={5} å€Ÿä¸œé£  

                   1  2  3  4  5
âˆ 2 5 âˆ âˆ   dist[] 0  2  4  8  4 
âˆ âˆ 2 6 âˆ            
âˆ âˆ âˆ 7 1          1  2  3  4  5 
âˆ âˆ 2 âˆ 4      p[] -1 1  2  2  3
âˆ âˆ âˆ âˆ âˆ   V-S={5}  

dist[5]æœ€å°,å¦‚æˆ˜é˜ŸV-S={} ç»“æŸç®—æ³•
```

ä»£ç å®ç°

```cpp
//main1.cpp
#include<iostream>
#include <cstring>
#include <stack>
#include <climits>
using namespace std;
const int MaxVnum = 100;       // åŸå¸‚çš„ä¸ªæ•°å¯ä¿®æ”¹
const int INF = INT_MAX;           // æ— ç©·å¤§10000000
int dist[MaxVnum], p[MaxVnum]; //æœ€çŸ­è·ç¦»å’Œå‰é©±æ•°ç»„
bool flag[MaxVnum];            //å¦‚æœs[i]ç­‰äºtrueï¼Œè¯´æ˜é¡¶ç‚¹iå·²ç»åŠ å…¥åˆ°é›†åˆS;å¦åˆ™é¡¶ç‚¹iå±äºé›†åˆV-S

typedef string VexType; //é¡¶ç‚¹çš„æ•°æ®ç±»å‹ï¼Œæ ¹æ®éœ€è¦å®šä¹‰
typedef int EdgeType;   //è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹ï¼Œè‹¥ä¸å¸¦æƒå€¼çš„å›¾ï¼Œåˆ™ä¸º0æˆ–1
typedef struct
{
  VexType Vex[MaxVnum];//é¡¶ç‚¹
  EdgeType Edge[MaxVnum][MaxVnum];
  int vexnum, edgenum; //é¡¶ç‚¹æ•°ï¼Œè¾¹æ•°
} AMGragh;

//æ ¹æ®é¡¶ç‚¹æ•°æ®xæ‰¾åˆ°ç›¸åº”é¡¶ç‚¹çš„ä¸‹æ ‡
int locatevex(AMGragh G, VexType x)
{
  for (int i = 0; i < G.vexnum; i++) //æŸ¥æ‰¾é¡¶ç‚¹ä¿¡æ¯çš„ä¸‹æ ‡
    if (x == G.Vex[i])
      return i;
  return -1; //æ²¡æ‰¾åˆ°
}

//åˆå§‹åŒ–é‚»æ¥çŸ©é˜µ
void CreateAMGraph(AMGragh &G)
{
  int i, j, w;
  VexType u, v;
  cout << "è¯·è¾“å…¥é¡¶ç‚¹æ•°ï¼š" << endl;
  cin >> G.vexnum;
  cout << "è¯·è¾“å…¥è¾¹æ•°:" << endl;
  cin >> G.edgenum;
  cout << "è¯·è¾“å…¥é¡¶ç‚¹ä¿¡æ¯:" << endl;
  for (int i = 0; i < G.vexnum; i++) //è¾“å…¥é¡¶ç‚¹ä¿¡æ¯ï¼Œå­˜å…¥é¡¶ç‚¹ä¿¡æ¯æ•°ç»„
    cin >> G.Vex[i];
  for (int i = 0; i < G.vexnum; i++) //åˆå§‹åŒ–é‚»æ¥çŸ©é˜µä¸ºæ— ç©·å¤§
    for (int j = 0; j < G.vexnum; j++)
      G.Edge[i][j] = INF;
  cout << "è¯·è¾“å…¥æ¯æ¡è¾¹ä¾é™„çš„ä¸¤ä¸ªé¡¶ç‚¹åŠæƒå€¼ï¼š" << endl;
  while (G.edgenum--)
  {
    cin >> u >> v >> w;
    i = locatevex(G, u); //æŸ¥æ‰¾é¡¶ç‚¹uçš„å­˜å‚¨ä¸‹æ ‡
    j = locatevex(G, v); //æŸ¥æ‰¾é¡¶ç‚¹vçš„å­˜å‚¨ä¸‹æ ‡
    if (i != -1 && j != -1)
      G.Edge[i][j] = w; //æœ‰å‘å›¾é‚»æ¥çŸ©é˜µ
    else
    {
      cout << "è¾“å…¥é¡¶ç‚¹ä¿¡æ¯é”™ï¼è¯·é‡æ–°è¾“å…¥ï¼" << endl;
      G.edgenum++; //æœ¬æ¬¡è¾“å…¥ä¸ç®—
    }
  }
}

//å•æºæœ€çŸ­è·¯å¾„ç®—æ³•
void Dijkstra(AMGragh G, int u)
{
  for (int i = 0; i < G.vexnum; i++)
  {
    dist[i] = G.Edge[u][i]; //åˆå§‹åŒ–æºç‚¹uåˆ°å…¶ä»–å„ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„é•¿åº¦
    flag[i] = false;
    if (dist[i] == INF)
      p[i] = -1; //æºç‚¹uåˆ°è¯¥é¡¶ç‚¹çš„è·¯å¾„é•¿åº¦ä¸ºæ— ç©·å¤§ï¼Œè¯´æ˜é¡¶ç‚¹iä¸æºç‚¹uä¸ç›¸é‚»
    else
      p[i] = u; //è¯´æ˜é¡¶ç‚¹iä¸æºç‚¹uç›¸é‚»ï¼Œè®¾ç½®é¡¶ç‚¹içš„å‰é©±p[i]=u
  }
  dist[u] = 0;
  flag[u] = true; //åˆå§‹æ—¶ï¼Œé›†åˆSä¸­åªæœ‰ä¸€ä¸ªå…ƒç´ ï¼šæºç‚¹u trueä»£è¡¨åŠ å…¥åˆ°S
  for (int i = 0; i < G.vexnum; i++)
  {
    int temp = INF, t = u;
    for (int j = 0; j < G.vexnum; j++) //åœ¨é›†åˆV-Sä¸­å¯»æ‰¾è·ç¦»æºç‚¹uæœ€è¿‘çš„é¡¶ç‚¹t
      if (!flag[j] && dist[j] < temp)
      {
        t = j;
        temp = dist[j];
      }
    if (t == u)
      return;                          //æ‰¾ä¸åˆ°tï¼Œåˆ™ä¹Ÿä»£è¡¨V-Sä¸ºç©ºè·³å‡ºå¾ªç¯
    flag[t] = true;                    //å¦åˆ™ï¼Œå°†tåŠ å…¥é›†åˆ
    for (int j = 0; j < G.vexnum; j++) //æ›´æ–°ä¸tç›¸é‚»æ¥çš„é¡¶ç‚¹åˆ°æºç‚¹uçš„è·ç¦»
      if (!flag[j] && G.Edge[t][j] < INF)//ä¸ºä¸´æ—¶é¡¶ç‚¹çš„å‡ºåº¦
        if (dist[j] > (dist[t] + G.Edge[t][j]))
        {
          dist[j] = dist[t] + G.Edge[t][j];//å€Ÿä¸œé£
          p[j] = t;//æ›´æ”¹å‰é©±
        }
  }
}

//æ ¹æ®å‰é©±æ•°ç»„å¯»æ‰¾è·¯å¾„
void findpath(AMGragh G, VexType u)
{
  int x;
  stack<int> S;
  cout << "æºç‚¹ä¸ºï¼š" << u << endl;
  for (int i = 0; i < G.vexnum; i++)//æ‰¾èµ·ç‚¹åˆ°æ¯ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„
  {
    x = p[i];//ç›®æ ‡é¡¶ç‚¹çš„å‰é©±
    if (x == -1 && u != G.Vex[i])
    {
      cout << "æºç‚¹åˆ°å…¶å®ƒå„é¡¶ç‚¹æœ€çŸ­è·¯å¾„ä¸ºï¼š" << u << "--" << G.Vex[i] << "    sorry,æ— è·¯å¯è¾¾" << endl;
      continue;
    }
    while (x != -1)
    {
      S.push(x);//å…¥æ ˆ
      x = p[x];//å‘å‰æ‰¾å‰é©±
    }
    cout << "æºç‚¹åˆ°å…¶å®ƒå„é¡¶ç‚¹æœ€çŸ­è·¯å¾„ä¸ºï¼š";
    while (!S.empty())//å¼¹å‡ºæœ€çŸ­è·¯å¾„
    {
      cout << G.Vex[S.top()] << "--";
      S.pop();
    }
    cout << G.Vex[i] << "    æœ€çŸ­è·ç¦»ä¸ºï¼š" << dist[i] << endl;
  }
}

int main()
{
  AMGragh G; //é‚»æ¥çŸ©é˜µå­˜å‚¨å›¾
  int st;
  VexType u;
  CreateAMGraph(G); //åˆå§‹åŒ–å›¾ä¿¡æ¯
  cout << "è¯·è¾“å…¥æºç‚¹çš„ä¿¡æ¯:" << endl;
  cin >> u;
  st = locatevex(G, u); //æŸ¥æ‰¾æºç‚¹uçš„å­˜å‚¨ä¸‹æ ‡
  Dijkstra(G, st);      //å•æºæœ€çŸ­è·¯å¾„ç®—æ³•
  cout << "å°æ˜æ‰€åœ¨çš„ä½ç½®:" << u << endl;
  for (int i = 0; i < G.vexnum; i++)
  {
    cout << "å°æ˜:" << u << " - "
         << "è¦å»çš„ä½ç½®:" << G.Vex[i];
    if (dist[i] == INF)
      cout << "sorry,æ— è·¯å¯è¾¾" << endl;
    else
      cout << "æœ€çŸ­è·ç¦»ä¸º:" << dist[i] << endl;
  }
  findpath(G, u); //æ ¹æ®å‰é©±æ•°ç»„æ‰¾æœ€çŸ­è·¯å¾„
  return 0;
}
```

ç®—æ³•å¤æ‚åº¦åˆ†æ

æ—¶é—´å¤æ‚åº¦ O(n^2)\
ç©ºé—´å¤æ‚åº¦ O(n)

### å„é¡¶ç‚¹ä¹‹é—´æœ€çŸ­è·¯å¾„Folyd

Floydç®—æ³•å¯ä»¥æ±‚è§£ä»»æ„ä¸¤ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ŒFloydç®—æ³•åˆç§°æ’å¿ƒæ³•ï¼Œå…¶ç®—æ³•æ ¸å¿ƒæ˜¯åœ¨é¡¶ç‚¹iåˆ°é¡¶ç‚¹jä¹‹é—´ï¼Œæ’å…¥é¡¶ç‚¹k,çœ‹æ˜¯å¦èƒ½å¤Ÿç¼©çŸ­iå’Œjä¹‹é—´çš„è·ç¦»(æ¾å¼›æ“ä½œ)

ç®—æ³•æ­¥éª¤

1ã€`æ•°æ®ç»“æ„`è®¾ç½®åœ°å›¾çš„å¸¦æƒé‚»æ¥çŸ©é˜µG.Edge\[j],å³å¦‚æœä»iåˆ°jæœ‰è¾¹å°±ä»¤G.Edge\[i]\[i]ç­‰äº\<i,j>çš„æƒå€¼ï¼Œåˆ™G.Edge\[i]\[j]=âˆï¼Œé‡‡ç”¨æ•°ç»„dist\[i]\[j]æ¥è®°å½•ä»ié¡¶ç‚¹åˆ°é¡¶ç‚¹jçš„æœ€çŸ­è·¯å¾„é•¿åº¦ï¼Œé‡‡ç”¨æ•°ç»„p\[i]\[j]æ¥è®°å½•ä»iåˆ°jé¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ä¸Šié¡¶ç‚¹çš„å‰é©±\
2ã€`åˆå§‹åŒ–`åˆå§‹åŒ–dist\[i]\[j]=G.Edge\[i]\[j],å¦‚æœé¡¶ç‚¹iåˆ°é¡¶ç‚¹jæœ‰è¾¹ç›¸è¿ï¼Œåˆå§‹åŒ–p\[i]\[j]=i,å¦åˆ™p\[i]\[j]=-1\
3ã€`æ’ç‚¹`ï¼Œå…¶å®å°±æ˜¯åœ¨iä¸jä¹‹é—´æ’å…¥é¡¶ç‚¹kï¼Œçœ‹æ˜¯å¦èƒ½å¤Ÿç¼©çŸ­iå’Œjä¹‹é—´çš„è·ç¦»ï¼Œå¦‚æœdist\[i]\[j]>dist\[i]\[k]+dist\[k]\[j],åˆ™dist\[i]\[j]=dist\[i]\[k]+dist\[k]\[j],è®°å½•iï¼Œjçš„å‰é©±ä¸ºp\[i]\[j]=p\[k]\[j]

ä»£ç å®ç°

```cpp
//main2.cpp
#include<iostream>
#include<cstring>
#include<climits>
using namespace std;

#define MaxVnum 100  //é¡¶ç‚¹æ•°æœ€å¤§å€¼
const int INF=INT_MAX; // æ— ç©·å¤§10000000

typedef string VexType;  //é¡¶ç‚¹çš„æ•°æ®ç±»å‹ï¼Œæ ¹æ®éœ€è¦å®šä¹‰
typedef int EdgeType;  //è¾¹ä¸Šæƒå€¼çš„æ•°æ®ç±»å‹ï¼Œè‹¥ä¸å¸¦æƒå€¼çš„å›¾ï¼Œåˆ™ä¸º0æˆ–1
typedef struct{
 VexType Vex[MaxVnum];
 EdgeType Edge[MaxVnum][MaxVnum];
 int vexnum,edgenum; //é¡¶ç‚¹æ•°ï¼Œè¾¹æ•°
}AMGragh;

int dist[MaxVnum][MaxVnum],p[MaxVnum][MaxVnum];

int locatevex(AMGragh G,VexType x)
{
    for(int i=0;i<G.vexnum;i++)//æŸ¥æ‰¾é¡¶ç‚¹ä¿¡æ¯çš„ä¸‹æ ‡
       if(x==G.Vex[i])
        return i;
    return -1;//æ²¡æ‰¾åˆ°
}

void CreateAMGraph(AMGragh &G)//åˆ›å»ºæ— å‘å›¾çš„é‚»æ¥çŸ©é˜µ
{
    int i,j,w;
    VexType u,v;
    cout<<"è¯·è¾“å…¥é¡¶ç‚¹æ•°ï¼š"<<endl;
    cin>>G.vexnum;
    cout<<"è¯·è¾“å…¥è¾¹æ•°:"<<endl;
    cin>>G.edgenum;
    cout<<"è¯·è¾“å…¥é¡¶ç‚¹ä¿¡æ¯:"<<endl;
    for(int i=0;i<G.vexnum;i++)//è¾“å…¥é¡¶ç‚¹ä¿¡æ¯ï¼Œå­˜å…¥é¡¶ç‚¹ä¿¡æ¯æ•°ç»„
        cin>>G.Vex[i];
    for(int i=0;i<G.vexnum;i++)//åˆå§‹åŒ–é‚»æ¥çŸ©é˜µæ‰€æœ‰å€¼ä¸º0ï¼Œè‹¥æ˜¯ç½‘ï¼Œåˆ™åˆå§‹åŒ–ä¸ºæ— ç©·å¤§
  for(int j=0;j<G.vexnum;j++)
         if(i!=j)
             G.Edge[i][j]=INF;
         else
             G.Edge[i][j]=0; //æ³¨æ„i==jæ—¶ï¼Œè®¾ç½®ä¸º0
    cout<<"è¯·è¾“å…¥æ¯æ¡è¾¹ä¾é™„çš„ä¸¤ä¸ªé¡¶ç‚¹åŠæƒå€¼ï¼š"<<endl;
    while(G.edgenum--)
    {
       cin>>u>>v>>w;
       i=locatevex(G,u);//æŸ¥æ‰¾é¡¶ç‚¹uçš„å­˜å‚¨ä¸‹æ ‡
       j=locatevex(G,v);//æŸ¥æ‰¾é¡¶ç‚¹vçš„å­˜å‚¨ä¸‹æ ‡
       if(i!=-1&&j!=-1)
   G.Edge[i][j]=w; //æœ‰å‘å›¾é‚»æ¥çŸ©é˜µå­˜å‚¨æƒå€¼
    }
}

//ç”¨Floydç®—æ³•æ±‚æœ‰å‘ç½‘Gä¸­å„å¯¹é¡¶ç‚¹iå’Œjä¹‹é—´çš„æœ€çŸ­è·¯å¾„
void Floyd(AMGragh G) 
{
    int i,j,k;
    //å„å¯¹ç»“ç‚¹ä¹‹é—´åˆå§‹å·²çŸ¥è·¯å¾„åŠè·ç¦»
    for(i=0;i<G.vexnum;i++){
      for(j=0;j<G.vexnum;j++)
      {
          dist[i][j]=G.Edge[i][j];
          if(dist[i][j]<INF && i!=j)
   p[i][j]=i;   //å¦‚æœiå’Œjä¹‹é—´æœ‰å¼§ï¼Œåˆ™å°†jçš„å‰é©±ç½®ä¸ºi
          else p[i][j]=-1;  //å¦‚æœiå’Œjä¹‹é—´æ— å¼§ï¼Œåˆ™å°†jçš„å‰é©±ç½®ä¸º-1
      }
    }
 for(k=0;k<G.vexnum; k++)//æ’ç‚¹
  for(i=0;i<G.vexnum; i++)//i
   for(j=0;j<G.vexnum; j++)//j
                //ä»iç»kåˆ°jçš„ä¸€æ¡è·¯å¾„æ›´çŸ­
    if(dist[i][k]!=INF&&dist[k][j]!=INF&&dist[i][k]+dist[k][j]<dist[i][j])
                {
     dist[i][j]=dist[i][k]+dist[k][j]; //æ›´æ–°dist[i][j]
     p[i][j]=p[k][j];       //æ›´æ”¹jçš„å‰é©±ä¸ºk
    }
}

void print(AMGragh G)
{
    int i,j;
    for(i=0;i<G.vexnum;i++)//è¾“å‡ºæœ€çŸ­è·ç¦»æ•°ç»„
    {
        for(j=0;j<G.vexnum;j++)
            cout<<dist[i][j]<<"\t";
        cout<<endl;
    }
    cout<<endl;
    for(i=0;i<G.vexnum;i++)//è¾“å‡ºå‰é©±æ•°ç»„
    {
        for(j=0;j<G.vexnum;j++)
            cout<<p[i][j]<<"\t";
        cout<<endl;
    }
}

//é€’å½’å½¢å¼ï¼ŒåŒç†ä¹Ÿæ˜¯åˆ©ç”¨æ ˆçš„æ€§è´¨ï¼Œé€†æ¨ä¸”æ­£å‘è¾“å‡º
void DisplayPath(AMGragh G,int s,int t )//æ˜¾ç¤ºæœ€çŸ­è·¯å¾„
{
 if(p[s][t]!=-1)
    {
  DisplayPath(G,s,p[s][t]);
  cout<<G.Vex[p[s][t]]<<"-->";
 }
}

int main()
{
    VexType start,destination;
    int u,v;
    AMGragh G;
    CreateAMGraph(G);
    Floyd(G);
    print(G);
 cout<<"è¯·ä¾æ¬¡è¾“å…¥è·¯å¾„çš„èµ·ç‚¹ä¸ç»ˆç‚¹çš„åç§°ï¼š";
 cin>>start>>destination;
 u=locatevex(G,start);
 v=locatevex(G,destination);
 DisplayPath(G,u,v);
 cout<<G.Vex[v]<<endl;
 cout<<"æœ€çŸ­è·¯å¾„çš„é•¿åº¦ä¸ºï¼š"<<dist[u][v]<<endl;
 cout<<endl;
    return 0;
}
```

ç®—æ³•å¤æ‚åº¦åˆ†æ

æ—¶é—´å¤æ‚åº¦O(n^3),Floydæ˜¯ä¸€ä¸ªæš´åŠ›æšä¸¾çš„ç®—æ³•ï¼Œå°è¯•äº†å°½æœ‰çš„å¯èƒ½ï¼Œä¿ç•™æœ€ä¼˜çš„\
ç©ºé—´å¤æ‚åº¦O(n^2)

> Dijkstraç®—æ³•æ— æ³•å¤„ç†å¸¦è´Ÿæƒå€¼è¾¹çš„å›¾ï¼ŒFloydç®—æ³•å¯ä»¥å¤„ç†å¸¦è´Ÿæƒå€¼è¾¹çš„å›¾ï¼Œä½†æ˜¯ä¸å…è®¸å›¾ä¸­åŒ…å«è´Ÿåœˆï¼ˆæƒå€¼ä¸ºè´Ÿçš„åœˆï¼‰ï¼Œå…¶ä»–è§£å†³è´Ÿæƒå€¼è¾¹çš„æœ€çŸ­è·¯å¾„ç®—æ³•Bellman-Fordå’ŒSPFAç®—æ³•

### æœ€å°ç”Ÿæˆæ ‘Prim

### æœ€å°ç”Ÿæˆæ ‘Kruskal

### æœ‰å‘æ— ç¯å›¾çš„è¡¨ç¤ºæ–¹å¼

### æ‹“æ‰‘æ’åº

### å…³é”®è·¯å¾„
