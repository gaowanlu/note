---
coverY: 0
---

# 第 10 章 信号

## 信号

### 信号的概念

首先什么是信号，信号是软件中断。  
异步事件的处理：查询法（如循环检测）、通知法（如条件变量）
信号的响应依赖于中断

```shell
gaowanlu@DESKTOP-QDLGRDB:/$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

1~31 为标准信号。32~64 为实时信号。

![UNIX系统信号](../../.gitbook/assets/2023-02-23230037.jpg)

### core 文件

当出错时可以保存现场为 core 文件，默认是不产生 core 文件的,默认 core 文件大小限制为 0

```cpp
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7823
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7823
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

将限制修改

```shell
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -c 10240
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -a
core file size          (blocks, -c) 10240
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7823
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7823
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

设置 core 产生位置为执行文件位置

```cpp
root@drecbb4udzdboiei-0626900:~# echo  "core-%e-%p-%t" > /proc/sys/kernel/core_pattern
```

测试样例

```cpp
//main.cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int *arr;
    arr[1]=12;
    return 0;
}
```

执行 main 产生 core 文件

```cpp
root@drecbb4udzdboiei-0626900:~# ls
core-main-4106040-1677165752  core-main-4106044-1677165757    main
```

### signal 函数

相关函数，ANSI C signal handling，绑定信号处理函数

重点：信号会打断阻塞的系统调用，例如在 sleep 中，但有信号传递过来则 sleep 会被打断,如 open、read 都有可能被打断，errno=EINTR

复杂情况：在处理一个信号时又来了一个相同信号需要处理，会怎样的，处理函数的现场是内核布置的所以可能冲掉前面的处理现场

```cpp
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

样例

```cpp
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

void handler(int sig)
{
    cout << sig << endl;
    fflush(stdout);
    // exit(0);//Ctrl+C不会使得程序退出
}

int main(int argc, char **argv)
{
    signal(SIGINT, handler);
    // signal(SIGINT, SIG_IGN); 收到SIGINT但对信号不做任何处理
    for (int i = 0; i < 10; i++)
    {
        cout << "*";
        fflush(nullptr);
        sleep(1);
    }
    return 0;
}
```

信号打断阻塞

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
using namespace std;

int main(int argc, char **argv)
{
    int fd;
    do
    {
        fd = open("./temp.txt", O_RDWR);
        if (fd < 0)
        {
            if (errno != EINTR) // 非信号打断则是真错误
            {
                cerr << "open error" << endl;
                exit(1);
            }
        }
    } while (fd < 0); // 被打断则再次尝试
    FILE *fp = fdopen(fd, "a+");
    fprintf(fp, "hello world\n");
    fflush(fp);
    return 0;
}
            //   ┌─────────────┬───────────────────────────────┐
            //   │fopen() mode │ open() flags                  │
            //   ├─────────────┼───────────────────────────────┤
            //   │     r       │ O_RDONLY                      │
            //   ├─────────────┼───────────────────────────────┤
            //   │     w       │ O_WRONLY | O_CREAT | O_TRUNC  │
            //   ├─────────────┼───────────────────────────────┤
            //   │     a       │ O_WRONLY | O_CREAT | O_APPEND │
            //   ├─────────────┼───────────────────────────────┤
            //   │     r+      │ O_RDWR                        │
            //   ├─────────────┼───────────────────────────────┤
            //   │     w+      │ O_RDWR | O_CREAT | O_TRUNC    │
            //   ├─────────────┼───────────────────────────────┤
            //   │     a+      │ O_RDWR | O_CREAT | O_APPEND   │
            //   └─────────────┴───────────────────────────────┘
```

### 信号的可靠与不可靠

#### 不可靠

1~31 信号 ——不支持排队，为普通信号。（不能用于统计信号发生次数的情景。）
SIGRTMIN-SIGRTMAX 信号 ——支持排队，实时信号

不可靠的意思是信号可能丢失或者被错误处理。信号的不可靠是行为的不可靠  
在早起系统中，信号存在两大缺陷，导致了信号不可靠

在处理一个信号时又来了一个相同信号需要处理，会怎样的，处理函数的现场是内核布置的所以可能冲掉前面的处理现场

缺陷 1：

系统早期馊主意，信号发生后，信号处理方式被重置为系统默认动作，只响应一次

```cpp
int  sig_int(); /* my signal handling function */
...
signal(SIGINT, sig_int); /* @1establish handler    */
...
sig_int()
{
    //如果再次被信号打断 则那么针对这个信号的处理方式就是系统默认的方法了
    signal(SIGINT, sig_int); /* @2reestablish handler for next time */
    ...
    ./*process the signal ... */
    ...
}

```

缺陷 2：

信号对进程的控制能力差，早期系统不能关闭信号，但是在执行后又需要提醒我们发生过信号

```cpp
pause - wait for signal
#include <unistd.h>
int pause(void);
```

```cpp
int  sig_int();     /* my signal handling function */
int  sig_int_flag; /* set nonzero when signal occurs */
main()
{
    signal(SIGINT, sig_int); /* establish handler */
    ...
    while (sig_int_flag == 0)
        pause();  /* go to sleep, waiting for signal */
    ...
}
sig_int()
{
    signal(SIGINT, sig_int); /* reestablish handler for next time */
    sig_int_flag = 1; /* set flag for main loop to examine */
}
// sig_int只有两行代码，它的作用就是忽略信号，并且用sig_int_flag标志信号发生过。
// 用while因为pause可能会被其他信号中断
// 缺陷：如果while与pause之间有信号发生，而且以后不再有信号发生则会一直pause下去，一直进入睡眠状态。
```

#### 可靠

可靠信号针对解决不可靠信号的两点缺陷来理解：

解决缺陷 1：

用 sigaction 代替 signal，现代大多数系统中，signal 也使用了 sigaction 实现，因此事可靠的。建议尽可能使用 sigaction 替代 signal，因为 sigaction 是同一的标准，可移植性强。可以说现在系统的信号处理方式是可靠的。不会只能执行一次。

解决缺陷 2：

用户可以通过 sigprocmask、sigaction 设置屏蔽字是信号阻塞。使信号处于 pending 状态，这样也就自然解决了缺陷二。

### 中断的系统调用

### 可重入函数

### SIGCLD 语义

### 可靠信号术语和语义

### 信号的响应过程

### 信号常用函数

kill、raise、alarm、pause、sleep

### 信号集

### 信号屏蔽字与 pending 集的处理

### 扩展

sigprocmask、sigpending、sigsetjmp、siglongjmp、sigsuspend、abort、system、sleep、nanosleep、clock_nanosleep、sigqueue

sigsuspend、sigaction、setitimer

### 实时信号

### 作业控制信号

### 信号名和编号
