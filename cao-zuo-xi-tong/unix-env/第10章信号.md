---
coverY: 0
---

# 第 10 章 信号

## 信号

### 信号的概念

首先什么是信号，信号是软件中断。  
异步事件的处理：查询法（如循环检测）、通知法（如条件变量）
信号的响应依赖于中断

```shell
gaowanlu@DESKTOP-QDLGRDB:/$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
63) SIGRTMAX-1  64) SIGRTMAX
```

1~31 为标准信号。32~64 为实时信号。

![UNIX系统信号](../../.gitbook/assets/2023-02-23230037.jpg)

### core 文件

当出错时可以保存现场为 core 文件，默认是不产生 core 文件的,默认 core 文件大小限制为 0

```cpp
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -a
core file size          (blocks, -c) 0
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7823
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7823
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

将限制修改

```shell
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -c 10240
gaowanlu@DESKTOP-QDLGRDB:/$ ulimit -a
core file size          (blocks, -c) 10240
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
file size               (blocks, -f) unlimited
pending signals                 (-i) 7823
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
open files                      (-n) 1024
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 7823
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
```

设置 core 产生位置为执行文件位置

```cpp
root@drecbb4udzdboiei-0626900:~# echo  "core-%e-%p-%t" > /proc/sys/kernel/core_pattern
```

测试样例

```cpp
//main.cpp
#include <iostream>
using namespace std;

int main(int argc, char **argv)
{
    int *arr;
    arr[1]=12;
    return 0;
}
```

执行 main 产生 core 文件

```cpp
root@drecbb4udzdboiei-0626900:~# ls
core-main-4106040-1677165752  core-main-4106044-1677165757    main
```

### signal 函数

相关函数，ANSI C signal handling，绑定信号处理函数

重点：信号会打断阻塞的系统调用，例如在 sleep 中，但有信号传递过来则 sleep 会被打断,如 open、read 都有可能被打断，errno=EINTR

复杂情况：在处理一个信号时又来了一个相同信号需要处理，会怎样的，处理函数的现场是内核布置的所以可能冲掉前面的处理现场

```cpp
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

样例

```cpp
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

void handler(int sig)
{
    cout << sig << endl;
    fflush(stdout);
    // exit(0);//Ctrl+C不会使得程序退出
}

int main(int argc, char **argv)
{
    signal(SIGINT, handler);
    // signal(SIGINT, SIG_IGN); 收到SIGINT但对信号不做任何处理
    for (int i = 0; i < 10; i++)
    {
        cout << "*";
        fflush(nullptr);
        sleep(1);
    }
    return 0;
}
```

信号打断阻塞

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
using namespace std;

int main(int argc, char **argv)
{
    int fd;
    do
    {
        fd = open("./temp.txt", O_RDWR);
        if (fd < 0)
        {
            if (errno != EINTR) // 非信号打断则是真错误
            {
                cerr << "open error" << endl;
                exit(1);
            }
        }
    } while (fd < 0); // 被打断则再次尝试
    FILE *fp = fdopen(fd, "a+");
    fprintf(fp, "hello world\n");
    fflush(fp);
    return 0;
}
            //   ┌─────────────┬───────────────────────────────┐
            //   │fopen() mode │ open() flags                  │
            //   ├─────────────┼───────────────────────────────┤
            //   │     r       │ O_RDONLY                      │
            //   ├─────────────┼───────────────────────────────┤
            //   │     w       │ O_WRONLY | O_CREAT | O_TRUNC  │
            //   ├─────────────┼───────────────────────────────┤
            //   │     a       │ O_WRONLY | O_CREAT | O_APPEND │
            //   ├─────────────┼───────────────────────────────┤
            //   │     r+      │ O_RDWR                        │
            //   ├─────────────┼───────────────────────────────┤
            //   │     w+      │ O_RDWR | O_CREAT | O_TRUNC    │
            //   ├─────────────┼───────────────────────────────┤
            //   │     a+      │ O_RDWR | O_CREAT | O_APPEND   │
            //   └─────────────┴───────────────────────────────┘
```

### 信号的可靠与不可靠

#### 不可靠

1~31 信号 ——不支持排队，为普通信号。（不能用于统计信号发生次数的情景。）
SIGRTMIN-SIGRTMAX 信号 ——支持排队，实时信号

不可靠的意思是信号可能丢失或者被错误处理。信号的不可靠是行为的不可靠  
在早起系统中，信号存在两大缺陷，导致了信号不可靠

在处理一个信号时又来了一个相同信号需要处理，会怎样的，处理函数的现场是内核布置的所以可能冲掉前面的处理现场

缺陷 1：

系统早期馊主意，信号发生后，信号处理方式被重置为系统默认动作，只响应一次

```cpp
int  sig_int(); /* my signal handling function */
...
signal(SIGINT, sig_int); /* @1establish handler    */
...
sig_int()
{
    //如果再次被信号打断 则那么针对这个信号的处理方式就是系统默认的方法了
    signal(SIGINT, sig_int); /* @2reestablish handler for next time */
    ...
    ./*process the signal ... */
    ...
}

```

缺陷 2：

信号对进程的控制能力差，早期系统不能关闭信号，但是在执行后又需要提醒我们发生过信号

```cpp
pause - wait for signal
#include <unistd.h>
int pause(void);
```

```cpp
int  sig_int();     /* my signal handling function */
int  sig_int_flag; /* set nonzero when signal occurs */
main()
{
    signal(SIGINT, sig_int); /* establish handler */
    ...
    while (sig_int_flag == 0)
        pause();  /* go to sleep, waiting for signal */
    ...
}
sig_int()
{
    signal(SIGINT, sig_int); /* reestablish handler for next time */
    sig_int_flag = 1; /* set flag for main loop to examine */
}
// sig_int只有两行代码，它的作用就是忽略信号，并且用sig_int_flag标志信号发生过。
// 用while因为pause可能会被其他信号中断
// 缺陷：如果while与pause之间有信号发生，而且以后不再有信号发生则会一直pause下去，一直进入睡眠状态。
```

#### 可靠

可靠信号针对解决不可靠信号的两点缺陷来理解：

解决缺陷 1：

用 sigaction 代替 signal，现代大多数系统中，signal 也使用了 sigaction 实现，因此事可靠的。建议尽可能使用 sigaction 替代 signal，因为 sigaction 是同一的标准，可移植性强。可以说现在系统的信号处理方式是可靠的。不会只能执行一次。

解决缺陷 2：

用户可以通过 sigprocmask、sigaction 设置屏蔽字是信号阻塞。使信号处于 pending 状态，这样也就自然解决了缺陷二。

### 可重入函数

可重入函数：函数还没结束，又发生了再次调用  
所有的系统调用都是可重入函数、可重入函数不一定是系统调用  
一部分标准库函数也是可重入的（例如 memcpy）

```cpp
struct tm *localtime(const time_t *timep);
struct tm *localtime_r(const time_t *timep, struct tm *result);
//_r 就是可重入版本
```

### 信号的响应过程

内核为每个进程都维护有 mask、pending 两个位图（默认 32 位）。mask 是屏蔽字、pending 记录发生了哪些信号。  
mask 默认全部位为 1、pending 每个位为 0.  
中断时内核作业就绪队列排队、轮到时即将从内核态回到用户态时，mask 与 pending 按位与为 0 说明没有任何信号，回到用户态  
信号从收到到响应有一个避免的延迟

思考：如何忽略掉一个信号的？标准信号为什么要丢失？

如果 mask&pending 得出有信号、则将响应两个位改为 0，则响应信号相关指定函数  
执行完信号处理函数后、回到内核排队将 mask 相应位改为 1，队列排到时 mask&pendding,相位为 0，信号被响应过了  
在接收到多个标准信号时，先响应谁是没有严格的规定顺序

标准信号为什么要丢失？

```cpp
mask pending
1       0    //原始
1       1    //来了信号
0       0    //去执行信号处理函数时
0       1    //执行处理函数期间，接收到了很多此信号，则多次将pending相应位置1
1       1    //处理函数返回 将mask改为1
0       0    //再次执行处理函数
1       0    //处理函数返回 队列轮到 没有信号发生了，去执行用户代码
```

### kill 函数

```cpp
//send signal to a process
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
/*
pid：
>0 发送给指定进程
0  发送给与当前进程同组的所有进程
-1 只要有给目标进程发信号的权限，则都会发送，除了init进程
<0 发送给进程组号为-pid内的所有进程
将sig=0，不会发出任何信号，但有检测进程或进程组是否存在的功能(返回-1、errno==ESRCH)
 */
```

样例,给子进程发信号，使得子进程结束

```cpp
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
#include <signal.h>

using namespace std;

void handler(int sig)
{
    cout << "child over" << endl;
    exit(0);
}

int main(int argc, char **argv)
{
    pid_t id = fork();
    if (id < 0)
    {
        exit(-1);
    }
    if (id == 0)
    {
        signal(SIGINT, handler);
        for (int i = 0; i < 10000; i++)
        {
            cout << i << endl;
            sleep(1);
        }
    }
    sleep(10);
    kill(id, SIGINT);
    return 0;
}
```

### raise 函数

给当前进程发送信号

```cpp
//send a signal to the caller
#include <signal.h>
int raise(int sig);
//kill(getpid(),sig);进程中调用
//pthread_kill(pthread_self(),sig); 以线程发信号
```

样例

```cpp
#include <iostream>
#include <signal.h>
using namespace std;

void handler(int sig)
{
    if (sig == SIGINT)
        cout << "SIGINT" << endl;
}

int main(int argc, char **argv)
{
    signal(SIGINT, handler);
    raise(SIGINT);
    return 0;
}
// gaowanlu@DESKTOP-QDLGRDB:/$ ./main
// SIGINT
```

### alarm 函数

倒计时为 0 时会向调用进程发送 SIGALRM(定时器超时)信号

```cpp
//set an alarm clock for delivery of a signal
//倒计时后会向当前进程发送SIGALRM信号
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

样例

```cpp
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

void handler(int sig)
{
    if (sig == SIGALRM)
        cout << "SIGALRM" << endl;
}

int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    cout << "5秒后发送信号" << endl;
    alarm(5);
    sleep(10); // sleep(10) 会被信号打断
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
5秒后发送信号
SIGALRM
*/
```

### pause 函数

等待信号

```cpp
//wait for signal
#include <unistd.h>
int pause(void);
```

样例

```cpp
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

void handler(int sig)
{
    if (sig == SIGALRM)
        cout << "SIGALRM" << endl;
}

int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    cout << "5秒后发送信号" << endl;
    alarm(5);
    // alarm(5);//alarm不能连用
    pause();
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
5秒后发送信号
SIGALRM
*/
```

### sleep 函数

有些系统的 sleep 是用 alarm 与 pause 组合起来形成的  
linux 一般 sleep 是用得 nanosleep 封装的

```cpp
//sleep for a specified number of seconds
#include <unistd.h>
unsigned int sleep(unsigned int seconds);
```

样例

```cpp
#include <iostream>
#include <signal.h>
#include <unistd.h>
using namespace std;

void handler(int sig)
{
    if (sig == SIGALRM)
        cout << "SIGALRM" << endl;
}

int main(int argc, char **argv)
{
    signal(SIGALRM, handler);
    sleep(5);
    cout << "sleep over" << endl;
    alarm(5);
    pause();
    cout << "alarm + pause over" << endl;
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
sleep over
SIGALRM
alarm + pause over
 */
```

### 定时循环样例

### 中断的系统调用

### SIGCLD 语义

### 可靠信号术语和语义

### 信号集

### 信号屏蔽字与 pending 集的处理

### 扩展

sigprocmask、sigpending、sigsetjmp、siglongjmp、sigsuspend、abort、system、sleep、nanosleep、clock_nanosleep、sigqueue

sigsuspend、sigaction、setitimer

### 实时信号

### 作业控制信号

### 信号名和编号
