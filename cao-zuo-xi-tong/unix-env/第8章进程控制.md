---
coverY: 0
---

# 第 8 章 进程控制

## 进程控制

### 进程的基本知识

### 进程标识符 pid

pid_t 有符号 16 位、ps 命令、进程号是顺次向下使用、getpid()获取进程 id、getppid()获取父进程 id

```cpp
#include <sys/types.h>
#include <unistd.h>
pid_t getpid(void); //调用进程的进程id
pid_t getppid(void); //调用进程的父进程id
uid_t getuid(void); //调用进程的实际用户ID
uid_t geteuid(void); //调用进程的有效用户id
gid_t getgid(void); //调用进程的实际组id
gid_t getegid(void); //调用进程的有效组id
```

1、实际用户 ID 和实际用户组 ID：标识我是谁。也就是登录用户的 uid 和 gid，比如我的 Linux 以 simon 登录，在 Linux 运行的所有的命令的实际用户 ID 都是 simon 的 uid，实际用户组 ID 都是 simon 的 gid（可以用 id 命令查看）。

2、有效用户 ID 和有效用户组 ID：进程用来决定我们对资源的访问权限。一般情况下，有效用户 ID 等于实际用户 ID，有效用户组 ID 等于实际用户组 ID。当设置-用户-ID（SUID）位设置，则有效用户 ID 等于文件的所有者的 uid，而不是实际用户 ID；同样，如果设置了设置-用户组-ID（SGID）位，则有效用户组 ID 等于文件所有者的 gid，而不是实际用户组 ID。

```cpp
#include <iostream>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
int main(int argc, char **argv)
{
    cout << "pid=" << getpid() << endl;
    cout << "ppid=" << getppid() << endl;
    cout << "uid=" << getuid() << endl;
    cout << "euid=" << geteuid() << endl;
    cout << "gid=" << getgid() << endl;
    cout << "egid=" << getegid() << endl;
    return 0;
}
// pid = 102 ppid = 10 uid = 1000 euid = 1000 gid = 1000 egid = 1000
```

### 进程的产生 fork(); vfork();

```cpp
#include <sys/types.h>
#include <unistd.h>
pid_t fork(void);
pid_t vfork(void);
```

duplicating 意味着拷贝克隆  
fork 后父子进程的区别：fork 返回值不同、pid 不同、ppid 不同、未决信号和文件锁不继承、资源利用量清零  
init 进程：是所有进程的祖先进程、PID=1

在 fork 时，缓冲区的内容也会被复制，所以刷新缓冲区操作显得很重要。

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
int main(int argc, char **argv)
{
    int val = 999;
    cout << "start" << endl;
    fflush(nullptr);
    pid_t pid = fork();
    if (pid < 0)
    {
        perror("pid<0");
    }
    else if (pid == 0) // 子进程
    {
        cout << val << "子进程 pid = " << pid << " ppid = " << getppid() << endl;
    }
    else // 父进程
    {
        cout << val << "父进程 pid = " << getpid() << endl;
    }
    return 0;
}
/*
start
999父进程 pid = 168
999子进程 pid = 0 ppid = 168
*/
```

进程并发小实例

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
using namespace std;
#define RIGHT 3320
#define LEFT 3000

bool check(int val)
{
    bool res = true;
    for (int i = 2; i < val / 2; i++)
    {
        if (val % i == 0)
        {
            res = false;
            break;
        }
    }
    return res;
}

int main(int argc, char **argv)
{
    for (int i = LEFT; i <= RIGHT; i++)
    {
        int pid = fork();
        if (pid == 0)
        {
            if (check(i))
            {
                cout << i << endl;
            }
            return 0;
        }
    }
    return 0;
}
```

### 父子进程之间对打开文件的共享

每个进程有自己的表项，fd 与文件指针的映射表，子进程表项来源于父进程的拷贝。文件指针所指向的文件表是由操作系统管理的，并不会随着 fork 而复制新的文件表。

![](../../.gitbook/assets/2023-02-16125124.jpg)

### init 进程与 vfork

进程状态

```bash
$man ps
PROCESS STATE CODES
Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:

D    uninterruptible sleep (usually IO)
I    Idle kernel thread
R    running or runnable (on run queue)
S    interruptible sleep (waiting for an event to complete)
T    stopped by job control signal
t    stopped by debugger during the tracing
W    paging (not valid since the 2.6.xx kernel)
X    dead (should never be seen)
Z    defunct ("zombie 僵尸") process, terminated but not reaped by its parent
```

当子进程结束时，父进程没有结束则子进程会称为僵尸进程，父进程结束时子进程将会称为孤儿进程。 孤儿进程将会由 init 进程接管，释放其资源。

关于 vfork

```cpp
#include <sys/types.h>
#include <unistd.h>
pid_t vfork(void);
```

vfork()会产生一个新的子进程.但是 vfork 创建的子进程与父进程共享数据段,而且由 vfork()创建的
子进程将先于父进程运行.fork()的使用详见百度词条 fork().  
vfork()用法与 fork()相似.但是也有区别,具体区别归结为以下 3 点:

1. fork():子进程拷贝父进程的数据段，代码段. vfork():子进程与父进程共享数据段.
2. fork():父子进程的执行次序不确定.vfork():保证子进程先运行，在调用 exec 或\_exit 之前与父进程数据是共享的,在它调用 exec 或\_exit 之后父进程才可能被调度运行。
3. vfork()保证子进程先运行，在她调用 exec 或\_exit 之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
4. 当需要改变共享数据段中变量的值，则拷贝父进程。

### 进程的消亡与资源释放 wait waitpid waitid

```cpp
#include <sys/types.h>
#include <sys/wait.h>
pid_t wait(int *wstatus);//等待进程状态发生变化
pid_t waitpid(pid_t pid, int *wstatus, int options);
// pid:
// > 0 等待进程ID与pid相等的子进程
// 0   等待组ID等于调用进程组ID的任一子进程
// -1  等待任一子进程
// <-1 等待组ID等于pid绝对值的任一子进程
// options:
// WNOHANG 没有子进程结束则立即返回,waitpid变为非阻塞
// WCONTINUED pid指定子进程在停止后已经继续，但状态尚未报告则返回其状态
// WUNTRACED pid指定子进程已处于停止状态，但状态尚未报告则返回其状态
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
//waitid与waitpid类似
```

waitid 参数

![waitid的idtype](../../.gitbook/assets/2023-02-19000259.jpg)
![waitid的options](../../.gitbook/assets/2023-02-19000349.jpg)

wait 样例

```cpp
//demo
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

using namespace std;

int main(int argc, char **argv)
{
    pid_t id = fork();
    if (id < 0)
    {
        return 0;
    }
    else if (id == 0) // child
    {
        cout << "child" << endl;
        exit(0);
    }
    int status;
    pid_t res_id = wait(&status);
    cout<<"child process "<<res_id<<" status changed"<<endl;
    cout << "parent" << endl;
    cout << res_id << endl;
    if (WIFEXITED(status))
    {
        cout << "正常结束退出码=" << WEXITSTATUS(status) << endl;
        cout << "子进程正常终止" << endl;
    }
    else if (WIFSIGNALED(status))
    {
        cout << "子进程由信号终止" << endl;
        cout << "导致子进程结束的信号码=" << WTERMSIG(status) << endl;
        if (WCOREDUMP(status))
        {
            cout << "产生了core dump文件" << endl;
        }
    }
    if (WIFSTOPPED(status))
    {
        cout << "子进程已暂停" << endl;
        cout << "STOPSIG=" << WSTOPSIG(status) << endl;
    }

    if (WIFCONTINUED(status))
    {
        cout << "the child process was resumed by delivery of SIGCONT." << endl;
    }

    return 0;
}
/*
child
child process 244 status changed
parent
244
正常结束退出码=0
子进程正常终止
*/
```

waitpid 样例

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

using namespace std;

int main(int argc, char **argv)
{
    pid_t id = fork();
    if (id < 0)
    {
        return 0;
    }
    else if (id == 0) // child
    {
        cout << "child" << endl;
        exit(0);
    }
    int status;
    pid_t res = waitpid(id, &status, WCONTINUED | WUNTRACED);
    cout << "parent" << endl;
    return 0;
}
/*
child
parent
 */
```

### exec 函数族

执行一个文件 execute a file

```cpp
#include <unistd.h>
extern char **environ;
int execl(const char *pathname, const char *arg, ...
                       /* (char  *) NULL */);
int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);//filename 会直接在环境变量中找path
int execle(const char *pathname, const char *arg, ...
                       /*, (char *) NULL, char *const envp[] */);
int execv(const char *pathname, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execvpe(const char *file, char *const argv[],
                       char *const envp[]);
// 传参从 argv0 开始的
```

用新的进程镜像替换旧的进程镜像

```cpp
#include <iostream>
#include <unistd.h>
using namespace std;

int main(int argc, char **argv)
{
    int res;
    fflush(nullptr);
    res = execl("/bin/bash", "bash",nullptr); // 新进程替换此进程,pid不变
    if (res == -1)
    {
        perror("execl error");
    }
    return 0;
}
```

fork、wait 与 exec

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
using namespace std;

int main(int argc, char **argv)
{
    pid_t pid = fork();
    if (pid < 0)
    {
        perror("pid <0");
        exit(0);
    }
    if (pid == 0)
    {
        execl("/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode/other", "other",nullptr);
        exit(0);
    }
    if (pid > 0)
    {
        int status;
        pid_t res = wait(&status);
        cout << res << " is overed" << endl;
    }
    return 0;
}

/*
other file output "hello world"
gaowanlu@DESKTOP-QDLGRDB:/mnt/c/Users/gaowanlu/Desktop/MyProject/note/testcode$ ./main
hello world
289 is overed
*/
```

### 用户权限与组权限

[视频](https://www.bilibili.com/video/BV1yJ411S7r6/?p=56&spm_id_from=pageDriver&vd_source=0d24d1529ac7f38c08b67c3298ab14a0)

### 解释器文件

### system();函数

### 进程会计

### 进程时间

### 守护进程

### 系统日志
