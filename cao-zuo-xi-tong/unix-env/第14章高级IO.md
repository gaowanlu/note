---
coverY: 0
---

# 第 14 章 高级 IO

## 高级 IO

### 非阻塞 IO

在 Linux 系统编程中，非阻塞 I/O 是一种编程模型，它允许程序在执行 I/O 操作时不被阻塞。相比于传统的阻塞 I/O 模型，在非阻塞 I/O 模型中，I/O 操作会立即返回，而不需要等待 I/O 操作完成。这使得程序可以同时处理多个 I/O 操作或者执行其他计算任务，提高了程序的并发性能。

在 Linux 中，可以使用 fcntl 系统调用或者使用套接字选项来设置非阻塞 I/O。通过将文件描述符设置为非阻塞模式，当读写操作无法立即完成时，系统调用会立即返回一个错误码，而不是一直等待直到操作完成。程序可以根据错误码判断是否需要重新尝试 I/O 操作，或者切换到处理其他任务。

需要注意的是，在非阻塞 I/O 模型中，应用程序需要不断轮询文件描述符，以便及时发现 I/O 操作的完成。可以使用轮询函数（如 select、poll、epoll）来实现这一点。同时，由于非阻塞 I/O 模型中涉及到并发访问文件描述符，因此需要考虑线程安全等问题。

总的来说，非阻塞 I/O 是 Linux 系统编程中常用的一种编程模型，它可以提高程序的并发性能，但也需要程序员考虑一些额外的问题。

#### fcntl 函数

复制文件描述符：cmd 取值为 F_DUPFD，arg 为目标文件描述符的最小值，表示将 fd 复制到一个新的文件描述符，该文件描述符的值不小于 arg。

获取/设置文件描述符标记：cmd 取值为 F_GETFD/F_SETFD，arg 为要获取/设置的标记。标记可以是 FD_CLOEXEC（表示在调用 exec 系列函数时关闭文件描述符）、FD_NONBLOCK（表示将文件描述符设置为非阻塞模式）等。

获取/设置文件状态标志：cmd 取值为 F_GETFL/F_SETFL，arg 为要获取/设置的状态标志。状态标志可以是 O_NONBLOCK（与 FD_NONBLOCK 作用相同）、O_APPEND（表示在写入文件时追加而不是覆盖）等。

获取/设置记录锁：cmd 取值为 F_GETLK/F_SETLK/F_SETLKW，arg 为要获取/设置的锁结构体。锁结构体包含锁的起始偏移量、长度、锁的类型等信息。

```cpp
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */ );
```

### 数据中继案例

实现

```cpp
      >--read--->(buf)>---write-->
                FSM1
(tty1)                           (tty2)
                FSM2
      <--write--<(buf)<---read---<
```

代码样例

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string>
#include <unistd.h>
#include <errno.h>

#define TTY1 "/dev/tty2"
#define TTY2 "/dev/tty3"
#define BUFFSIZE 1024

using namespace std;

// 状态机状态
enum
{
    STATE_R = 1, // 读态
    STATE_W,     // 写态
    STATE_EX,
    STATE_T // 终止状态
};

// 有限状态机
struct fdm_t
{
    int state;
    int sfd;
    int dfd;
    int len;
    int pos;
    string str;
    char buf[BUFFSIZE];
};

void fsm_driver(struct fdm_t *fsm)
{
    int res;
    // 从源写到目标
    switch (fsm->state)
    {
    case STATE_R: // 读
        fsm->len = read(fsm->sfd, fsm->buf, BUFFSIZE);
        if (fsm->len == 0)
        {
            fsm->state = STATE_T; // 结束
        }
        else if (fsm->len < 0)
        {
            if (errno == EAGAIN) // 非阻塞读失败
            {
                fsm->state = STATE_R;
            }
            else // 真错
            {
                fsm->str = "读出错";
                fsm->state = STATE_EX; // 结束
            }
        }
        else // 下一步前往写状态
        {
            fsm->state = STATE_W;
            fsm->pos = 0;
        }
        break;
    case STATE_W: // 写
        res = write(fsm->dfd, (fsm->buf + fsm->pos), fsm->len);
        if (res < 0)
        {
            if (errno == EAGAIN)
            {
                fsm->state = STATE_W;
            }
            else
            {
                fsm->str = "写出错";
                fsm->state = STATE_EX; // 写出错
            }
        }
        else
        {
            fsm->len -= res;
            fsm->pos += res;
            if (fsm->len == 0) // 写完了
            {
                fsm->state = STATE_R; // 去读
            }
            else // 没写完
            {
                fsm->state = STATE_W; // 仍旧去写
            }
        }
        break;
    case STATE_EX: // 写出错
        cerr << fsm->str << endl;
        fsm->state = STATE_T;
        break;
    case STATE_T: // 结束
        break;
    default:
        break;
    }
}

void relay(int fd1, int fd2)
{
    // 将两个文件描述符改为以非阻塞打开
    int fd1_save = fcntl(fd1, F_GETFL);
    int fd2_save = fcntl(fd2, F_GETFL);
    int res1 = fcntl(fd1, F_SETFL, fd1_save | O_NONBLOCK);
    int res2 = fcntl(fd2, F_SETFL, fd2_save | O_NONBLOCK);
    cout << "设置非阻塞成功 " << res1 << " " << res2 << endl;
    struct fdm_t fsm1, fsm2;

    fsm1.state = STATE_R;
    fsm1.sfd = fd1; // 源
    fsm1.dfd = fd2; // 目标

    fsm2.state = STATE_R;
    fsm2.sfd = fd2;
    fsm2.dfd = fd1;

    //       fsm1
    // fd1----buf---->fd2
    //       fsm2
    // fd2----buf---->fd1

    while (fsm1.state != STATE_T || fsm2.state != STATE_T)
    {
        fsm_driver(&fsm1);
        fsm_driver(&fsm2);
    }

    // 恢复原来文件状态
    fcntl(fd1, F_SETFL, fd1_save);
    fcntl(fd2, F_SETFL, fd2_save);
}

int main(int argc, char **argv)
{
    int fd1, fd2;
    fd1 = open(TTY1, O_RDWR);
    if (fd1 == -1)
    {
        cerr << "fd1 open() error" << endl;
    }
    fd2 = open(TTY2, O_RDWR | O_NONBLOCK);
    if (fd2 == -1)
    {
        cerr << "fd2 open() error" << endl;
    }
    relay(fd1, fd2);

    close(fd1);
    close(fd2);
    return 0;
}
```

### 记录锁

### IO 多路转接

#### select

#### poll

#### epoll

### 异步 IO

### readv 和 writev

### readn 和 writen

### 存储映射 IO
