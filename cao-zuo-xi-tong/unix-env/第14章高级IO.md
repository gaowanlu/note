---
coverY: 0
---

# 第 14 章 高级 IO

## 高级 IO

### 非阻塞 IO

在 Linux 系统编程中，非阻塞 I/O 是一种编程模型，它允许程序在执行 I/O 操作时不被阻塞。相比于传统的阻塞 I/O 模型，在非阻塞 I/O 模型中，I/O 操作会立即返回，而不需要等待 I/O 操作完成。这使得程序可以同时处理多个 I/O 操作或者执行其他计算任务，提高了程序的并发性能。

在 Linux 中，可以使用 fcntl 系统调用或者使用套接字选项来设置非阻塞 I/O。通过将文件描述符设置为非阻塞模式，当读写操作无法立即完成时，系统调用会立即返回一个错误码，而不是一直等待直到操作完成。程序可以根据错误码判断是否需要重新尝试 I/O 操作，或者切换到处理其他任务。

需要注意的是，在非阻塞 I/O 模型中，应用程序需要不断轮询文件描述符，以便及时发现 I/O 操作的完成。可以使用轮询函数（如 select、poll、epoll）来实现这一点。同时，由于非阻塞 I/O 模型中涉及到并发访问文件描述符，因此需要考虑线程安全等问题。

总的来说，非阻塞 I/O 是 Linux 系统编程中常用的一种编程模型，它可以提高程序的并发性能，但也需要程序员考虑一些额外的问题。

#### fcntl 函数

复制文件描述符：cmd 取值为 F_DUPFD，arg 为目标文件描述符的最小值，表示将 fd 复制到一个新的文件描述符，该文件描述符的值不小于 arg。

获取/设置文件描述符标记：cmd 取值为 F_GETFD/F_SETFD，arg 为要获取/设置的标记。标记可以是 FD_CLOEXEC（表示在调用 exec 系列函数时关闭文件描述符）、FD_NONBLOCK（表示将文件描述符设置为非阻塞模式）等。

获取/设置文件状态标志：cmd 取值为 F_GETFL/F_SETFL，arg 为要获取/设置的状态标志。状态标志可以是 O_NONBLOCK（与 FD_NONBLOCK 作用相同）、O_APPEND（表示在写入文件时追加而不是覆盖）等。

获取/设置记录锁：cmd 取值为 F_GETLK/F_SETLK/F_SETLKW，arg 为要获取/设置的锁结构体。锁结构体包含锁的起始偏移量、长度、锁的类型等信息。

```cpp
#include <unistd.h>
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* arg */ );
```

### 数据中继案例

实现

```cpp
      >--read--->(buf)>---write-->
                FSM1
(tty1)                           (tty2)
                FSM2
      <--write--<(buf)<---read---<
```

代码样例

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <string>
#include <unistd.h>
#include <errno.h>

#define TTY1 "/dev/tty2"
#define TTY2 "/dev/tty3"
#define BUFFSIZE 1024

using namespace std;

// 状态机状态
enum
{
    STATE_R = 1, // 读态
    STATE_W,     // 写态
    STATE_EX,
    STATE_T // 终止状态
};

// 有限状态机
struct fdm_t
{
    int state;
    int sfd;
    int dfd;
    int len;
    int pos;
    string str;
    char buf[BUFFSIZE];
};

void fsm_driver(struct fdm_t *fsm)
{
    int res;
    // 从源写到目标
    switch (fsm->state)
    {
    case STATE_R: // 读
        fsm->len = read(fsm->sfd, fsm->buf, BUFFSIZE);
        if (fsm->len == 0)
        {
            fsm->state = STATE_T; // 结束
        }
        else if (fsm->len < 0)
        {
            if (errno == EAGAIN) // 非阻塞读失败
            {
                fsm->state = STATE_R;
            }
            else // 真错
            {
                fsm->str = "读出错";
                fsm->state = STATE_EX; // 结束
            }
        }
        else // 下一步前往写状态
        {
            fsm->state = STATE_W;
            fsm->pos = 0;
        }
        break;
    case STATE_W: // 写
        res = write(fsm->dfd, (fsm->buf + fsm->pos), fsm->len);
        if (res < 0)
        {
            if (errno == EAGAIN)
            {
                fsm->state = STATE_W;
            }
            else
            {
                fsm->str = "写出错";
                fsm->state = STATE_EX; // 写出错
            }
        }
        else
        {
            fsm->len -= res;
            fsm->pos += res;
            if (fsm->len == 0) // 写完了
            {
                fsm->state = STATE_R; // 去读
            }
            else // 没写完
            {
                fsm->state = STATE_W; // 仍旧去写
            }
        }
        break;
    case STATE_EX: // 写出错
        cerr << fsm->str << endl;
        fsm->state = STATE_T;
        break;
    case STATE_T: // 结束
        break;
    default:
        break;
    }
}

void relay(int fd1, int fd2)
{
    // 将两个文件描述符改为以非阻塞打开
    int fd1_save = fcntl(fd1, F_GETFL);
    int fd2_save = fcntl(fd2, F_GETFL);
    int res1 = fcntl(fd1, F_SETFL, fd1_save | O_NONBLOCK);
    int res2 = fcntl(fd2, F_SETFL, fd2_save | O_NONBLOCK);
    cout << "设置非阻塞成功 " << res1 << " " << res2 << endl;
    struct fdm_t fsm1, fsm2;

    fsm1.state = STATE_R;
    fsm1.sfd = fd1; // 源
    fsm1.dfd = fd2; // 目标

    fsm2.state = STATE_R;
    fsm2.sfd = fd2;
    fsm2.dfd = fd1;

    //       fsm1
    // fd1----buf---->fd2
    //       fsm2
    // fd2----buf---->fd1

    while (fsm1.state != STATE_T || fsm2.state != STATE_T)
    {
        fsm_driver(&fsm1);
        fsm_driver(&fsm2);
    }

    // 恢复原来文件状态
    fcntl(fd1, F_SETFL, fd1_save);
    fcntl(fd2, F_SETFL, fd2_save);
}

int main(int argc, char **argv)
{
    int fd1, fd2;
    fd1 = open(TTY1, O_RDWR);
    if (fd1 == -1)
    {
        cerr << "fd1 open() error" << endl;
    }
    fd2 = open(TTY2, O_RDWR | O_NONBLOCK);
    if (fd2 == -1)
    {
        cerr << "fd2 open() error" << endl;
    }
    relay(fd1, fd2);

    close(fd1);
    close(fd2);
    return 0;
}
```

### IO 多路复用

Linux 系统编程中的 IO 多路复用技术可以帮助解决以下问题：

同时处理多个 I/O 事件：在传统的阻塞式 I/O 模型中，每个 I/O 操作都会阻塞进程，只有当 I/O 操作完成后，进程才会继续执行。这种模型在同时处理多个 I/O 事件时效率很低。而 IO 多路复用可以同时监听多个 I/O 事件，当任意一个 I/O 事件就绪时，进程可以及时处理，从而提高了系统的并发处理能力。

避免无限循环等待：在传统的非阻塞式 I/O 模型中，如果一个文件描述符没有数据可读，进程会不断地轮询，这会浪费 CPU 资源。而 IO 多路复用通过监听多个文件描述符，可以有效避免无限循环等待的问题。

节省资源：在传统的多线程模型中，每个线程都需要占用一定的内存和 CPU 资源。而 IO 多路复用可以在一个线程内同时处理多个 I/O 事件，从而节省了系统资源，提高了系统的性能。

### select

select 函数是 Linux 系统编程中常用的一种 I/O 多路复用机制，它可以让程序同时监听多个文件描述符，一旦其中任何一个文件描述符有数据可读或可写，就会通知程序进行相应的处理。

函数原型

```cpp
/* According to POSIX.1-2001, POSIX.1-2008 */
#include <sys/select.h>
/* According to earlier standards */
#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>
int select(int nfds, fd_set *readfds, fd_set *writefds,
          fd_set *exceptfds, struct timeval *timeout);
//该函数的返回值是就绪的文件描述符数量,当set全为null时设置timeout可以被用作安全休眠返回值为0
struct timeval {
   long    tv_sec;         /* seconds */
   long    tv_usec;        /* microseconds */
};

/*
nfds：要监听的最大文件描述符值加1。
readfds：读文件描述符集合。
writefds：写文件描述符集合。
exceptfds：异常文件描述符集合。
timeout：超时时间。
*/
```

监听集合操作

```cpp
//从set中删除fd
void FD_CLR(int fd, fd_set *set);
//判断fd是否在set中
int  FD_ISSET(int fd, fd_set *set);
//将fd加入到set中
void FD_SET(int fd, fd_set *set);
//清空set
void FD_ZERO(fd_set *set);
```

将数据中继实例改为 select 版本

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <sys/select.h>
#include <fcntl.h>
#include <string>
#include <unistd.h>
#include <errno.h>

#define TTY1 "./temp1.o"
#define TTY2 "./temp2.o"
#define BUFFSIZE 1024

using namespace std;

// 状态机状态
enum
{
    STATE_R = 1, // 读态
    STATE_W,     // 写态
    STATE_EX,
    STATE_T // 终止状态
};

// 有限状态机
struct fdm_t
{
    int state;
    int sfd;
    int dfd;
    int len;
    int pos;
    string str;
    char buf[BUFFSIZE];
};

void fsm_driver(struct fdm_t *fsm)
{
    int res;
    // 从源写到目标
    switch (fsm->state)
    {
    case STATE_R: // 读
        fsm->len = read(fsm->sfd, fsm->buf, BUFFSIZE);
        if (fsm->len == 0)
        {
            fsm->state = STATE_T; // 结束
        }
        else if (fsm->len < 0)
        {
            if (errno == EAGAIN) // 非阻塞读失败
            {
                fsm->state = STATE_R;
            }
            else // 真错
            {
                fsm->str = "读出错";
                fsm->state = STATE_EX; // 结束
            }
        }
        else // 下一步前往写状态
        {
            fsm->state = STATE_W;
            fsm->pos = 0;
        }
        break;
    case STATE_W: // 写
        res = write(fsm->dfd, (fsm->buf + fsm->pos), fsm->len);
        if (res < 0)
        {
            if (errno == EAGAIN)
            {
                fsm->state = STATE_W;
            }
            else
            {
                fsm->str = "写出错";
                fsm->state = STATE_EX; // 写出错
            }
        }
        else
        {
            fsm->len -= res;
            fsm->pos += res;
            if (fsm->len == 0) // 写完了
            {
                fsm->state = STATE_R; // 去读
            }
            else // 没写完
            {
                fsm->state = STATE_W; // 仍旧去写
            }
        }
        break;
    case STATE_EX: // 写出错
        cerr << fsm->str << endl;
        fsm->state = STATE_T;
        break;
    case STATE_T: // 结束
        break;
    default:
        break;
    }
}

void relay(int fd1, int fd2)
{
    // 将两个文件描述符改为以非阻塞打开
    int fd1_save = fcntl(fd1, F_GETFL);
    int fd2_save = fcntl(fd2, F_GETFL);
    int res1 = fcntl(fd1, F_SETFL, fd1_save | O_NONBLOCK);
    int res2 = fcntl(fd2, F_SETFL, fd2_save | O_NONBLOCK);
    cout << "设置非阻塞成功 " << res1 << " " << res2 << endl;
    struct fdm_t fsm1, fsm2;
    fd_set rset, wset, eset;
    fsm1.state = STATE_R;
    fsm1.sfd = fd1; // 源
    fsm1.dfd = fd2; // 目标

    fsm2.state = STATE_R;
    fsm2.sfd = fd2;
    fsm2.dfd = fd1;

    //       fsm1
    // fd1----buf---->fd2
    //       fsm2
    // fd2----buf---->fd1
    while (fsm1.state != STATE_T || fsm2.state != STATE_T)
    {
        // 布置监视任务
        FD_ZERO(&rset);
        FD_ZERO(&wset);
        FD_ZERO(&eset);
        if (fsm1.state == STATE_R)
        {
            FD_SET(fsm1.sfd, &rset);
            FD_SET(fsm1.sfd, &eset);
        }
        else if (fsm1.state == STATE_W)
        {
            FD_SET(fsm1.dfd, &wset);
            FD_SET(fsm1.dfd, &eset);
        }
        if (fsm2.state == STATE_R)
        {
            FD_SET(fsm2.sfd, &rset);
            FD_SET(fsm2.sfd, &eset);
        }
        else if (fsm2.state == STATE_W)
        {
            FD_SET(fsm2.dfd, &wset);
            FD_SET(fsm2.dfd, &eset);
        }
        // 监视
        int select_res; // 状态机为W R状态时才进行select监听
        if (fsm1.state < STATE_EX && fsm2.state < STATE_EX && (select_res = select(std::max(fsm1.sfd, fsm1.dfd) + 1, &rset, &wset, &eset, nullptr)) < 0)
        {
            if (errno == EINTR) // 被信号打断
            {
                continue; // 重新监视
            }
            cerr << "select error" << endl;
            break;
        }
        // 监视结果
        if (FD_ISSET(fsm1.sfd, &eset) || FD_ISSET(fsm1.dfd, &eset))
        {
            cerr << "fd in eset" << endl;
            fsm1.state = STATE_EX;
            fsm2.state = STATE_EX;
        }
        if (fsm1.state >= STATE_EX || FD_ISSET(fsm1.sfd, &rset) || FD_ISSET(fsm2.dfd, &wset))
        {
            fsm_driver(&fsm1);
        }
        if (fsm2.state >= STATE_EX || FD_ISSET(fsm2.sfd, &rset) || FD_ISSET(fsm1.dfd, &wset))
        {
            fsm_driver(&fsm2);
        }
    }
    // 恢复原来文件状态
    fcntl(fd1, F_SETFL, fd1_save);
    fcntl(fd2, F_SETFL, fd2_save);
}

int main(int argc, char **argv)
{
    int fd1, fd2;
    fd1 = open(TTY1, O_RDWR | O_CREAT);
    if (fd1 == -1)
    {
        cerr << "fd1 open() error" << endl;
    }
    fd2 = open(TTY2, O_RDWR | O_NONBLOCK | O_CREAT);
    if (fd2 == -1)
    {
        cerr << "fd2 open() error" << endl;
    }
    relay(fd1, fd2);
    close(fd1);
    close(fd2);
    return 0;
}
```

### pselect

函数原型

```cpp
#include <sys/select.h>
int pselect(int nfds, fd_set *readfds, fd_set *writefds,
           fd_set *exceptfds, const struct timespec *timeout,
            const sigset_t *sigmask);
//pselect提供信号屏蔽,可以在pselect前进行信号屏蔽，在阻塞pselect时使用sigmask指定的信号屏蔽，pselect返回后恢复原来的信号屏蔽
struct timespec {
   long    tv_sec;         /* seconds */
   long    tv_nsec;        /* nanoseconds */
};
```

### select 监听个数限制

在 Linux 系统中，select 函数能够监听的文件描述符数量是有限制的，具体的限制取决于操作系统实现和内存限制.

在早期的 Linux 内核中，select 函数可以监听的最大文件描述符数量是 1024，这是由文件描述符集合的数据结构实现决定的。文件描述符集合通常是一个位图，位图中的每一位表示一个文件描述符，因此，一个 32 位的整数可以表示 32 个文件描述符。因此，文件描述符集合通常的实现是一个数组，数组中的每个元素都是一个 32 位的整数，能够表示 32 个文件描述符。

在早期的 Unix 系统中，文件描述符集合通常是一个长度为 32 的数组，能够监听的最大文件描述符数量就是 32 \* 32 = 1024

随着 Linux 内核的不断升级和优化，select 函数可以监听的最大文件描述符数量已经得到了很大的提高，例如在现代的 Linux 内核中，可以通过修改 FD_SETSIZE 宏定义来扩大文件描述符集合的大小，从而提高 select 函数能够监听的最大文件描述符数量。通常，FD_SETSIZE 宏定义的默认值是 1024 或者更大，可以在编译时通过修改宏定义的方式来改变文件描述符集合的大小。

总的来说，select 函数能够监听的最大文件描述符数量是有限制的，但可以通过修改操作系统配置和内存限制来提高其能力。另外，随着 I/O 多路复用技术的发展和操作系统内核的优化，还有其他更高效的 I/O 多路复用机制可以用来替代 select 函数，例如 poll、epoll 等，它们可以更加高效地处理大量的文件描述符。

### poll

poll 函数是 Linux 系统中用于 I/O 多路复用的一种机制，可以同时监视多个文件描述符的读写事件，从而避免了使用多个线程或进程来处理大量的 I/O 操作。

函数原型

```cpp
#include <poll.h>
int poll(struct pollfd *fds, nfds_t nfds, int timeout);//timeout ms
// fds：为结构体数组指针
// nfs：为数组的长度
// timeout < 0：poll函数一直阻塞，直到有事件发生。
// timeout == 0：poll函数立即返回，不阻塞，用于查询所有监视的文件描述符的状态。
// timeout > 0：poll函数等待timeout毫秒后返回，即使没有事件发生。

struct pollfd {
    int   fd;         /* file descriptor 要监视的文件描述符 */
    short events;     /* requested events 要监视的事件类型*/
    short revents;    /* returned events 实际发生的事件类型*/
};
```

关于 event 的选项

![poll的events和revents标志](../../.gitbook/assets/屏幕截图2023-04-03165355.jpg)

简单使用样例

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <fcntl.h>
#include <string>
#include <unistd.h>
#include <poll.h>
#include <errno.h>

#define TTY1 "./temp1.o"
#define TTY2 "./temp2.o"
#define MAX 1024

using namespace std;

int main(int argc, char **argv)
{
    int fd1, fd2;
    fd1 = open(TTY1, O_RDWR | O_CREAT);
    if (fd1 == -1)
    {
        cerr << "fd1 open() error" << endl;
    }
    fd2 = open(TTY2, O_RDWR | O_NONBLOCK | O_CREAT);
    if (fd2 == -1)
    {
        cerr << "fd2 open() error" << endl;
    }
    { // 非阻塞设置
        int fd1_save = fcntl(fd1, F_GETFL);
        int fd2_save = fcntl(fd2, F_GETFL);
        int res1 = fcntl(fd1, F_SETFL, fd1_save | O_NONBLOCK);
        int res2 = fcntl(fd2, F_SETFL, fd2_save | O_NONBLOCK);
        cout << "设置非阻塞成功 " << res1 << " " << res2 << endl;
    }
    // poll使用
    struct pollfd pfds[MAX];
    // 数组初始化
    for (int i = 0; i < MAX; i++)
    {
        pfds[i].fd = -1;
    }
    pfds[0].fd = fd1;
    pfds[0].events = 0;
    pfds[0].events = POLLIN | POLLOUT;
    pfds[1].fd = fd2;
    pfds[1].events = 0;
    pfds[1].events = POLLIN | POLLOUT;
    // poll监听
    int res;
    while (1)
    {
        if ((res = poll(pfds, 2, -1)) < 0)
        {
            if (errno == EINTR)
            {
                continue;
            }
            break;
        }
        for (int i = 0; i < MAX; i++)
        {
            if (pfds[i].fd != -1)
            {
                if (pfds[i].revents & POLLIN)
                {
                    cout << pfds[i].fd << "可读" << endl;
                    // 进行非阻塞IO相关操作
                }
                if (pfds[i].revents & POLLOUT)
                {
                    cout << pfds[i].fd << "可写" << endl;
                    // 进行非阻塞IO相关操作
                }
            }
        }
    }
    // poll返回0表示超时 -1表示错误
    // 调用poll后pfds数组不会被清空
    close(fd1);
    close(fd2);
    return 0;
}
```

#### poll 与 select 对比

相对于 select 函数，poll 函数的优点在于能够监听更多的文件描述符，并且对于大量文件描述符的情况下效率更高，因为 poll 函数不需要轮询所有文件描述符，而是使用内核事件通知机制来实现。另外，poll 函数还支持更细粒度的事件类型，例如 POLLPRI 表示有紧急数据可读，这是 select 函数不支持的。

select 是以事件组织描述符，得事件->检测描述符  
poll 是以描述符组织事件，得描述符->判断事件

### ppoll

函数原型

```cpp
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <signal.h>
#include <poll.h>
int ppoll(struct pollfd *fds, nfds_t nfds,
    const struct timespec *tmo_p, const sigset_t *sigmask);
```

### epoll

函数原型

#### epoll_create

参数 size 指定了创建的 epoll 实例中能够同时处理的文件描述符的数量，这个值并不是实际限制，而只是一个提示，内核会根据系统的实际情况调整这个值。当 size 被设置为 0 时，epoll_create 函数会自动选择一个合适的值。

函数返回一个文件描述符，如果创建失败，则返回-1，并设置 errno 为相应的错误码。

在使用 epoll 前，必须先调用 epoll_create 创建一个 epoll 实例，并将返回的文件描述符保存下来，以便后续的操作。每个 epoll 实例在内核中都有一个相应的事件表，用于存储所有注册在该 epoll 实例中的文件描述符及其对应的事件。

```cpp
#include <sys/epoll.h>
int epoll_create(int size);
```

#### epoll_ctl

```cpp
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
/*op:
EPOLL_CTL_ADD 将文件描述符fd添加到epoll实例中，event参数指定了fd关注的事件类型。
EPOLL_CTL_MOD 修改文件描述符fd在epoll实例中的关注事件，event参数指定了修改后的事件类型。
EPOLL_CTL_DEL 将文件描述符fd从epoll实例中删除。
*/

//参数event是一个指向epoll_event结构体的指针，
//该结构体用于指定文件描述符关注的事件类型，它的定义如下：
struct epoll_event {
    uint32_t events; /* 关注的事件类型 */
    epoll_data_t data; /* 用户数据 */
};
/*events成员表示关注的事件类型，可以是以下值的组合：
EPOLLIN：可读事件。
EPOLLOUT：可写事件。
EPOLLRDHUP：TCP连接被对端关闭，或者对端关闭了写操作。
EPOLLERR：错误事件。
EPOLLHUP：挂起事件，通常是由于连接重置或者文件描述符被关闭导致的。*/

//data成员是一个epoll_data_t类型的联合体，
//用于存储与文件描述符相关的用户数据，它的定义如下：
typedef union epoll_data {
    void *ptr;
    int fd;
    uint32_t u32;
    uint64_t u64;
} epoll_data_t;
```

epoll_ctl 函数注意事项

1、要添加或删除的文件描述符必须是已经打开的、合法的文件描述符。
2、在将文件描述符添加到 epoll 实例中之前，需要先将其设置为非阻塞模式。
3、event 参数中的 events 成员应该是需要关注的事件类型的组合，例如，如果希望关注可读事件和挂起事件，则可以设置 events 成员为 EPOLLIN | EPOLLHUP。

#### epoll_wait

```cpp
int epoll_wait(int epfd, struct epoll_event *events,
               int maxevents, int timeout);
int epoll_pwait(int epfd, struct epoll_event *events,
                int maxevents, int timeout,
                const sigset_t *sigmask);
```

简单样例

```cpp
#include <iostream>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
#include <fcntl.h>
#include <string>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>

#define TTY1 "./temp1.o"
#define TTY2 "./temp2.o"
#define MAX 1024

using namespace std;

int main(int argc, char **argv)
{
    int fd1, fd2;
    fd1 = open(TTY1, O_RDWR | O_CREAT);
    if (fd1 == -1)
    {
        cerr << "fd1 open() error" << endl;
    }
    fd2 = open(TTY2, O_RDWR | O_NONBLOCK | O_CREAT);
    if (fd2 == -1)
    {
        cerr << "fd2 open() error" << endl;
    }
    { // 非阻塞设置
        int fd1_save = fcntl(fd1, F_GETFL);
        int fd2_save = fcntl(fd2, F_GETFL);
        int res1 = fcntl(fd1, F_SETFL, fd1_save | O_NONBLOCK);
        int res2 = fcntl(fd2, F_SETFL, fd2_save | O_NONBLOCK);
        cout << "设置非阻塞成功 " << res1 << " " << res2 << endl;
    }
    // epoll
    int epfd = epoll_create(2);
    if (epfd < 0)
    {
        cerr << "epoll create error" << endl;
        exit(1);
    }
    struct epoll_event ev, events[1024];
    ev.events = EPOLLIN | EPOLLET; // ET模式
    ev.data.fd = fd1;
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd1, &ev);
    ev.events = EPOLLOUT;
    ev.data.fd = fd2;
    epoll_ctl(epfd, EPOLL_CTL_ADD, fd2, &ev);
    // 添加监听事项
    int ret;
    while (1)
    {
        if ((ret = epoll_wait(epfd, events, 1024, -1)) < 0)
        {
            if (errno == EINTR)
            {
                continue;
            }
            break;
        }
        else
        {
            for (int i = 0; i < ret; i++) // 遍历就绪集合
            {
                int fd = events[i].data.fd;
                if (fd == fd1)
                {
                    if (events[i].events & EPOLLIN)
                    {
                        cout << fd << "EPOLLIN" << endl;
                        // epoll_ctl...
                    }
                    else if (events[i].events & EPOLLOUT)
                    {
                        cout << fd << "EPOLLOUT" << endl;
                        // epoll_ctl...
                    }
                }
                else if (fd == fd2)
                {
                    if (events[i].events & EPOLLIN)
                    {
                        cout << fd << "EPOLLIN" << endl;
                        // epoll_ctl...
                    }
                    else if (events[i].events & EPOLLOUT)
                    {
                        cout << fd << "EPOLLOUT" << endl;
                        // epoll_ctl...
                    }
                }
            }
        }
    }
    close(fd1);
    close(fd2);
    return 0;
}
// fd1 的 EPOLLIN只会触发一次 因为是EPOLLET模式
// fd2 的 EPOLLOUT会一直触发
```

### select、poll、epoll 对比

I/O 触发方式

- 水平触发 LT，当一个文件描述符就绪时，会不断地通知应用程序，直到应用程序处理完这个文件描述符上的所有可读或可写数据。这种事件通知机制比较简单，但当文件描述符数量较大时，效率会有所下降。

- 边缘触发 ET，当一个文件描述符从未就绪变为就绪时，才会通知应用程序。这种事件通知机制能够有效减少通知次数，提高效率。ET 模式需要使用系统调用（如 read、write、recv、send 等）来处理所有可读或可写数据，否则可能会导致缓冲区中剩余的数据未能被处理。

- 单次触发 EPOLLONESHOT，可以在文件描述符就绪后只通知一次，需要应用程序再次调用 epoll_ctl 函数来重新将该文件描述符加入监听队列。

使用 ET 要注意的点

1、ET 模式下，每个就绪事件只会通知一次，如果应用程序没有及时处理，可能会造成事件丢失。
2、ET 模式下，应用程序需要读取所有可读或可写数据，直到 read 或 write 等系统调用返回 EAGAIN 或 EWOULDBLOCK，否则可能会导致阻塞或者缓冲区溢出。
3、ET 模式通常适用于大量连接、高并发的场景，可以减少通知次数，提高效率。

|              | select                                         | poll                                           | epoll                                                                                                  |
| ------------ | ---------------------------------------------- | ---------------------------------------------- | ------------------------------------------------------------------------------------------------------ |
| 操作方式     | 遍历                                           | 遍历                                           | 回调                                                                                                   |
| 底层实现     | 数组                                           | 链表                                           | 红黑树                                                                                                 |
| IO 效率      | 每次调用进行线性遍历 O(n)                      | 每次调用进行线性遍历 O(n)                      | 事件通知方式，每当 fd 就绪，系统注册的回调函数就会被调用，将就绪 fd 放到 rdllist 中，事件复杂度为 O(1) |
| 最大连接数   | 1024（x86）或 2048（x64）                      | 无上限                                         | 无上限                                                                                                 |
| fd 拷贝      | 每次调用，都需要把 fd 集合从用户态拷贝到内核态 | 每次调用，都需要把 fd 集合从用户态拷贝到内核态 | 调用 epoll_ctl 时拷贝进内核并保存，值后每次 epoll_wait 不拷贝                                          |
| I/O 触发方式 | 水平触发 LT                                    | 水平触发 LT                                    | LT（水平触发）、ET（边缘触发 默认）和 EPOLLONESHOT（单次触发）                                         |

### readv 和 writev

### readn 和 writen

### 异步 IO

### 记录锁

### 存储映射 IO
