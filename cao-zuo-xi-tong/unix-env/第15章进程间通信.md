---
coverY: 0
---

# 第 15 章 进程间通信

## 进程间通信

进程间的通信(InterProcess Communication,IPC)  
常见的 IPC 方式有

1、半双工管道、FIFO  
2、全双工管道、命名全双工管道  
3、消息队列、信号量、共享内存  
4、消息队列（实时）、信号量、共享存储（实时）  
5、套接字、STREAMS

### 管道 pipe

管道是一种进程间通信机制，用于在两个进程间传递数据。可以实现一种单向、基于字节流的通信方式，即一个进程将数据写入管道的一段，另一个进程从管道的另一端读取数据

#### 管道的分类

管道有两种类型：无名管道(Anonymous Pipes)和命名管道(Named Pipes)

1、无名管道（PIPE）：无名管道是在进程间临时创建的，只能在创建它们的进程及其子进程之间进行通信。无名管道的创建是通过 pipe 系统调用来实现的，调用成功后会返回两个文件描述符，一个用于读取管道中的数据，一个用于写入数据到管道中。无名管道具有较小的缓冲区，一旦缓冲区已满，写入操作将被阻塞直到读取进程读取管道中的数据。

2、命名管道（FIFO）：命名管道是在文件系统中创建的，多个进程可以通过打开同一个文件来进行通信。命名管道的创建是通过 mkfifo 系统调用来实现的，调用成功后会在文件系统中创建一个 FIFO 文件，进程可以使用 open 系统调用打开该文件并进行读写操作。命名管道具有较大的缓冲区，写入操作不会阻塞，直到缓冲区已满。

#### pipe 函数

```cpp
#include <unistd.h>
/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */
struct fd_pair {
    long fd[2];
};
struct fd_pair pipe();
/* On all other architectures */
int pipe(int pipefd[2]);// 创建一个管道，成功返回0，pipefd[0]代表管道读端，pipefd[1]代表管道写端。
```

#### pipe2 函数

pipefd: 一个长度为 2 的整型数组，用来存储新创建的管道的读取端和写入端的文件描述符。

flags: 用来设置管道的属性，可以为以下值之一：

O_CLOEXEC: 设置管道文件描述符在执行 exec 时自动关闭。
O_DIRECT: 禁止使用缓存。
O_NONBLOCK: 将管道设置为非阻塞模式。

```cpp
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int pipe2(int pipefd[2], int flags);
```

#### pipe 创建背后流程

![pipe 创建背后流程](../../.gitbook/assets/屏幕截图2023-04-05234929.jpg)

#### 管道样例

父进程向子进程发送内容的简单样例

```cpp
#include <iostream>
#include <errno.h>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
using namespace std;

#define BUFFSIZE 256

int main(int argc, char **argv)
{
    int pipefd[2];
    pid_t pid;
    char buffer[BUFFSIZE];
    if (pipe(pipefd) == -1)
    {
        cerr << "pipe error" << endl;
        exit(1);
    }
    pid = fork();
    if (pid == -1)
    {
        cerr << "fork error" << endl;
        exit(1);
    }
    if (pid == 0) // 子进程
    {
        close(pipefd[1]); // 关闭写端
        ssize_t count = read(pipefd[0], buffer, BUFFSIZE);
        if (count == -1)
        {
            cerr << "read error" << endl;
            exit(1);
        }
        cout << "child process read=> " << buffer << endl;
        close(pipefd[0]); // 关闭读端
        exit(0);          // 子进程退出
    }
    else // 父进程
    {
        close(pipefd[0]); // 关闭读端
        char message[] = "hello,child process!";
        ssize_t count = write(pipefd[1], message, strlen(message) + 1);
        if (count == -1)
        {
            cerr << "write error" << endl;
            exit(-1);
        }
        close(pipefd[1]); // 关闭写端
        cout << "father process write=> " << message << endl;
        pid_t retpid = wait(nullptr); // 等待子进程结束
        if (retpid == pid)
        {
            cout << "child process end" << endl;
        }
        cout << "father process end" << endl;
        exit(0);
    }
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
father process write=> hello,child process!
child process read=> hello,child process!
child process end
father process end
*/
```

#### popen 和 pclose 函数

popen 和 pclose 是 C 标准库中的两个函数，用于在程序中调用外部命令，并进行输入输出的操作。

函数原型

```cpp
#include <stdio.h>
FILE *popen(const char *command, const char *mode);
int pclose(FILE *stream);
```

popen，command 参数为要执行的外部命令，mode 参数为打开文件的模式（读或写）。popen 函数会创建一个管道，执行指定的命令，并返回一个 FILE 类型的文件指针，可以使用标准的文件 I/O 函数（如 fread、fwrite、fgets、fputs 等）对该文件进行读写操作。如果 mode 参数为“r”，则该文件指针指向命令的标准输出，如果 mode 参数为“w”，则该文件指针指向命令的标准输入。

pclose，stream 参数为 popen 函数返回的文件指针。pclose 函数会等待命令执行完毕，并关闭管道。如果命令执行成功，pclose 函数返回命令的退出状态，否则返回-1。

简单样例

```cpp
#include <iostream>
#include <cstdlib>
#include <unistd.h>
#include <cstdio>
using namespace std;

int main(int argc, char **argv)
{
    FILE *fp;
    char buffer[1024];
    chdir("/");
    fp = popen("ls -l", "r");
    if (fp == nullptr)
    {
        cerr << "popen error" << endl;
        exit(1);
    }
    while (fgets(buffer, sizeof(buffer), fp))
    {
        cout << buffer;
    }
    int ret_state = pclose(fp);
    cout << "\nret_state=" << ret_state << endl;
    return 0;
}
```

#### 如何用管道双向通信

当然可以在 fork 前创建两个管道，fork 后对两个管道规定读写的方向为相反，就可以实现父进程向子进程发数据同时也可以由子进程向父进程发送数据

### 协同进程

协同进程通常指一组进程通过协作的方式共同完成一个任务,出了在 fork 前预分配，也可以使用进程通信方式进程任务数据的分配等

### FIFO

```cpp
mkfifo()
mkfifoat()
```

### 消息队列

### 信号量

### 共享内存

### UNIX 域套接字

Unix 域套接字（Unix Domain Socket）是一种用于进程间通信的机制，它只能在同一台计算机上的进程之间进行通信。Unix 域套接字提供了一种可靠的、高性能的本地通信方式，与 TCP/IP 协议栈相比，它不需要经过网络协议栈的处理，因此可以获得更高的性能和更低的延迟。

Unix 域套接字的通信方式与 TCP/IP 协议栈相似，包括面向连接的 SOCK_STREAM 类型和面向消息的 SOCK_DGRAM 类型。使用 Unix 域套接字进行通信时，应用程序需要创建一个 Unix 域套接字，然后将它绑定到一个本地文件系统路径上。另一个应用程序可以通过该路径打开套接字，并使用它进行通信。这种通信方式是双向的，每个进程都可以在套接字上进行读写操作。

Unix 域套接字可以用于各种进程间通信的场景，如服务器进程与客户端进程之间的通信、进程间共享内存等。使用 Unix 域套接字可以获得比命名管道、共享内存等其他进程间通信机制更高的灵活性和性能。

### FIFO

### XSI IPC

### 客户进程-服务器进程属性
