---
coverY: 0
---

# 第 15 章 进程间通信

## 进程间通信

进程间的通信(InterProcess Communication,IPC)  
常见的 IPC 方式有

1、半双工管道、FIFO  
2、全双工管道、命名全双工管道  
3、消息队列、信号量、共享内存  
4、消息队列（实时）、信号量、共享存储（实时）  
5、套接字、STREAMS

### 管道 pipe

管道是一种进程间通信机制，用于在两个进程间传递数据。可以实现一种单向、基于字节流的通信方式，即一个进程将数据写入管道的一段，另一个进程从管道的另一端读取数据

#### 管道的分类

管道有两种类型：无名管道(Anonymous Pipes)和命名管道(Named Pipes)

1、无名管道（PIPE）：无名管道是在进程间临时创建的，只能在创建它们的进程及其子进程之间进行通信。无名管道的创建是通过 pipe 系统调用来实现的，调用成功后会返回两个文件描述符，一个用于读取管道中的数据，一个用于写入数据到管道中。无名管道具有较小的缓冲区，一旦缓冲区已满，写入操作将被阻塞直到读取进程读取管道中的数据。

2、命名管道（FIFO）：命名管道是在文件系统中创建的，多个进程可以通过打开同一个文件来进行通信。命名管道的创建是通过 mkfifo 系统调用来实现的，调用成功后会在文件系统中创建一个 FIFO 文件，进程可以使用 open 系统调用打开该文件并进行读写操作。命名管道具有较大的缓冲区，写入操作不会阻塞，直到缓冲区已满。

#### pipe 函数

```cpp
#include <unistd.h>
/* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */
struct fd_pair {
    long fd[2];
};
struct fd_pair pipe();
/* On all other architectures */
int pipe(int pipefd[2]);// 创建一个管道，成功返回0，pipefd[0]代表管道读端，pipefd[1]代表管道写端。
```

#### pipe2 函数

pipefd: 一个长度为 2 的整型数组，用来存储新创建的管道的读取端和写入端的文件描述符。

flags: 用来设置管道的属性，可以为以下值之一：

O_CLOEXEC: 设置管道文件描述符在执行 exec 时自动关闭。
O_DIRECT: 禁止使用缓存。
O_NONBLOCK: 将管道设置为非阻塞模式。

```cpp
#include <fcntl.h>              /* Obtain O_* constant definitions */
#include <unistd.h>
int pipe2(int pipefd[2], int flags);
```

#### pipe 创建背后流程

![pipe 创建背后流程](../../.gitbook/assets/屏幕截图2023-04-05234929.jpg)

#### 管道样例

父进程向子进程发送内容的简单样例

```cpp
#include <iostream>
#include <errno.h>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
using namespace std;

#define BUFFSIZE 256

int main(int argc, char **argv)
{
    int pipefd[2];
    pid_t pid;
    char buffer[BUFFSIZE];
    if (pipe(pipefd) == -1)
    {
        cerr << "pipe error" << endl;
        exit(1);
    }
    pid = fork();
    if (pid == -1)
    {
        cerr << "fork error" << endl;
        exit(1);
    }
    if (pid == 0) // 子进程
    {
        close(pipefd[1]); // 关闭写端
        ssize_t count = read(pipefd[0], buffer, BUFFSIZE);
        if (count == -1)
        {
            cerr << "read error" << endl;
            exit(1);
        }
        cout << "child process read=> " << buffer << endl;
        close(pipefd[0]); // 关闭读端
        exit(0);          // 子进程退出
    }
    else // 父进程
    {
        close(pipefd[0]); // 关闭读端
        char message[] = "hello,child process!";
        ssize_t count = write(pipefd[1], message, strlen(message) + 1);
        if (count == -1)
        {
            cerr << "write error" << endl;
            exit(-1);
        }
        close(pipefd[1]); // 关闭写端
        cout << "father process write=> " << message << endl;
        pid_t retpid = wait(nullptr); // 等待子进程结束
        if (retpid == pid)
        {
            cout << "child process end" << endl;
        }
        cout << "father process end" << endl;
        exit(0);
    }
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
father process write=> hello,child process!
child process read=> hello,child process!
child process end
father process end
*/
```

#### popen 和 pclose 函数

popen 和 pclose 是 C 标准库中的两个函数，用于在程序中调用外部命令，并进行输入输出的操作。

函数原型

```cpp
#include <stdio.h>
FILE *popen(const char *command, const char *mode);
int pclose(FILE *stream);
```

popen，command 参数为要执行的外部命令，mode 参数为打开文件的模式（读或写）。popen 函数会创建一个管道，执行指定的命令，并返回一个 FILE 类型的文件指针，可以使用标准的文件 I/O 函数（如 fread、fwrite、fgets、fputs 等）对该文件进行读写操作。如果 mode 参数为“r”，则该文件指针指向命令的标准输出，如果 mode 参数为“w”，则该文件指针指向命令的标准输入。

pclose，stream 参数为 popen 函数返回的文件指针。pclose 函数会等待命令执行完毕，并关闭管道。如果命令执行成功，pclose 函数返回命令的退出状态，否则返回-1。

简单样例

```cpp
#include <iostream>
#include <cstdlib>
#include <unistd.h>
#include <cstdio>
using namespace std;

int main(int argc, char **argv)
{
    FILE *fp;
    char buffer[1024];
    chdir("/");
    fp = popen("ls -l", "r");
    if (fp == nullptr)
    {
        cerr << "popen error" << endl;
        exit(1);
    }
    while (fgets(buffer, sizeof(buffer), fp))
    {
        cout << buffer;
    }
    int ret_state = pclose(fp);
    cout << "\nret_state=" << ret_state << endl;
    return 0;
}
```

#### 如何用管道双向通信

当然可以在 fork 前创建两个管道，fork 后对两个管道规定读写的方向为相反，就可以实现父进程向子进程发数据同时也可以由子进程向父进程发送数据

### 协同进程

协同进程通常指一组进程通过协作的方式共同完成一个任务,出了在 fork 前预分配，也可以使用进程通信方式进程任务数据的分配等

### FIFO

FIFO 是一种特殊的文件类型，也称为命名管道（named pipes），允许不同进程之间进行通信。与匿名管道不同，FIFO 在文件系统中有一个特定的文件名，因此可以由多个进程同时访问

#### 创建 FIFO mkfifo

参数 pathname 指定 FIFO 的路径名，mode 指定 FIFO 的访问权限。创建 FIFO 后，可以像打开普通文件一样打开它。

```cpp
#include <sys/types.h>
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
//函数调用成功，则返回0，如果出现错误，则返回-1。
```

简单样例

```cpp
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <cstring>
#include <errno.h>

#define PATH "/tmp/myfifo"

int main()
{
    if (mkfifo(PATH, 0666) == -1)
    {
        perror("create mkfifo error\n");
        if (errno == EEXIST)
        {
            printf(strerror(errno), "");
        }
        exit(EXIT_FAILURE);
    }
    return 0;
}
```

#### mkfifoat

在指定的文件夹下创建 FIFO

```cpp
#include <fcntl.h>           /* Definition of AT_* constants */
#include <sys/stat.h>
int mkfifoat(int dirfd, const char *pathname, mode_t mode);
```

样例

```cpp
#include <fcntl.h>
#include <sys/stat.h>

int main() {
    int dirfd = open("/tmp", O_RDONLY);
    mkfifoat(dirfd, "myfifo", 0666);
    close(dirfd);
    return 0;
}
```

#### FIFO 样例

父子进程通信、当然可以是没有血缘关系的两个进程

```cpp
#include <iostream>
#include <errno.h>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <fcntl.h>

using namespace std;

#define BUFFSIZE 256

int main(int argc, char **argv)
{
    char buffer[BUFFSIZE];
    const char *path = "/tmp/tmpfifo";
    int ret = mkfifo(path, 0666);
    int fifo = open(path, O_RDWR);
    int pid = fork();
    if (pid == -1)
    {
        cerr << "fork error" << endl;
        exit(1);
    }
    if (pid == 0) // 子进程
    {
        ssize_t count = read(fifo, buffer, BUFFSIZE);
        if (count == -1)
        {
            cerr << "read error" << endl;
            exit(1);
        }
        cout << "child process read=> " << buffer << endl;
        close(fifo);
        exit(0); // 子进程退出
    }
    else // 父进程
    {
        char message[] = "hello,child process!";
        ssize_t count = write(fifo, message, strlen(message) + 1);
        if (count == -1)
        {
            cerr << "write error" << endl;
            exit(-1);
        }
        close(fifo);
        cout << "father process write=> " << message << endl;
        pid_t retpid = wait(nullptr); // 等待子进程结束
        if (retpid == pid)
        {
            cout << "child process end" << endl;
        }
        cout << "father process end" << endl;
        if (remove(path) == 0)
        {
            cout << "fifo delete success" << endl;
        }
        exit(0);
    }
    return 0;
}
/*
gaowanlu@DESKTOP-QDLGRDB:/$ ./main
father process write=> hello,child process!
child process read=> hello,child process!
child process end
father process end
*/
```

#### FIFO 注意事项

1、FIFO 是一种特殊类型的文件，需要像操作普通文件一样打开和关闭它。在打开 FIFO 时，需要指定相应的文件访问模式，例如只读、只写或读写模式。

2、FIFO 是一种半双工通信机制，即一个进程可以向管道写入数据，另一个进程可以从管道读取数据，但不能同时进行。因此，在使用 FIFO 进行通信时，需要分别创建读写进程，并确保它们在适当的时候打开和关闭 FIFO 文件描述符。

3、FIFO 是基于字节流的，它不保留消息的边界，因此在从 FIFO 中读取数据时，需要进行适当的数据处理，以确保正确地解析消息。

4、如果要使用多个 FIFO 进行通信，需要使用不同的 FIFO 文件名来避免冲突。建议使用唯一的、具有描述性的 FIFO 名称来避免混淆。

5、FIFO 是基于文件系统的，因此如果 FIFO 文件被删除或文件系统故障，通信将中断。在使用 FIFO 进行通信时，需要考虑这些情况，并采取适当的恢复措施。

### 管道的读写阻塞

在 Unix 和类 Unix 系统中，管道和 FIFO 的写操作和读操作都是阻塞的，也就是说，如果没有读进程读取管道中的数据，写进程将一直阻塞等待，直到有读进程读取数据为止。同样地，如果管道已满（即写进程写入数据的速度比读进程读取数据的速度快），写进程将一直阻塞等待，直到有足够的空间写入数据为止。

类似地，如果没有数据可读取，读进程将一直阻塞等待，直到有写进程写入数据为止。如果管道为空（即读进程读取数据的速度比写进程写入数据的速度快），读进程将一直阻塞等待，直到有数据可读取为止。

需要注意的是，管道和 FIFO 都是单向的，如果需要进行双向通信，需要创建两个管道或 FIFO。

### XSI IPC

XSI IPC（X/Open System Interface Inter-Process Communication）是 UNIX 系统中一组标准的进程间通信（IPC）机制，由 X/Open 组织制定并发布。

XSI IPC 包括三种主要的 IPC 机制：消息队列（message queues）、信号量（semaphores）和共享内存（shared memory），它们可以在进程之间传递数据、同步进程和共享内存等。这些机制都提供了一些函数和系统调用，以供进程进行访问和操作。

相比于传统的 IPC 机制（如管道、套接字等），XSI IPC 提供了更高级、更强大和更灵活的 IPC 功能，可以实现更复杂的进程间通信和同步。它们还提供了一些可靠性和性能方面的优势，如消息队列可以在进程之间异步传递数据、信号量可以实现进程之间的同步、共享内存可以实现进程之间高效地共享数据等。

需要链接库

```shell
gcc -o program program.c -lrt -lipc
```

```shell
gaowanlu@DESKTOP-QDLGRDB:/$ ipcs

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
```

### XSI IPC 权限结构

在头文件、sys/ipc.h 中

ipc_perm 结构体中的这些信息可以用于控制对 IPC 对象的访问权限，从而保护 IPC 对象的安全性和可靠性。其中，**key、uid、gid、cuid、cgid 和**seq 字段是只读的，不能通过应用程序修改。mode 字段可以使用 IPC 对象创建函数的 mode 参数来指定，或者使用系统调用 chmod 修改 IPC 对象的权限。

```cpp
struct ipc_perm{
    uid_t uid;//IPC对象所有者的有效用户ID
    gid_t gid;//IPC对象所有者的有效组ID
    uid_t cuid;//IPC对象创建者的有效用户ID
    gid_t cgid;//IPC对象创建者的有效组ID
    mode_t mode;//IPC对象的权限模式，由创建者指定
    key_t __key;//IPC对象的键值，由IPC对象创建函数（如msgget、semget、shmget）指定
    unsigned short __seq;//IPC对象的序列号，用于防止IPC对象的重复使用。
};
```

### 消息队列

消息队列（message queue）是一种 IPC 机制，用于在进程之间异步传递消息。消息队列提供了一种可靠的、异步的、有序的进程间通信方式，适用于需要传递大量数据或需要独立的进程间通信的应用程序。

Linux 系统中的消息队列通过 System V IPC 机制实现，包括三个主要的系统调用：msgget、msgsnd 和 msgrcv。

#### msqid_ds 结构

每一个队列都有一个 msqid_ds 结构与其关联 在头文件 sys/msg.h

```cpp
struct msqid_ds {
    //消息队列的权限信息，包括UID、GID、权限位等
    struct ipc_perm msg_perm;   /* Ownership and permissions */
    //消息队列的最后一次发送时间
    time_t          msg_stime;  /* Time of last msgsnd(2) */
    //消息队列的最后一次接收时间
    time_t          msg_rtime;  /* Time of last msgrcv(2) */
    //消息队列的最后一次修改时间
    time_t          msg_ctime;  /* Time of last change */
    //消息队列当前的字节数
    unsigned long   __msg_cbytes;/* Current number of bytes in queue */
    //消息队列中当前的消息数量
    msgqnum_t       msg_qnum;   /* Current number of messages in queue */
    //消息队列的最大字节数
    msglen_t        msg_qbytes; /* Maximum number of bytes allowed in queue */
    //最后一个发送消息的进程ID
    pid_t           msg_lspid;  /* PID of last msgsnd(2) */
    //最后一个接收消息的进程ID
    pid_t           msg_lrpid;  /* PID of last msgrcv(2) */
};
```

#### ftok 函数

convert a pathname and a project identifier to a System V IPC key

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
key_t ftok(const char *pathname, int proj_id)
```

特殊的key_t 

IPC_PRIVATE用于创建一个新的IPC对象，例如新的共享内存区域、新的消息队列或新的信号量集等。通过指定IPC_PRIVATE标志符，可以保证创建的新IPC对象是唯一的，并且只能由当前进程及其子进程访问。

#### 消息队列收发内容格式

mtype 是消息的类型，通常为正整数，用于在发送和接收消息时标识消息的种类。  
mtext 是消息的内容，可以是任何数据类型的数据，实际大小可以超过 1 个字节，需要根据具体情况动态分配存储空间。

```cpp
struct msgbuf {
    long mtype;      /* 消息类型 */
    char mtext[1];   /* 消息内容，实际长度可以超过 1 个字节 */
};
```

#### msgget 函数

get a System V message queue identifier,用于创建或获取一个消息队列

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgget(key_t key, int msgflg);
// If  msgflg  specifies both IPC_CREAT and IPC_EXCL and a message queue already exists for key, then msgget() fails with errno set to EEXIST.
// IPC_EXCL是System V IPC（包括消息队列、信号量、共享内存等）的一个标志位，用于创建IPC资源时控制是否允许创建已经存在的IPC对象
```

#### msgctl 函数

用于对消息队列进行控制操作

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgctl(int msqid, int cmd, struct msqid_ds *buf);
```

其中：

msqid 是消息队列标识符（ID），用于指定要操作的消息队列。  
cmd 是操作命令，用于指定要执行的操作。常用的命令有：  
IPC_STAT：获取消息队列的状态信息，将其存储在 buf 中。  
IPC_SET：设置消息队列的状态信息，使用 buf 中的内容进行设置。  
IPC_RMID：删除消息队列，释放其占用的资源。  
buf 是 struct msqid_ds 结构体类型的指针，用于存储消息队列的状态信息。

msgctl() 函数的返回值为执行成功或失败的标志。若函数执行成功，返回值为 0；若函数执行失败，返回值为 -1，并设置相应的错误码。

#### msgsnd 函数

用于向消息队列发送消息

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);
```

其中：

msqid 是消息队列标识符（ID），用于指定要发送消息的消息队列。  
msgp 是指向要发送的消息的指针，类型为 struct msgbuf，包含了消息的类型和内容。  
msgsz 是消息的大小，以字节为单位。  
msgflg 是发送消息的选项，用于指定消息发送的行为。常用的选项有：  
IPC_NOWAIT：如果消息队列已满，不阻塞，立即返回，并设置错误码 EAGAIN。  
MSG_NOERROR：如果消息的大小大于消息队列的最大大小，截断消息并发送成功，不阻塞，不设置错误码。

msgsnd() 函数的返回值为执行成功或失败的标志。若函数执行成功，返回值为 0；若函数执行失败，返回值为 -1，并设置相应的错误码。

#### msgrcv 函数

用于从消息队列中接收消息

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

其中：

msqid 是消息队列标识符（ID），用于指定要接收消息的消息队列。  
msgp 是指向接收消息的缓冲区的指针，类型为 struct msgbuf，用于存储接收到的消息的类型和内容。  
msgsz 是缓冲区的大小，以字节为单位，表示可以接收的最大消息大小。  
msgtyp 是要接收的消息类型。如果值为 0，则接收队列中的第一条消息；如果值大于 0，则接收队列中类型为该值的第一条消息；如果值小于 0，则接收队列中类型值小于或等于该值的绝对值的第一条消息。  
msgflg 是接收消息的选项，用于指定接收消息的行为。常用的选项有：  
IPC_NOWAIT：如果消息队列为空，不阻塞，立即返回，并设置错误码 ENOMSG。  
MSG_NOERROR：如果消息的大小大于缓冲区的大小，截断消息并接收成功，不阻塞，不设置错误码。

msgrcv() 函数的返回值为接收到的消息的长度，即消息的实际大小（字节数）。若函数执行失败，返回值为 -1，并设置相应的错误码。

#### 消息队列样例

父子进程通信样例

```cpp
root@drecbb4udzdboiei-0626900:/mes/temp# ./main
Message queue created successfully.
child process send end
child process end
father process end
IPC_RMID
```

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <cstring>
#include <unistd.h>
using namespace std;

struct mymsgbuf
{
    long mtype;       /* 消息类型 */
    char mtext[1024]; /* 消息内容，实际长度可以超过 1 个字节 */
};

int main(int argc, char **argv)
{
    // 创建IPC键值
    key_t key = ftok("/tmp", 'a');
    if (key < 0)
    {
        perror("ftok");
        exit(EXIT_FAILURE);
    }
    // 创建消息队列
    int msgid = msgget(key, IPC_CREAT | IPC_EXCL | 0666);
    if (msgid == -1) // 出错
    {
        if (errno == EEXIST)
        {
            printf("Message queue already exists.\n");
        }
        else
        {
            printf("Failed to create message queue: %s\n", strerror(errno));
            exit(1);
        }
    }
    printf("Message queue created successfully.\n");
    int pid = fork();
    if (pid == -1)
    {
        cerr << "fork error" << endl;
        exit(1);
    }
    // 子进程
    if (pid == 0)
    {
        struct mymsgbuf buffer;
        buffer.mtype = 0;
        strcpy(buffer.mtext, "hello world\n");
        int ret = msgsnd(msgid, &buffer, sizeof(buffer), IPC_NOWAIT);
        while (ret == -1 && errno == EAGAIN)
        {
            ret = msgsnd(msgid, &buffer, sizeof(buffer), IPC_NOWAIT);
        }
        cout << "child process send end" << endl;
        exit(0); // 子进程退出
    }
    else // 父进程
    {
        struct mymsgbuf buffer;
        ssize_t len = msgrcv(msgid, &buffer, sizeof(buffer) - sizeof(long), 0, IPC_NOWAIT);
        if (len == sizeof(buffer))
        {
            cout << "father process read :" << buffer.mtext << endl;
        }
        pid_t retpid = wait(nullptr); // 等待子进程结束
        if (retpid == pid)
        {
            cout << "child process end" << endl;
        }
        cout << "father process end" << endl;
        // 销毁消息队列
        struct msqid_ds msgds;
        if (0 == msgctl(msgid, IPC_RMID, &msgds))
        {
            cout << "IPC_RMID" << endl;
        }
        exit(0);
    }
    return 0;
}
```

### 信号量

信号量（Semaphore）是一种用于进程同步和互斥的机制,可以用来解决多个进程同时访问共享资源的问题，保证进程之间的互斥和同步。

在Linux中，信号量是由内核维护的一种计数器，它的值通常为非负整数。进程可以通过信号量来协调对共享资源的访问，以保证同一时刻只有一个进程能够访问该资源。进程可以通过原子操作来增加或减少信号量的值，并且可以阻塞等待信号量的值达到某个特定的值。

每个信号量由一个无名结构表示，至少包含下列成员

```cpp
struct {
    unsigned short semval;//semaphore value,always >=0
    pid_t sempid;//pid for last operation
    unsigned short semncnt;//processes awaiting semval>curval
    unsigned short semzcnt;//processes awaiting semval==0
}
```

#### semid_ds 结构

该结构体定义在<sys/sem.h>头文件中

```cpp
struct semid_ds {
    struct ipc_perm sem_perm;  /* Ownership and permissions */
    //最近一次semop操作的时间
    time_t sem_otime;          /* Last semop time */
    //最近一次修改信号量集的时间
    time_t sem_ctime;          /* Last change time */
    //信号量集中包含的信号量数量
    unsigned short sem_nsems;  /* No. of semaphores in set */
    ...
};
```

#### semget 函数

semget()是一个用于创建或获取一个信号量集的函数。该函数可以用于获取一个已经存在的信号量集或创建一个新的信号量集。

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semget(key_t key, int nsems, int semflg);
```

其中，key是信号量集的键值，用于标识信号量集的唯一性；nsems是信号量集中包含的信号量个数；semflg是用于指定信号量集的创建标志，它可以是IPC_CREAT表示创建信号量集，IPC_EXCL表示创建时如果信号量已存在则返回错误(EEXIST)，IPC_NOWAIT表示不等待，直接返回。

semget()函数的返回值是一个信号量集标识符（semaphore set identifier），用于标识该信号量集。

#### semop 函数

semop()函数是一个用于对信号量进行操作的函数，它可以用于增加或减少信号量的值，或者等待信号量的值达到特定的条件等。

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semop(int semid, struct sembuf *sops, size_t nsops);
```

其中，semid是信号量集标识符，用于标识要操作的信号量集；sops是一个指向sembuf结构体的数组，其中每个sembuf结构体描述了一个要进行的信号量操作；nsops表示sops数组中sembuf结构体的数量。

```cpp
struct sembuf {
    unsigned short sem_num;  /* Semaphore number */
    short          sem_op;   /* Semaphore operation */
    short          sem_flg;  /* Operation flags IPC_NOWAIT、SEM_UNDO*/
};
```

其中

sem_num表示要操作的信号量的编号，从0开始计数；  
sem_op表示要进行的操作，它可以是一个正整数、0、或一个负整数；当sem_op为正整数时，表示要将信号量的值增加sem_op(指定SEM_UNDO则减去sem_op)；当sem_op为负整数时，表示要获取由该信号量控制的资源；当sem_op为0时，表示调用进程希望等待到信号量值变为0； 
sem_flag可选 IPC_NOWAIT与SEM_UNDO  

#### semctl 函数

semctl()是一个用于控制信号量集的函数。它可以用于获取、设置、删除信号量集，以及对信号量进行操作等。

```cpp
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semctl(int semid, int semnum, int cmd, .../*union semun arg*/);
union semun{
    int val;/*for SETVAL*/
    struct semid_ds *buf;/*for IPC_STAT and IPC_SET*/
    unsigned short *array;/*for GETALL and SETALL*/
    struct seminfo  *__buf;/* Buffer for IPC_INFO(Linux-specific)*/
}
```

其中，semid是信号量集标识符，用于标识要控制的信号量集；semnum是要操作的信号量编号，它从0开始计数；cmd是要执行的操作命令，它可以是  
IPC_RMID表示删除信号量集  
IPC_SET表示设置信号量集的属性  
IPC_STAT表示获取信号量集的状态信息  
GETVAL返回成员semnum的semval值  
SETVAL设置成员semnum的semval值，值由arg.val指定；  
GETPID返回成员semnum的sempid值  
GETNCNT返回成员semnum的semncnt值  
GETZCNT返回成员semnum的semzcnt值  
GETALL返回成员semnum的sempid值，值存储在arg.array指向的数组中  
SETALL将集合中所有信号量值设置为arg.array指向的数组中的值  
第四个参数是根据操作命令不同而不同的。

#### 信号量样例

父进程“P”，子进程“V”

```cpp
#include <iostream>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <cstring>
#include <unistd.h>
using namespace std;

union semun
{
    int val;               /*for SETVAL*/
    struct semid_ds *buf;  /*for IPC_STAT and IPC_SET*/
    unsigned short *array; /*for GETALL and SETALL*/
    struct seminfo *__buf; /* Buffer for IPC_INFO(Linux-specific)*/
};

int main(int argc, char **argv)
{
    // 创建信号量集
    int sems_id = semget(IPC_PRIVATE, 1, IPC_CREAT | IPC_EXCL | 0666);
    if (sems_id == -1)
    {
        if (errno != EEXIST)
        {
            cerr << strerror(errno) << endl;
            exit(1);
        }
    }
    // 初始化信号量
    union semun m_semun;
    m_semun.val = 0;
    if (-1 == semctl(sems_id, 0, SETVAL, m_semun))
    {
        cerr << strerror(errno) << endl;
        exit(1);
    }
    int pid = fork();
    if (pid == -1)
    {
        cerr << "fork error" << endl;
        exit(1);
    }
    // 子进程
    if (pid == 0)
    {
        for (int i = 0; i < 10; i++) // 消耗10个资源
        {
            struct sembuf m_sembuf[1];
            m_sembuf[0].sem_num = 0;
            m_sembuf[0].sem_op = -1; // 要1个 "P"操作
            m_sembuf[0].sem_flg = 0; // 默认等待
            int ret = semop(sems_id, m_sembuf, 1);
            while (ret == -1 && errno == EINTR)
            {
                ret = semop(sems_id, m_sembuf, 1);
            }
            cout << "child " << i << endl;
        }
        exit(0); // 子进程退出
    }
    else // 父进程
    {
        for (int i = 0; i < 10; i++)
        {
            struct sembuf m_sembuf[1];
            m_sembuf[0].sem_num = 0;
            m_sembuf[0].sem_op = 1;  // 加1个 "V"操作
            m_sembuf[0].sem_flg = 0; // 默认等待
            int ret = semop(sems_id, m_sembuf, 1);
            while (ret == -1 && errno == EINTR)
            {
                ret = semop(sems_id, m_sembuf, 1);
            }
            cout << "father " << i << endl;
            sleep(1);
        }
        // 等待子进程
        int ret_pid = wait(nullptr);
        // 删除信号量集
        if (0 == semctl(sems_id, 0, IPC_RMID))
        {
            cout << "delete sem success" << endl;
        }
        exit(0);
    }
    return 0;
}
```

### 共享内存

### 客户进程-服务器进程属性

### UNIX 域套接字

Unix 域套接字（Unix Domain Socket）是一种用于进程间通信的机制，它只能在同一台计算机上的进程之间进行通信。Unix 域套接字提供了一种可靠的、高性能的本地通信方式，与 TCP/IP 协议栈相比，它不需要经过网络协议栈的处理，因此可以获得更高的性能和更低的延迟。

Unix 域套接字的通信方式与 TCP/IP 协议栈相似，包括面向连接的 SOCK_STREAM 类型和面向消息的 SOCK_DGRAM 类型。使用 Unix 域套接字进行通信时，应用程序需要创建一个 Unix 域套接字，然后将它绑定到一个本地文件系统路径上。另一个应用程序可以通过该路径打开套接字，并使用它进行通信。这种通信方式是双向的，每个进程都可以在套接字上进行读写操作。

Unix 域套接字可以用于各种进程间通信的场景，如服务器进程与客户端进程之间的通信、进程间共享内存等。使用 Unix 域套接字可以获得比命名管道、共享内存等其他进程间通信机制更高的灵活性和性能。
